{"version":3,"sources":["../../../../src/dash/DashHandler.js"],"names":["DashHandler","config","context","eventBus","events","debug","dashConstants","urlUtils","type","streamInfo","timelineConverter","dashMetrics","baseURLController","instance","logger","segmentIndex","lastSegment","requestedTime","isDynamicManifest","dynamicStreamCompleted","selectedMimeType","segmentsController","setup","getLogger","resetInitialSettings","create","on","INITIALIZATION_LOADED","onInitializationLoaded","SEGMENTS_LOADED","onSegmentsLoaded","REPRESENTATION_UPDATE_STARTED","onRepresentationUpdateStarted","DYNAMIC_STREAM_COMPLETED","onDynamicStreamCompleted","initialize","isDynamic","getStreamId","id","getType","getStreamInfo","setCurrentIndex","value","getCurrentIndex","resetIndex","reset","off","setRequestUrl","request","destination","representation","baseURL","resolve","path","url","serviceLocation","isRelative","generateInitRequest","mediaInfo","mediaType","FragmentRequest","period","adaptation","presentationStartTime","start","HTTPRequest","INIT_SEGMENT_TYPE","range","availabilityStartTime","calcAvailabilityStartTimeFromPresentationTime","mpd","availabilityEndTime","calcAvailabilityEndTimeFromPresentationTime","duration","quality","index","representationId","initialization","bandwidth","getInitRequest","setMimeType","newMimeType","setExpectedLiveEdge","liveEdge","updateManifestUpdateInfo","e","processRepresentation","voRepresentation","hasInitialization","hasSegments","trigger","REPRESENTATION_UPDATE_COMPLETED","update","getRequestForSegment","segment","undefined","manifest","Period_asArray","AdaptationSet_asArray","Representation_asArray","media","replacementNumber","replacementTime","MEDIA_SEGMENT_TYPE","mediaRange","startTime","timescale","wallStartTime","availabilityIdx","adaptationIndex","isMediaFinished","isFinished","availableSegmentsNumber","time","parseFloat","toFixed","endTime","getSegmentRequestForTime","options","segmentInfoType","idx","keepIdx","ignoreIsFinished","getSegmentByTime","finished","action","ACTION_COMPLETE","SEGMENT_TIMELINE","getNextSegmentRequest","indexToRequest","getSegmentByIndex","mediaStartTime","isEndlessMedia","isFinite","segments","error","fragments","count","i","len","s","seg","length","push","segmentAvailabilityRange","end","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"DashHandler.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport FragmentRequest from '../streaming/vo/FragmentRequest';\r\nimport { HTTPRequest } from '../streaming/vo/metrics/HTTPRequest';\r\nimport FactoryMaker from '../core/FactoryMaker';\r\nimport {\r\n    replaceIDForTemplate,\r\n    unescapeDollarsInTemplate,\r\n    replaceTokenForTemplate,\r\n    getTimeBasedSegment\r\n} from './utils/SegmentsUtils';\r\n\r\nimport SegmentsController from './controllers/SegmentsController';\r\n\r\nfunction DashHandler(config) {\r\n\r\n    config = config || {};\r\n    const context = this.context;\r\n\r\n    const eventBus = config.eventBus;\r\n    const events = config.events;\r\n    const debug = config.debug;\r\n    const dashConstants = config.dashConstants;\r\n    const urlUtils = config.urlUtils;\r\n    const type = config.type;\r\n    const streamInfo = config.streamInfo;\r\n\r\n    const timelineConverter = config.timelineConverter;\r\n    const dashMetrics = config.dashMetrics;\r\n    const baseURLController = config.baseURLController;\r\n\r\n    let instance,\r\n        logger,\r\n        segmentIndex,\r\n        lastSegment,\r\n        requestedTime,\r\n        isDynamicManifest,\r\n        dynamicStreamCompleted,\r\n        selectedMimeType,\r\n        segmentsController;\r\n\r\n    function setup() {\r\n        logger = debug.getLogger(instance);\r\n        resetInitialSettings();\r\n\r\n        segmentsController = SegmentsController(context).create(config);\r\n\r\n        eventBus.on(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\r\n        eventBus.on(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\r\n        eventBus.on(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\r\n        eventBus.on(events.DYNAMIC_STREAM_COMPLETED, onDynamicStreamCompleted, instance);\r\n    }\r\n\r\n    function initialize(isDynamic) {\r\n        isDynamicManifest = isDynamic;\r\n        dynamicStreamCompleted = false;\r\n        segmentsController.initialize(isDynamic);\r\n    }\r\n\r\n    function getStreamId() {\r\n        return streamInfo.id;\r\n    }\r\n\r\n    function getType() {\r\n        return type;\r\n    }\r\n\r\n    function getStreamInfo() {\r\n        return streamInfo;\r\n    }\r\n\r\n    function setCurrentIndex (value) {\r\n        segmentIndex = value;\r\n    }\r\n\r\n    function getCurrentIndex () {\r\n        return segmentIndex;\r\n    }\r\n\r\n    function resetIndex() {\r\n        segmentIndex = -1;\r\n        lastSegment = null;\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        resetIndex();\r\n        requestedTime = null;\r\n        segmentsController = null;\r\n        selectedMimeType = null;\r\n    }\r\n\r\n    function reset() {\r\n        resetInitialSettings();\r\n\r\n        eventBus.off(events.INITIALIZATION_LOADED, onInitializationLoaded, instance);\r\n        eventBus.off(events.SEGMENTS_LOADED, onSegmentsLoaded, instance);\r\n        eventBus.off(events.REPRESENTATION_UPDATE_STARTED, onRepresentationUpdateStarted, instance);\r\n        eventBus.off(events.DYNAMIC_STREAM_COMPLETED, onDynamicStreamCompleted, instance);\r\n    }\r\n\r\n    function setRequestUrl(request, destination, representation) {\r\n        const baseURL = baseURLController.resolve(representation.path);\r\n        let url,\r\n            serviceLocation;\r\n\r\n        if (!baseURL || (destination === baseURL.url) || (!urlUtils.isRelative(destination))) {\r\n            url = destination;\r\n        } else {\r\n            url = baseURL.url;\r\n            serviceLocation = baseURL.serviceLocation;\r\n\r\n            if (destination) {\r\n                url = urlUtils.resolve(destination, url);\r\n            }\r\n        }\r\n\r\n        if (urlUtils.isRelative(url)) {\r\n            return false;\r\n        }\r\n\r\n        request.url = url;\r\n        request.serviceLocation = serviceLocation;\r\n\r\n        return true;\r\n    }\r\n\r\n    function generateInitRequest(mediaInfo, representation, mediaType) {\r\n        const request = new FragmentRequest();\r\n        const period = representation.adaptation.period;\r\n        const presentationStartTime = period.start;\r\n\r\n        request.mediaType = mediaType;\r\n        request.type = HTTPRequest.INIT_SEGMENT_TYPE;\r\n        request.range = representation.range;\r\n        request.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(presentationStartTime, period.mpd, isDynamicManifest);\r\n        request.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationStartTime + period.duration, period.mpd, isDynamicManifest);\r\n        request.quality = representation.index;\r\n        request.mediaInfo = mediaInfo;\r\n        request.representationId = representation.id;\r\n\r\n        if (setRequestUrl(request, representation.initialization, representation)) {\r\n            request.url = replaceTokenForTemplate(request.url, 'Bandwidth', representation.bandwidth);\r\n            return request;\r\n        }\r\n    }\r\n\r\n    function getInitRequest(mediaInfo, representation) {\r\n        if (!representation) return null;\r\n        const request = generateInitRequest(mediaInfo, representation, getType());\r\n        return request;\r\n    }\r\n\r\n    function setMimeType(newMimeType) {\r\n        selectedMimeType = newMimeType;\r\n    }\r\n\r\n    function setExpectedLiveEdge(liveEdge) {\r\n        timelineConverter.setExpectedLiveEdge(liveEdge);\r\n        dashMetrics.updateManifestUpdateInfo({presentationStartTime: liveEdge});\r\n    }\r\n\r\n    function onRepresentationUpdateStarted(e) {\r\n        processRepresentation(e.representation);\r\n    }\r\n\r\n    function processRepresentation(voRepresentation) {\r\n        const hasInitialization = voRepresentation.hasInitialization();\r\n        const hasSegments = voRepresentation.hasSegments();\r\n\r\n        // If representation has initialization and segments information, REPRESENTATION_UPDATE_COMPLETED can be triggered immediately\r\n        // otherwise, it means that a request has to be made to get initialization and/or segments informations\r\n        if (hasInitialization && hasSegments) {\r\n            eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED, { representation: voRepresentation }, streamInfo.id, type);\r\n        } else {\r\n            segmentsController.update(voRepresentation, selectedMimeType, hasInitialization, hasSegments);\r\n        }\r\n    }\r\n\r\n    function getRequestForSegment(mediaInfo, segment) {\r\n        if (segment === null || segment === undefined) {\r\n            return null;\r\n        }\r\n\r\n        const request = new FragmentRequest();\r\n        const representation = segment.representation;\r\n        const bandwidth = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\r\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].bandwidth;\r\n        let url = segment.media;\r\n\r\n        url = replaceTokenForTemplate(url, 'Number', segment.replacementNumber);\r\n        url = replaceTokenForTemplate(url, 'Time', segment.replacementTime);\r\n        url = replaceTokenForTemplate(url, 'Bandwidth', bandwidth);\r\n        url = replaceIDForTemplate(url, representation.id);\r\n        url = unescapeDollarsInTemplate(url);\r\n\r\n        request.mediaType = getType();\r\n        request.type = HTTPRequest.MEDIA_SEGMENT_TYPE;\r\n        request.range = segment.mediaRange;\r\n        request.startTime = segment.presentationStartTime;\r\n        request.duration = segment.duration;\r\n        request.timescale = representation.timescale;\r\n        request.availabilityStartTime = segment.availabilityStartTime;\r\n        request.availabilityEndTime = segment.availabilityEndTime;\r\n        request.wallStartTime = segment.wallStartTime;\r\n        request.quality = representation.index;\r\n        request.index = segment.availabilityIdx;\r\n        request.mediaInfo = mediaInfo;\r\n        request.adaptationIndex = representation.adaptation.index;\r\n        request.representationId = representation.id;\r\n\r\n        if (setRequestUrl(request, url, representation)) {\r\n            return request;\r\n        }\r\n    }\r\n\r\n    function isMediaFinished(representation) {\r\n        let isFinished = false;\r\n\r\n        if (!representation) return isFinished;\r\n\r\n        if (!isDynamicManifest) {\r\n            if (segmentIndex >= representation.availableSegmentsNumber) {\r\n                isFinished = true;\r\n            }\r\n        } else {\r\n            if (dynamicStreamCompleted) {\r\n                isFinished = true;\r\n            } else if (lastSegment) {\r\n                const time = parseFloat((lastSegment.presentationStartTime - representation.adaptation.period.start).toFixed(5));\r\n                const endTime = lastSegment.duration > 0 ? time + 1.5 * lastSegment.duration : time;\r\n                const duration = representation.adaptation.period.duration;\r\n\r\n                isFinished = endTime >= duration;\r\n            }\r\n        }\r\n        return isFinished;\r\n    }\r\n\r\n    function getSegmentRequestForTime(mediaInfo, representation, time, options) {\r\n        let request = null;\r\n\r\n        if (!representation || !representation.segmentInfoType) {\r\n            return request;\r\n        }\r\n\r\n        const idx = segmentIndex;\r\n        const keepIdx = options ? options.keepIdx : false;\r\n        const ignoreIsFinished = (options && options.ignoreIsFinished) ? true : false;\r\n\r\n        if (requestedTime !== time) { // When playing at live edge with 0 delay we may loop back with same time and index until it is available. Reduces verboseness of logs.\r\n            requestedTime = time;\r\n            logger.debug('Getting the request for time : ' + time);\r\n        }\r\n\r\n        const segment = segmentsController.getSegmentByTime(representation, time);\r\n        if (segment) {\r\n            segmentIndex = segment.availabilityIdx;\r\n            lastSegment = segment;\r\n            logger.debug('Index for time ' + time + ' is ' + segmentIndex);\r\n            request = getRequestForSegment(mediaInfo, segment);\r\n        } else {\r\n            const finished = !ignoreIsFinished ? isMediaFinished(representation) : false;\r\n            if (finished) {\r\n                request = new FragmentRequest();\r\n                request.action = FragmentRequest.ACTION_COMPLETE;\r\n                request.index = segmentIndex - 1;\r\n                request.mediaType = type;\r\n                request.mediaInfo = mediaInfo;\r\n                logger.debug('Signal complete in getSegmentRequestForTime');\r\n            }\r\n        }\r\n\r\n        if (keepIdx && idx >= 0) {\r\n            segmentIndex = representation.segmentInfoType === dashConstants.SEGMENT_TIMELINE && isDynamicManifest ? segmentIndex : idx;\r\n        }\r\n\r\n        return request;\r\n    }\r\n\r\n    function getNextSegmentRequest(mediaInfo, representation) {\r\n        let request = null;\r\n\r\n        if (!representation || !representation.segmentInfoType) {\r\n            return null;\r\n        }\r\n\r\n        requestedTime = null;\r\n\r\n        const indexToRequest = segmentIndex + 1;\r\n        logger.debug('Getting the next request at index: ' + indexToRequest);\r\n\r\n        // check that there is a segment in this index\r\n        const segment = segmentsController.getSegmentByIndex(representation, indexToRequest, lastSegment ? lastSegment.mediaStartTime : -1);\r\n        if (!segment && isEndlessMedia(representation) && !dynamicStreamCompleted) {\r\n            logger.debug(getType() + ' No segment found at index: ' + indexToRequest + '. Wait for next loop');\r\n            return null;\r\n        } else {\r\n            if (segment) {\r\n                request = getRequestForSegment(mediaInfo, segment);\r\n                segmentIndex = segment.availabilityIdx;\r\n            } else {\r\n                if (isDynamicManifest) {\r\n                    segmentIndex = indexToRequest - 1;\r\n                } else {\r\n                    segmentIndex = indexToRequest;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (segment) {\r\n            lastSegment = segment;\r\n        } else {\r\n            const finished = isMediaFinished(representation, segment);\r\n            if (finished) {\r\n                request = new FragmentRequest();\r\n                request.action = FragmentRequest.ACTION_COMPLETE;\r\n                request.index = segmentIndex - 1;\r\n                request.mediaType = getType();\r\n                request.mediaInfo = mediaInfo;\r\n                logger.debug('Signal complete');\r\n            }\r\n        }\r\n\r\n        return request;\r\n    }\r\n\r\n    function isEndlessMedia(representation) {\r\n        return !isFinite(representation.adaptation.period.duration);\r\n    }\r\n\r\n    function onInitializationLoaded(e) {\r\n        const representation = e.representation;\r\n        if (!representation.segments) return;\r\n\r\n        eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED, { representation: representation }, streamInfo.id, type);\r\n    }\r\n\r\n    function onSegmentsLoaded(e) {\r\n        if (e.error) return;\r\n\r\n        const fragments = e.segments;\r\n        const representation = e.representation;\r\n        const segments = [];\r\n        let count = 0;\r\n\r\n        let i,\r\n            len,\r\n            s,\r\n            seg;\r\n\r\n        for (i = 0, len = fragments ? fragments.length : 0; i < len; i++) {\r\n            s = fragments[i];\r\n\r\n            seg = getTimeBasedSegment(\r\n                timelineConverter,\r\n                isDynamicManifest,\r\n                representation,\r\n                s.startTime,\r\n                s.duration,\r\n                s.timescale,\r\n                s.media,\r\n                s.mediaRange,\r\n                count);\r\n\r\n            if (seg) {\r\n                segments.push(seg);\r\n                seg = null;\r\n                count++;\r\n            }\r\n        }\r\n\r\n        if (segments.length > 0) {\r\n            representation.segmentAvailabilityRange = {start: segments[0].presentationStartTime, end: segments[segments.length - 1].presentationStartTime};\r\n            representation.availableSegmentsNumber = segments.length;\r\n            representation.segments = segments;\r\n\r\n            if (isDynamicManifest) {\r\n                const lastSegment = segments[segments.length - 1];\r\n                const liveEdge = lastSegment.presentationStartTime - 8;\r\n                // the last segment is the Expected, not calculated, live edge.\r\n                setExpectedLiveEdge(liveEdge);\r\n            }\r\n        }\r\n\r\n        if (!representation.hasInitialization()) {\r\n            return;\r\n        }\r\n\r\n        eventBus.trigger(events.REPRESENTATION_UPDATE_COMPLETED, { representation: representation }, streamInfo.id, type);\r\n    }\r\n\r\n    function onDynamicStreamCompleted() {\r\n        logger.debug('Dynamic stream complete');\r\n        dynamicStreamCompleted = true;\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        getStreamId: getStreamId,\r\n        getType: getType,\r\n        getStreamInfo: getStreamInfo,\r\n        getInitRequest: getInitRequest,\r\n        getRequestForSegment: getRequestForSegment,\r\n        getSegmentRequestForTime: getSegmentRequestForTime,\r\n        getNextSegmentRequest: getNextSegmentRequest,\r\n        setCurrentIndex: setCurrentIndex,\r\n        getCurrentIndex: getCurrentIndex,\r\n        isMediaFinished: isMediaFinished,\r\n        reset: reset,\r\n        resetIndex: resetIndex,\r\n        setMimeType: setMimeType\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nDashHandler.__dashjs_factory_name = 'DashHandler';\r\nexport default FactoryMaker.getClassFactory(DashHandler);\r\n"]}