{"version":3,"sources":["../../../../src/streaming/Stream.js"],"names":["Stream","config","context","eventBus","getInstance","urlUtils","manifestModel","mediaPlayerModel","manifestUpdater","adapter","capabilities","errHandler","timelineConverter","dashMetrics","abrController","playbackController","eventController","mediaController","textController","protectionController","videoModel","settings","streamInfo","instance","logger","streamProcessors","isStreamInitialized","isStreamActivated","isMediaInitialized","hasVideoTrack","hasAudioTrack","updateError","isUpdating","fragmentController","thumbnailController","preloaded","boxParser","preloadingScheduled","debug","isEndedEventSignaled","trackChangedEvent","codecCompatibilityTable","setup","getLogger","resetInitialSettings","create","dashConstants","DashConstants","initialize","registerEvents","registerProtectionEvents","on","Events","BUFFERING_COMPLETED","onBufferingCompleted","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","INBAND_EVENTS","onInbandEvents","unRegisterEvents","off","KEY_ERROR","onProtectionError","SERVER_CERTIFICATE_UPDATED","LICENSE_REQUEST_COMPLETE","KEY_SYSTEM_SELECTED","KEY_SESSION_CREATED","KEY_STATUSES_CHANGED","unRegisterProtectionEvents","getStreamId","id","activate","mediaSource","previousBuffers","result","CURRENT_TRACK_CHANGED","onCurrentTrackChanged","getPreloaded","initializeMedia","initializeAfterPreload","deactivate","keepBuffers","ln","length","errored","i","fragmentModel","getFragmentModel","removeExecutedRequestsBeforeTime","getStartTime","getDuration","reset","setPreloaded","isActive","setMediaSource","isMediaSupported","getMediaInfo","splice","dischargePreBuffer","msg","error","DashJSError","Errors","MANIFEST_ERROR_ID_NOSTREAMS_CODE","getValue","fatal","pause","duration","NaN","getIsEndedEventSignaled","setIsEndedEventSignaled","value","start","getPreloadingScheduled","setPreloadingScheduled","getLiveStartTime","manifestInfo","isDynamic","getType","Constants","AUDIO","VIDEO","getId","getStreamInfo","getHasAudioTrack","getHasVideoTrack","getThumbnailController","checkConfig","hasOwnProperty","Error","MISSING_CONFIG_ERROR","getBitrateListFor","type","IMAGE","getBitrateList","mediaInfo","event","message","codec","MUXED","MANIFEST_ERROR_ID_MULTIPLEXED_CODE","TEXT","FRAGMENTED_TEXT","EMBEDDED_TEXT","contentProtection","supportsEncryptedMedia","CAPABILITY_MEDIAKEYS_ERROR_CODE","CAPABILITY_MEDIAKEYS_ERROR_MESSAGE","supportsCodec","e","newMediaInfo","manifest","setCurrentMediaInfo","processor","getProcessorForMediaInfo","currentTime","getTime","info","refreshManifestOnSwitchTrack","refreshManifest","selectMediaInfo","updateTopQualityIndex","switchTrackAsked","abortRequests","getScheduleController","setSeekTarget","setBufferingTime","resetIndexHandler","createStreamProcessor","allMediaForType","optionalSettings","getModel","streamProcessor","mimeType","baseURLController","setBuffer","buffer","replaceIdx","push","ignoreMediaInfo","idx","index","addMediaInfo","initializeMediaForType","getAllMediaInfoForType","initialMediaInfo","addEmbeddedTrack","addTrack","getTracksFor","events","checkInitialMediaSettingsForType","getCurrentTrackFor","trigger","STREAM_INITIALIZING","addInlineEvents","getEventsFor","addInbandEvents","element","getElement","filterCodecs","test","nodeName","buffers","createBuffers","checkIfInitializationCompleted","realAdaptation","getAdaptationForType","Array","isArray","Representation_asArray","filter","_","getCodec","hasError","audio","video","DATA_UPDATE_FAILED_ERROR_CODE","DATA_UPDATE_FAILED_ERROR_MESSAGE","initializeForMedia","setTimeSyncCompleted","STREAM_INITIALIZED","liveStartTime","createBuffer","getBuffer","streamId","processors","getProcessors","warn","isBufferingCompleted","STREAM_BUFFERING_COMPLETED","mediaType","arr","updateData","updatedStreamInfo","updateStreamInfo","getMediaInfoForType","oldMediaInfo","undefined","isMediaCodecCompatible","newStream","compareCodecs","isProtectionCompatible","stream","compareProtectionConfig","newStreamInfo","currentStreamInfo","newAdaptation","currentAdaptation","ContentProtection","sameMimeType","oldCodecs","map","representation","codecs","newCodecs","codecMatch","some","newCodec","indexOf","partialCodecMatch","oldCodec","codecRootCompatibleWithCodec","codec1","codec2","codecRoot","split","rootCompatible","compatTableCodec","compatibleCodecs","compatibleCodec","preload","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"Stream.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport Constants from './constants/Constants';\r\nimport DashConstants from '../dash/constants/DashConstants';\r\nimport StreamProcessor from './StreamProcessor';\r\nimport FragmentController from './controllers/FragmentController';\r\nimport ThumbnailController from './thumbnail/ThumbnailController';\r\nimport EventBus from '../core/EventBus';\r\nimport Events from '../core/events/Events';\r\nimport Debug from '../core/Debug';\r\nimport Errors from '../core/errors/Errors';\r\nimport FactoryMaker from '../core/FactoryMaker';\r\nimport DashJSError from './vo/DashJSError';\r\nimport BoxParser from './utils/BoxParser';\r\nimport URLUtils from './utils/URLUtils';\r\n\r\nfunction Stream(config) {\r\n\r\n    config = config || {};\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n    const urlUtils = URLUtils(context).getInstance();\r\n\r\n    const manifestModel = config.manifestModel;\r\n    const mediaPlayerModel = config.mediaPlayerModel;\r\n    const manifestUpdater = config.manifestUpdater;\r\n    const adapter = config.adapter;\r\n    const capabilities = config.capabilities;\r\n    const errHandler = config.errHandler;\r\n    const timelineConverter = config.timelineConverter;\r\n    const dashMetrics = config.dashMetrics;\r\n    const abrController = config.abrController;\r\n    const playbackController = config.playbackController;\r\n    const eventController = config.eventController;\r\n    const mediaController = config.mediaController;\r\n    const textController = config.textController;\r\n    const protectionController = config.protectionController;\r\n    const videoModel = config.videoModel;\r\n    const settings = config.settings;\r\n    let streamInfo = config.streamInfo;\r\n\r\n    let instance,\r\n        logger,\r\n        streamProcessors,\r\n        isStreamInitialized,\r\n        isStreamActivated,\r\n        isMediaInitialized,\r\n        hasVideoTrack,\r\n        hasAudioTrack,\r\n        updateError,\r\n        isUpdating,\r\n        fragmentController,\r\n        thumbnailController,\r\n        preloaded,\r\n        boxParser,\r\n        preloadingScheduled,\r\n        debug,\r\n        isEndedEventSignaled,\r\n        trackChangedEvent;\r\n\r\n    const codecCompatibilityTable = [\r\n        {\r\n            'codec': 'avc1',\r\n            'compatibleCodecs': ['avc3']\r\n        },\r\n        {\r\n            'codec': 'avc3',\r\n            'compatibleCodecs': ['avc1']\r\n        }\r\n    ];\r\n\r\n    function setup() {\r\n        debug = Debug(context).getInstance();\r\n        logger = debug.getLogger(instance);\r\n        resetInitialSettings();\r\n\r\n        boxParser = BoxParser(context).getInstance();\r\n\r\n        fragmentController = FragmentController(context).create({\r\n            streamInfo: streamInfo,\r\n            mediaPlayerModel: mediaPlayerModel,\r\n            dashMetrics: dashMetrics,\r\n            errHandler: errHandler,\r\n            settings: settings,\r\n            boxParser: boxParser,\r\n            dashConstants: DashConstants,\r\n            urlUtils: urlUtils\r\n        });\r\n    }\r\n\r\n    function initialize() {\r\n        registerEvents();\r\n        registerProtectionEvents();\r\n    }\r\n\r\n    function registerEvents() {\r\n        eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\r\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\r\n        eventBus.on(Events.INBAND_EVENTS, onInbandEvents, instance);\r\n    }\r\n\r\n    function unRegisterEvents() {\r\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\r\n        eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\r\n        eventBus.off(Events.INBAND_EVENTS, onInbandEvents, instance);\r\n    }\r\n\r\n    function registerProtectionEvents() {\r\n        if (protectionController) {\r\n            eventBus.on(Events.KEY_ERROR, onProtectionError, instance);\r\n            eventBus.on(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\r\n            eventBus.on(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\r\n            eventBus.on(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\r\n            eventBus.on(Events.KEY_SESSION_CREATED, onProtectionError, instance);\r\n            eventBus.on(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\r\n        }\r\n    }\r\n\r\n    function unRegisterProtectionEvents() {\r\n        if (protectionController) {\r\n            eventBus.off(Events.KEY_ERROR, onProtectionError, instance);\r\n            eventBus.off(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\r\n            eventBus.off(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\r\n            eventBus.off(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\r\n            eventBus.off(Events.KEY_SESSION_CREATED, onProtectionError, instance);\r\n            eventBus.off(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\r\n        }\r\n    }\r\n\r\n    function getStreamId() {\r\n        return streamInfo ? streamInfo.id : null;\r\n    }\r\n\r\n    /**\r\n     * Activates Stream by re-initializing some of its components\r\n     * @param {MediaSource} mediaSource\r\n     * @memberof Stream#\r\n     * @param {SourceBuffer} previousBuffers\r\n     */\r\n    function activate(mediaSource, previousBuffers) {\r\n        if (!isStreamActivated) {\r\n            let result;\r\n            eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\r\n            if (!getPreloaded()) {\r\n                result = initializeMedia(mediaSource, previousBuffers);\r\n            } else {\r\n                initializeAfterPreload();\r\n                result = previousBuffers;\r\n            }\r\n            isStreamActivated = true;\r\n            return result;\r\n        }\r\n        return previousBuffers;\r\n    }\r\n\r\n    /**\r\n     * Partially resets some of the Stream elements\r\n     * @memberof Stream#\r\n     * @param {boolean} keepBuffers\r\n     */\r\n    function deactivate(keepBuffers) {\r\n        let ln = streamProcessors ? streamProcessors.length : 0;\r\n        const errored = false;\r\n        for (let i = 0; i < ln; i++) {\r\n            let fragmentModel = streamProcessors[i].getFragmentModel();\r\n            fragmentModel.removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\r\n            streamProcessors[i].reset(errored, keepBuffers);\r\n        }\r\n        streamProcessors = [];\r\n        isStreamActivated = false;\r\n        isMediaInitialized = false;\r\n        setPreloaded(false);\r\n        eventBus.off(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\r\n    }\r\n\r\n    function isActive() {\r\n        return isStreamActivated;\r\n    }\r\n\r\n    function setMediaSource(mediaSource) {\r\n        for (let i = 0; i < streamProcessors.length;) {\r\n            if (isMediaSupported(streamProcessors[i].getMediaInfo())) {\r\n                streamProcessors[i].setMediaSource(mediaSource);\r\n                i++;\r\n            } else {\r\n                streamProcessors[i].reset();\r\n                streamProcessors.splice(i, 1);\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < streamProcessors.length; i++) {\r\n            //Adding of new tracks to a stream processor isn't guaranteed by the spec after the METADATA_LOADED state\r\n            //so do this after the buffers are created above.\r\n            streamProcessors[i].dischargePreBuffer();\r\n        }\r\n\r\n        if (streamProcessors.length === 0) {\r\n            const msg = 'No streams to play.';\r\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg + 'nostreams', manifestModel.getValue()));\r\n            logger.fatal(msg);\r\n        }\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        deactivate();\r\n        isStreamInitialized = false;\r\n        hasVideoTrack = false;\r\n        hasAudioTrack = false;\r\n        updateError = {};\r\n        isUpdating = false;\r\n        preloadingScheduled = false;\r\n        isEndedEventSignaled = false;\r\n    }\r\n\r\n    function reset() {\r\n\r\n        if (playbackController) {\r\n            playbackController.pause();\r\n        }\r\n\r\n        if (fragmentController) {\r\n            fragmentController.reset();\r\n            fragmentController = null;\r\n        }\r\n\r\n        streamInfo = null;\r\n\r\n        resetInitialSettings();\r\n\r\n        unRegisterEvents();\r\n\r\n        unRegisterProtectionEvents();\r\n\r\n        setPreloaded(false);\r\n    }\r\n\r\n    function getDuration() {\r\n        return streamInfo ? streamInfo.duration : NaN;\r\n    }\r\n\r\n    function getIsEndedEventSignaled() {\r\n        return isEndedEventSignaled;\r\n    }\r\n\r\n    function setIsEndedEventSignaled(value) {\r\n        isEndedEventSignaled = value;\r\n    }\r\n\r\n    function getStartTime() {\r\n        return streamInfo ? streamInfo.start : NaN;\r\n    }\r\n\r\n    function getPreloadingScheduled() {\r\n        return preloadingScheduled;\r\n    }\r\n\r\n    function setPreloadingScheduled(value) {\r\n        preloadingScheduled = value;\r\n    }\r\n\r\n    function getLiveStartTime() {\r\n        if (!streamInfo.manifestInfo.isDynamic) return NaN;\r\n        // Get live start time of the video stream (1st in array of streams)\r\n        // or audio if no video stream\r\n        for (let i = 0; i < streamProcessors.length; i++) {\r\n            if (streamProcessors[i].getType() === Constants.AUDIO ||\r\n                streamProcessors[i].getType() === Constants.VIDEO) {\r\n                return streamProcessors[i].getLiveStartTime();\r\n            }\r\n        }\r\n        return NaN;\r\n    }\r\n\r\n    function getId() {\r\n        return streamInfo ? streamInfo.id : null;\r\n    }\r\n\r\n    function getStreamInfo() {\r\n        return streamInfo;\r\n    }\r\n\r\n    function getHasAudioTrack() {\r\n        return hasAudioTrack;\r\n    }\r\n\r\n    function getHasVideoTrack() {\r\n        return hasVideoTrack;\r\n    }\r\n\r\n    function getThumbnailController() {\r\n        return thumbnailController;\r\n    }\r\n\r\n    function checkConfig() {\r\n        if (!videoModel || !abrController || !abrController.hasOwnProperty('getBitrateList') || !adapter || !adapter.hasOwnProperty('getAllMediaInfoForType') || !adapter.hasOwnProperty('getEventsFor')) {\r\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {string} type\r\n     * @returns {Array}\r\n     * @memberof Stream#\r\n     */\r\n    function getBitrateListFor(type) {\r\n        checkConfig();\r\n        if (type === Constants.IMAGE) {\r\n            if (!thumbnailController) {\r\n                return [];\r\n            }\r\n            return thumbnailController.getBitrateList();\r\n        }\r\n        const mediaInfo = getMediaInfo(type);\r\n        return abrController.getBitrateList(mediaInfo);\r\n    }\r\n\r\n    function onProtectionError(event) {\r\n        if (event.error) {\r\n            errHandler.error(event.error);\r\n            logger.fatal(event.error.message);\r\n            reset();\r\n        }\r\n    }\r\n\r\n    function isMediaSupported(mediaInfo) {\r\n        const type = mediaInfo ? mediaInfo.type : null;\r\n        let codec,\r\n            msg;\r\n\r\n        if (type === Constants.MUXED) {\r\n            msg = 'Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines';\r\n            logger.fatal(msg);\r\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_MULTIPLEXED_CODE, msg, manifestModel.getValue()));\r\n            return false;\r\n        }\r\n\r\n        if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT || type === Constants.EMBEDDED_TEXT || type === Constants.IMAGE) {\r\n            return true;\r\n        }\r\n        codec = mediaInfo.codec;\r\n        logger.debug(type + ' codec: ' + codec);\r\n\r\n        if (!!mediaInfo.contentProtection && !capabilities.supportsEncryptedMedia()) {\r\n            errHandler.error(new DashJSError(Errors.CAPABILITY_MEDIAKEYS_ERROR_CODE, Errors.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE));\r\n        } else if (!capabilities.supportsCodec(codec)) {\r\n            msg = type + 'Codec (' + codec + ') is not supported.';\r\n            logger.error(msg);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function onCurrentTrackChanged(e) {\r\n        if (!streamInfo || e.newMediaInfo.streamInfo.id !== streamInfo.id) return;\r\n        let mediaInfo = e.newMediaInfo;\r\n        let manifest = manifestModel.getValue();\r\n\r\n        adapter.setCurrentMediaInfo(streamInfo.id, mediaInfo.type, mediaInfo);\r\n\r\n        let processor = getProcessorForMediaInfo(mediaInfo);\r\n        if (!processor) return;\r\n\r\n        let currentTime = playbackController.getTime();\r\n        logger.info('Stream -  Process track changed at current time ' + currentTime);\r\n\r\n        logger.debug('Stream -  Update stream controller');\r\n        if (manifest.refreshManifestOnSwitchTrack) { // Applies only for MSS streams\r\n            logger.debug('Stream -  Refreshing manifest for switch track');\r\n            trackChangedEvent = e;\r\n            manifestUpdater.refreshManifest();\r\n        } else {\r\n            processor.selectMediaInfo(mediaInfo);\r\n            if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) {\r\n                abrController.updateTopQualityIndex(mediaInfo);\r\n                processor.switchTrackAsked();\r\n                processor.getFragmentModel().abortRequests();\r\n            } else {\r\n                processor.getScheduleController().setSeekTarget(currentTime);\r\n                processor.setBufferingTime(currentTime);\r\n                processor.resetIndexHandler();\r\n            }\r\n        }\r\n    }\r\n\r\n    function createStreamProcessor(mediaInfo, allMediaForType, mediaSource, optionalSettings) {\r\n\r\n        let fragmentModel = fragmentController.getModel(mediaInfo ? mediaInfo.type : null);\r\n\r\n        let streamProcessor = StreamProcessor(context).create({\r\n            streamInfo: streamInfo,\r\n            type: mediaInfo ? mediaInfo.type : null,\r\n            mimeType: mediaInfo ? mediaInfo.mimeType : null,\r\n            timelineConverter: timelineConverter,\r\n            adapter: adapter,\r\n            manifestModel: manifestModel,\r\n            mediaPlayerModel: mediaPlayerModel,\r\n            fragmentModel: fragmentModel,\r\n            dashMetrics: config.dashMetrics,\r\n            baseURLController: config.baseURLController,\r\n            abrController: abrController,\r\n            playbackController: playbackController,\r\n            mediaController: mediaController,\r\n            textController: textController,\r\n            errHandler: errHandler,\r\n            settings: settings,\r\n            boxParser: boxParser\r\n        });\r\n\r\n        streamProcessor.initialize(mediaSource, hasVideoTrack);\r\n        abrController.updateTopQualityIndex(mediaInfo);\r\n\r\n        if (optionalSettings) {\r\n            streamProcessor.setBuffer(optionalSettings.buffer);\r\n            streamProcessor.setBufferingTime(optionalSettings.currentTime);\r\n            streamProcessors[optionalSettings.replaceIdx] = streamProcessor;\r\n        } else {\r\n            streamProcessors.push(streamProcessor);\r\n        }\r\n\r\n        if (optionalSettings && optionalSettings.ignoreMediaInfo) {\r\n            return;\r\n        }\r\n\r\n        if (mediaInfo && (mediaInfo.type === Constants.TEXT || mediaInfo.type === Constants.FRAGMENTED_TEXT)) {\r\n            let idx;\r\n            for (let i = 0; i < allMediaForType.length; i++) {\r\n                if (allMediaForType[i].index === mediaInfo.index) {\r\n                    idx = i;\r\n                }\r\n                streamProcessor.addMediaInfo(allMediaForType[i]); //creates text tracks for all adaptations in one stream processor\r\n            }\r\n            streamProcessor.selectMediaInfo(allMediaForType[idx]); //sets the initial media info\r\n        } else {\r\n            streamProcessor.addMediaInfo(mediaInfo, true);\r\n        }\r\n    }\r\n\r\n    function initializeMediaForType(type, mediaSource) {\r\n        const allMediaForType = adapter.getAllMediaInfoForType(streamInfo, type);\r\n\r\n        let mediaInfo = null;\r\n        let initialMediaInfo;\r\n\r\n        if (!allMediaForType || allMediaForType.length === 0) {\r\n            logger.info('No ' + type + ' data.');\r\n            return;\r\n        }\r\n\r\n        if (type === Constants.VIDEO) {\r\n            hasVideoTrack = true;\r\n        }\r\n\r\n        if (type === Constants.AUDIO) {\r\n            hasAudioTrack = true;\r\n        }\r\n\r\n        for (let i = 0, ln = allMediaForType.length; i < ln; i++) {\r\n            mediaInfo = allMediaForType[i];\r\n\r\n            if (type === Constants.EMBEDDED_TEXT) {\r\n                textController.addEmbeddedTrack(mediaInfo);\r\n            } else {\r\n                if (!isMediaSupported(mediaInfo)) continue;\r\n                mediaController.addTrack(mediaInfo);\r\n            }\r\n        }\r\n\r\n        if (type === Constants.EMBEDDED_TEXT || mediaController.getTracksFor(type, streamInfo).length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (type === Constants.IMAGE) {\r\n            thumbnailController = ThumbnailController(context).create({\r\n                streamInfo: streamInfo,\r\n                adapter: adapter,\r\n                baseURLController: config.baseURLController,\r\n                timelineConverter: config.timelineConverter,\r\n                debug: debug,\r\n                eventBus: eventBus,\r\n                events: Events,\r\n                dashConstants: DashConstants\r\n            });\r\n            return;\r\n        }\r\n\r\n\r\n        mediaController.checkInitialMediaSettingsForType(type, streamInfo);\r\n        initialMediaInfo = mediaController.getCurrentTrackFor(type, streamInfo);\r\n\r\n        eventBus.trigger(Events.STREAM_INITIALIZING, {\r\n            streamInfo: streamInfo,\r\n            mediaInfo: mediaInfo\r\n        });\r\n\r\n        // TODO : How to tell index handler live/duration?\r\n        // TODO : Pass to controller and then pass to each method on handler?\r\n\r\n        createStreamProcessor(initialMediaInfo, allMediaForType, mediaSource);\r\n    }\r\n\r\n    function addInlineEvents() {\r\n        if (eventController) {\r\n            const events = adapter.getEventsFor(streamInfo);\r\n            eventController.addInlineEvents(events);\r\n        }\r\n    }\r\n\r\n    function addInbandEvents(events) {\r\n        if (eventController) {\r\n            eventController.addInbandEvents(events);\r\n        }\r\n    }\r\n\r\n    function initializeMedia(mediaSource, previousBuffers) {\r\n        checkConfig();\r\n        let element = videoModel.getElement();\r\n\r\n        addInlineEvents();\r\n\r\n        isUpdating = true;\r\n\r\n        filterCodecs(Constants.VIDEO);\r\n        filterCodecs(Constants.AUDIO);\r\n\r\n        if (!element || (element && (/^VIDEO$/i).test(element.nodeName))) {\r\n            initializeMediaForType(Constants.VIDEO, mediaSource);\r\n        }\r\n        initializeMediaForType(Constants.AUDIO, mediaSource);\r\n        initializeMediaForType(Constants.TEXT, mediaSource);\r\n        initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\r\n        initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\r\n        initializeMediaForType(Constants.MUXED, mediaSource);\r\n        initializeMediaForType(Constants.IMAGE, mediaSource);\r\n\r\n        //TODO. Consider initialization of TextSourceBuffer here if embeddedText, but no sideloadedText.\r\n        const buffers = createBuffers(previousBuffers);\r\n\r\n        isMediaInitialized = true;\r\n        isUpdating = false;\r\n\r\n        if (streamProcessors.length === 0) {\r\n            const msg = 'No streams to play.';\r\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\r\n            logger.fatal(msg);\r\n        } else {\r\n            checkIfInitializationCompleted();\r\n        }\r\n\r\n        return buffers;\r\n    }\r\n\r\n    function initializeAfterPreload() {\r\n        isUpdating = true;\r\n        checkConfig();\r\n        filterCodecs(Constants.VIDEO);\r\n        filterCodecs(Constants.AUDIO);\r\n\r\n        isMediaInitialized = true;\r\n        isUpdating = false;\r\n        if (streamProcessors.length === 0) {\r\n            const msg = 'No streams to play.';\r\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\r\n            logger.debug(msg);\r\n        } else {\r\n            checkIfInitializationCompleted();\r\n        }\r\n    }\r\n\r\n    function filterCodecs(type) {\r\n        const realAdaptation = adapter.getAdaptationForType(streamInfo ? streamInfo.index : null, type, streamInfo);\r\n\r\n        if (!realAdaptation || !Array.isArray(realAdaptation.Representation_asArray)) return;\r\n\r\n        // Filter codecs that are not supported\r\n        realAdaptation.Representation_asArray = realAdaptation.Representation_asArray.filter((_, i) => {\r\n            // keep at least codec from lowest representation\r\n            if (i === 0) return true;\r\n\r\n            const codec = adapter.getCodec(realAdaptation, i, true);\r\n            if (!capabilities.supportsCodec(codec)) {\r\n                logger.error('[Stream] codec not supported: ' + codec);\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n\r\n    function checkIfInitializationCompleted() {\r\n        const ln = streamProcessors.length;\r\n        const hasError = !!updateError.audio || !!updateError.video;\r\n        let error = hasError ? new DashJSError(Errors.DATA_UPDATE_FAILED_ERROR_CODE, Errors.DATA_UPDATE_FAILED_ERROR_MESSAGE) : null;\r\n\r\n        for (let i = 0; i < ln; i++) {\r\n            if (streamProcessors[i].isUpdating() || isUpdating) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (!isMediaInitialized) {\r\n            return;\r\n        }\r\n\r\n        if (protectionController) {\r\n            // Need to check if streamProcessors exists because streamProcessors\r\n            // could be cleared in case an error is detected while initializing DRM keysystem\r\n            for (let i = 0; i < ln && streamProcessors[i]; i++) {\r\n                if (streamProcessors[i].getType() === Constants.AUDIO ||\r\n                    streamProcessors[i].getType() === Constants.VIDEO ||\r\n                    streamProcessors[i].getType() === Constants.FRAGMENTED_TEXT) {\r\n                    protectionController.initializeForMedia(streamProcessors[i].getMediaInfo());\r\n                }\r\n            }\r\n        }\r\n\r\n        if (error) {\r\n            errHandler.error(error);\r\n        } else if (!isStreamInitialized) {\r\n            isStreamInitialized = true;\r\n            timelineConverter.setTimeSyncCompleted(true);\r\n\r\n            eventBus.trigger(Events.STREAM_INITIALIZED, {\r\n                streamInfo: streamInfo,\r\n                liveStartTime: getLiveStartTime()\r\n            });\r\n        }\r\n\r\n        // (Re)start ScheduleController:\r\n        // - in case stream initialization has been completed after 'play' event (case for SegmentBase streams)\r\n        // - in case stream is complete but a track switch has been requested\r\n        for (let i = 0; i < ln && streamProcessors[i]; i++) {\r\n            streamProcessors[i].getScheduleController().start();\r\n        }\r\n    }\r\n\r\n    function getMediaInfo(type) {\r\n        let streamProcessor = null;\r\n\r\n        for (let i = 0; i < streamProcessors.length; i++) {\r\n            streamProcessor = streamProcessors[i];\r\n\r\n            if (streamProcessor.getType() === type) {\r\n                return streamProcessor.getMediaInfo();\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    function createBuffers(previousBuffers) {\r\n        const buffers = {};\r\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\r\n            const buffer = streamProcessors[i].createBuffer(previousBuffers);\r\n            if (buffer) {\r\n                buffers[streamProcessors[i].getType()] = buffer.getBuffer();\r\n            }\r\n        }\r\n        return buffers;\r\n    }\r\n\r\n    function onBufferingCompleted(e) {\r\n        if (e.streamId !== streamInfo.id) return;\r\n\r\n        let processors = getProcessors();\r\n        const ln = processors.length;\r\n\r\n        if (ln === 0) {\r\n            logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined');\r\n            return;\r\n        }\r\n\r\n        // if there is at least one buffer controller that has not completed buffering yet do nothing\r\n        for (let i = 0; i < ln; i++) {\r\n            //if audio or video buffer is not buffering completed state, do not send STREAM_BUFFERING_COMPLETED\r\n            if (!processors[i].isBufferingCompleted() && (processors[i].getType() === Constants.AUDIO || processors[i].getType() === Constants.VIDEO)) {\r\n                logger.warn('onBufferingCompleted - One streamProcessor has finished but', processors[i].getType(), 'one is not buffering completed');\r\n                return;\r\n            }\r\n        }\r\n\r\n        logger.debug('onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED');\r\n        eventBus.trigger(Events.STREAM_BUFFERING_COMPLETED, {\r\n            streamInfo: streamInfo\r\n        });\r\n    }\r\n\r\n    function onDataUpdateCompleted(e) {\r\n        updateError[e.mediaType] = e.error;\r\n        checkIfInitializationCompleted();\r\n    }\r\n\r\n    function onInbandEvents(e) {\r\n        addInbandEvents(e.events);\r\n    }\r\n\r\n    function getProcessorForMediaInfo(mediaInfo) {\r\n        if (!mediaInfo) {\r\n            return null;\r\n        }\r\n\r\n        let processors = getProcessors();\r\n\r\n        return processors.filter(function (processor) {\r\n            return (processor.getType() === mediaInfo.type);\r\n        })[0];\r\n    }\r\n\r\n    function getProcessors() {\r\n        let arr = [];\r\n\r\n        let type,\r\n            streamProcessor;\r\n\r\n        for (let i = 0; i < streamProcessors.length; i++) {\r\n            streamProcessor = streamProcessors[i];\r\n            type = streamProcessor.getType();\r\n\r\n            if (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) {\r\n                arr.push(streamProcessor);\r\n            }\r\n        }\r\n\r\n        return arr;\r\n    }\r\n\r\n    function updateData(updatedStreamInfo) {\r\n        logger.info('Manifest updated... updating data system wide.');\r\n\r\n        isStreamActivated = false;\r\n        isUpdating = true;\r\n        streamInfo = updatedStreamInfo;\r\n\r\n        if (eventController) {\r\n            addInlineEvents();\r\n        }\r\n\r\n        filterCodecs(Constants.VIDEO);\r\n        filterCodecs(Constants.AUDIO);\r\n\r\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\r\n            let streamProcessor = streamProcessors[i];\r\n            streamProcessor.updateStreamInfo(streamInfo);\r\n            let mediaInfo = adapter.getMediaInfoForType(streamInfo, streamProcessor.getType());\r\n            abrController.updateTopQualityIndex(mediaInfo);\r\n            streamProcessor.addMediaInfo(mediaInfo, true);\r\n        }\r\n\r\n        if (trackChangedEvent) {\r\n            let mediaInfo = trackChangedEvent.newMediaInfo;\r\n            if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) {\r\n                let processor = getProcessorForMediaInfo(trackChangedEvent.oldMediaInfo);\r\n                if (!processor) return;\r\n                processor.switchTrackAsked();\r\n                trackChangedEvent = undefined;\r\n            }\r\n        }\r\n\r\n        isUpdating = false;\r\n        checkIfInitializationCompleted();\r\n    }\r\n\r\n    function isMediaCodecCompatible(newStream) {\r\n        return compareCodecs(newStream, Constants.VIDEO) && compareCodecs(newStream, Constants.AUDIO);\r\n    }\r\n\r\n    function isProtectionCompatible(stream) {\r\n        return compareProtectionConfig(stream, Constants.VIDEO) && compareProtectionConfig(stream, Constants.AUDIO);\r\n    }\r\n\r\n    function compareProtectionConfig(stream, type) {\r\n        if (!stream) {\r\n            return false;\r\n        }\r\n        const newStreamInfo = stream.getStreamInfo();\r\n        const currentStreamInfo = getStreamInfo();\r\n\r\n        if (!newStreamInfo || !currentStreamInfo) {\r\n            return false;\r\n        }\r\n\r\n        const newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo);\r\n        const currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo);\r\n\r\n        if (!newAdaptation || !currentAdaptation) {\r\n            // If there is no adaptation for neither the old or the new stream they're compatible\r\n            return !newAdaptation && !currentAdaptation;\r\n        }\r\n\r\n        // If any of the periods requires EME, we can't do smooth transition\r\n        if (newAdaptation.ContentProtection || currentAdaptation.ContentProtection) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function compareCodecs(newStream, type) {\r\n        if (!newStream || !newStream.hasOwnProperty('getStreamInfo')) {\r\n            return false;\r\n        }\r\n        const newStreamInfo = newStream.getStreamInfo();\r\n        const currentStreamInfo = getStreamInfo();\r\n\r\n        if (!newStreamInfo || !currentStreamInfo) {\r\n            return false;\r\n        }\r\n\r\n        const newAdaptation = adapter.getAdaptationForType(newStreamInfo.index, type, newStreamInfo);\r\n        const currentAdaptation = adapter.getAdaptationForType(currentStreamInfo.index, type, currentStreamInfo);\r\n\r\n        if (!newAdaptation || !currentAdaptation) {\r\n            // If there is no adaptation for neither the old or the new stream they're compatible\r\n            return !newAdaptation && !currentAdaptation;\r\n        }\r\n\r\n        const sameMimeType = newAdaptation && currentAdaptation && newAdaptation.mimeType === currentAdaptation.mimeType;\r\n        const oldCodecs = currentAdaptation.Representation_asArray.map((representation) => {\r\n            return representation.codecs;\r\n        });\r\n\r\n        const newCodecs = newAdaptation.Representation_asArray.map((representation) => {\r\n            return representation.codecs;\r\n        });\r\n\r\n        const codecMatch = newCodecs.some((newCodec) => {\r\n            return oldCodecs.indexOf(newCodec) > -1;\r\n        });\r\n\r\n        const partialCodecMatch = newCodecs.some((newCodec) => oldCodecs.some((oldCodec) => codecRootCompatibleWithCodec(oldCodec, newCodec)));\r\n        return codecMatch || (partialCodecMatch && sameMimeType);\r\n    }\r\n\r\n    // Check if the root of the old codec is the same as the new one, or if it's declared as compatible in the compat table\r\n    function codecRootCompatibleWithCodec(codec1, codec2) {\r\n        const codecRoot = codec1.split('.')[0];\r\n        const rootCompatible = codec2.indexOf(codecRoot) === 0;\r\n        let compatTableCodec;\r\n        for (let i = 0; i < codecCompatibilityTable.length; i++) {\r\n            if (codecCompatibilityTable[i].codec === codecRoot) {\r\n                compatTableCodec = codecCompatibilityTable[i];\r\n                break;\r\n            }\r\n        }\r\n        if (compatTableCodec) {\r\n            return rootCompatible || compatTableCodec.compatibleCodecs.some((compatibleCodec) => codec2.indexOf(compatibleCodec) === 0);\r\n        }\r\n        return rootCompatible;\r\n    }\r\n\r\n    function setPreloaded(value) {\r\n        preloaded = value;\r\n    }\r\n\r\n    function getPreloaded() {\r\n        return preloaded;\r\n    }\r\n\r\n    function preload(mediaSource, previousBuffers) {\r\n        if (!getPreloaded()) {\r\n            addInlineEvents();\r\n\r\n            initializeMediaForType(Constants.VIDEO, mediaSource);\r\n            initializeMediaForType(Constants.AUDIO, mediaSource);\r\n            initializeMediaForType(Constants.TEXT, mediaSource);\r\n            initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\r\n            initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\r\n            initializeMediaForType(Constants.MUXED, mediaSource);\r\n            initializeMediaForType(Constants.IMAGE, mediaSource);\r\n\r\n            createBuffers(previousBuffers);\r\n\r\n            eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\r\n            for (let i = 0; i < streamProcessors.length && streamProcessors[i]; i++) {\r\n                streamProcessors[i].getScheduleController().start();\r\n            }\r\n\r\n            setPreloaded(true);\r\n        }\r\n    }\r\n\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        getStreamId: getStreamId,\r\n        activate: activate,\r\n        deactivate: deactivate,\r\n        isActive: isActive,\r\n        getDuration: getDuration,\r\n        getStartTime: getStartTime,\r\n        getId: getId,\r\n        getStreamInfo: getStreamInfo,\r\n        getHasAudioTrack: getHasAudioTrack,\r\n        getHasVideoTrack: getHasVideoTrack,\r\n        preload: preload,\r\n        getThumbnailController: getThumbnailController,\r\n        getBitrateListFor: getBitrateListFor,\r\n        updateData: updateData,\r\n        reset: reset,\r\n        getProcessors: getProcessors,\r\n        setMediaSource: setMediaSource,\r\n        isMediaCodecCompatible: isMediaCodecCompatible,\r\n        isProtectionCompatible: isProtectionCompatible,\r\n        getPreloaded: getPreloaded,\r\n        getPreloadingScheduled,\r\n        setPreloadingScheduled,\r\n        getIsEndedEventSignaled,\r\n        setIsEndedEventSignaled\r\n    };\r\n\r\n    setup();\r\n    return instance;\r\n}\r\n\r\nStream.__dashjs_factory_name = 'Stream';\r\nexport default FactoryMaker.getClassFactory(Stream);\r\n"]}