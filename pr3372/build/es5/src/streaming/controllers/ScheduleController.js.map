{"version":3,"sources":["../../../../../src/streaming/controllers/ScheduleController.js"],"names":["ScheduleController","config","context","eventBus","getInstance","adapter","dashMetrics","mediaPlayerModel","fragmentModel","abrController","playbackController","textController","streamInfo","type","mimeType","mediaController","bufferController","settings","instance","logger","currentRepresentationInfo","initialRequest","isStopped","isFragmentProcessingInProgress","timeToLoadDelay","scheduleTimeout","seekTarget","hasVideoTrack","bufferLevelRule","lastFragmentRequest","topQualityIndex","lastInitQuality","replaceRequestArray","switchTrack","replacingBuffer","mediaRequest","checkPlaybackQuality","isReplacementRequest","setup","getLogger","resetInitialSettings","initialize","_hasVideoTrack","create","on","Events","DATA_UPDATE_STARTED","onDataUpdateStarted","FRAGMENT_LOADING_COMPLETED","onFragmentLoadingCompleted","STREAM_COMPLETED","onStreamCompleted","BUFFER_CLEARED","onBufferCleared","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","QUOTA_EXCEEDED","onQuotaExceeded","PLAYBACK_SEEKING","onPlaybackSeeking","PLAYBACK_STARTED","onPlaybackStarted","PLAYBACK_RATE_CHANGED","onPlaybackRateChanged","PLAYBACK_TIME_UPDATED","onPlaybackTimeUpdated","URL_RESOLUTION_FAILED","onURLResolutionFailed","FRAGMENT_LOADING_ABANDONED","onFragmentLoadingAbandoned","BUFFERING_COMPLETED","onBufferingCompleted","getType","getStreamId","id","setCurrentRepresentation","representationInfo","isStarted","start","getIsBufferingCompleted","debug","createPlaylistTraceMetrics","getTime","getPlaybackRate","startScheduleTimer","stop","clearTimeout","hasTopQualityChanged","newTopQualityIndex","getTopQualityIndexFor","info","schedule","isPaused","get","streaming","scheduleWhilePaused","Constants","FRAGMENTED_TEXT","TEXT","isTextEnabled","validateExecutedFragmentRequest","isReplacement","length","isNaN","execute","getNextFragment","quality","getSwitchMode","MediaController","TRACK_SWITCH_MODE_ALWAYS_REPLACE","replaceBuffer","trigger","INIT_FRAGMENT_NEEDED","representationId","replacement","shift","isInitializationRequest","MEDIA_FRAGMENT_NEEDED","setFragmentProcessState","time","safeBufferLevel","fragmentDuration","schedulingInfo","getCurrentSchedulingInfo","mediaInfo","duration","request","getRequests","state","FragmentModel","FRAGMENT_MODEL_EXECUTED","threshold","indexOf","getIsTextTrack","fastSwitchModeEnabled","fastSwitchEnabled","bufferLevel","getBufferLevel","abandonmentState","getAbandonmentStateFor","trackChanged","isCurrentTrack","TRACK_SWITCH_MODE_NEVER_REPLACE","qualityChanged","MetricsConstants","ABANDON_LOAD","replaceRequest","index","setSeekTarget","value","setTimeout","processInitRequest","executeRequest","processMediaRequest","url","getIsDynamic","lowLatencyEnabled","switchTrackAsked","push","completeQualityChange","item","startTime","TRACK_CHANGE_RENDERED","mediaType","oldMediaInfo","newMediaInfo","adaptationIndex","QUALITY_CHANGE_RENDERED","oldQuality","newQuality","e","range","error","serviceLocation","addExecutedRequest","currentTime","fragEndTime","isSeeking","hasEnoughSpaceToAppend","quotaExceeded","abortRequests","seekTime","setTimeToLoadDelay","latency","DVRWindow","end","NaN","updateManifestUpdateInfo","updatePlayListTraceMetrics","playbackspeed","playbackRate","toString","getTimeToLoadDelay","getBufferTarget","undefined","reset","off","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"ScheduleController.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport Constants from '../constants/Constants';\r\nimport MetricsConstants from '../constants/MetricsConstants';\r\nimport BufferLevelRule from '../rules/scheduling/BufferLevelRule';\r\nimport FragmentModel from '../models/FragmentModel';\r\nimport EventBus from '../../core/EventBus';\r\nimport Events from '../../core/events/Events';\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport Debug from '../../core/Debug';\r\nimport MediaController from './MediaController';\r\n\r\nfunction ScheduleController(config) {\r\n\r\n    config = config || {};\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n    const adapter = config.adapter;\r\n    const dashMetrics = config.dashMetrics;\r\n    const mediaPlayerModel = config.mediaPlayerModel;\r\n    const fragmentModel = config.fragmentModel;\r\n    const abrController = config.abrController;\r\n    const playbackController = config.playbackController;\r\n    const textController = config.textController;\r\n    const streamInfo = config.streamInfo;\r\n    const type = config.type;\r\n    const mimeType = config.mimeType;\r\n    const mediaController = config.mediaController;\r\n    const bufferController = config.bufferController;\r\n    const settings = config.settings;\r\n\r\n    let instance,\r\n        logger,\r\n        currentRepresentationInfo,\r\n        initialRequest,\r\n        isStopped,\r\n        isFragmentProcessingInProgress,\r\n        timeToLoadDelay,\r\n        scheduleTimeout,\r\n        seekTarget,\r\n        hasVideoTrack,\r\n        bufferLevelRule,\r\n        lastFragmentRequest,\r\n        topQualityIndex,\r\n        lastInitQuality,\r\n        replaceRequestArray,\r\n        switchTrack,\r\n        replacingBuffer,\r\n        mediaRequest,\r\n        checkPlaybackQuality,\r\n        isReplacementRequest;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        resetInitialSettings();\r\n    }\r\n\r\n    function initialize(_hasVideoTrack) {\r\n        hasVideoTrack = _hasVideoTrack;\r\n\r\n        bufferLevelRule = BufferLevelRule(context).create({\r\n            abrController: abrController,\r\n            dashMetrics: dashMetrics,\r\n            mediaPlayerModel: mediaPlayerModel,\r\n            textController: textController,\r\n            settings: settings\r\n        });\r\n\r\n        //eventBus.on(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\r\n        eventBus.on(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\r\n        eventBus.on(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\r\n        eventBus.on(Events.STREAM_COMPLETED, onStreamCompleted, this);\r\n        eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, this);\r\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\r\n        eventBus.on(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\r\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\r\n        eventBus.on(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\r\n        eventBus.on(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\r\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\r\n        eventBus.on(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\r\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\r\n        eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, this);\r\n    }\r\n\r\n    function getType() {\r\n        return type;\r\n    }\r\n\r\n    function getStreamId() {\r\n        return streamInfo.id;\r\n    }\r\n\r\n    function setCurrentRepresentation(representationInfo) {\r\n        currentRepresentationInfo = representationInfo;\r\n    }\r\n\r\n    function isStarted() {\r\n        return (isStopped === false);\r\n    }\r\n\r\n    function start() {\r\n        if (isStarted()) return;\r\n        if (!currentRepresentationInfo || bufferController.getIsBufferingCompleted()) return;\r\n\r\n        logger.debug('Schedule Controller starts');\r\n        isStopped = false;\r\n        dashMetrics.createPlaylistTraceMetrics(currentRepresentationInfo.id, playbackController.getTime() * 1000, playbackController.getPlaybackRate());\r\n\r\n        if (initialRequest) {\r\n            initialRequest = false;\r\n        }\r\n\r\n        startScheduleTimer(0);\r\n    }\r\n\r\n    function stop() {\r\n        if (isStopped) return;\r\n\r\n        logger.debug('Schedule Controller stops');\r\n        logger.debug(type + ' Schedule Controller stops');\r\n        isStopped = true;\r\n        clearTimeout(scheduleTimeout);\r\n    }\r\n\r\n    function hasTopQualityChanged(type, id) {\r\n        topQualityIndex[id] = topQualityIndex[id] || {};\r\n        const newTopQualityIndex = abrController.getTopQualityIndexFor(type, id);\r\n\r\n        if (topQualityIndex[id][type] != newTopQualityIndex) {\r\n            logger.info('Top quality ' + type + ' index has changed from ' + topQualityIndex[id][type] + ' to ' + newTopQualityIndex);\r\n            topQualityIndex[id][type] = newTopQualityIndex;\r\n            return true;\r\n        }\r\n        return false;\r\n\r\n    }\r\n\r\n    function schedule() {\r\n        if (isStopped || isFragmentProcessingInProgress ||\r\n            (playbackController.isPaused() && !settings.get().streaming.scheduleWhilePaused) ||\r\n            ((type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) && !textController.isTextEnabled()) ||\r\n            bufferController.getIsBufferingCompleted()) {\r\n            stop();\r\n            return;\r\n        }\r\n\r\n        validateExecutedFragmentRequest();\r\n\r\n        const isReplacement = replaceRequestArray.length > 0;\r\n        if (replacingBuffer || isNaN(lastInitQuality) || switchTrack || isReplacement ||\r\n            hasTopQualityChanged(type, streamInfo.id) ||\r\n            bufferLevelRule.execute(type, currentRepresentationInfo, hasVideoTrack)) {\r\n            const getNextFragment = function () {\r\n                if ((currentRepresentationInfo.quality !== lastInitQuality || switchTrack) && (!replacingBuffer)) {\r\n                    if (switchTrack) {\r\n                        logger.debug('Switch track for ' + type + ', representation id = ' + currentRepresentationInfo.id);\r\n                        replacingBuffer = mediaController.getSwitchMode(type) === MediaController.TRACK_SWITCH_MODE_ALWAYS_REPLACE;\r\n                        if (replacingBuffer && bufferController.replaceBuffer) {\r\n                            bufferController.replaceBuffer();\r\n                        }\r\n                        switchTrack = false;\r\n                    } else {\r\n                        logger.debug('Quality has changed, get init request for representationid = ' + currentRepresentationInfo.id);\r\n                    }\r\n                    eventBus.trigger(Events.INIT_FRAGMENT_NEEDED, {\r\n                        representationId: currentRepresentationInfo.id\r\n                    }, streamInfo.id, type);\r\n                    lastInitQuality = currentRepresentationInfo.quality;\r\n                    checkPlaybackQuality = false;\r\n                } else {\r\n                    const replacement = replaceRequestArray.shift();\r\n\r\n                    if (replacement && replacement.isInitializationRequest()) {\r\n                        // To be sure the specific init segment had not already been loaded\r\n                        eventBus.trigger(Events.INIT_FRAGMENT_NEEDED, {\r\n                            representationId: replacement.representationId\r\n                        }, streamInfo.id, type);\r\n                        checkPlaybackQuality = false;\r\n                    } else {\r\n                        eventBus.trigger(Events.MEDIA_FRAGMENT_NEEDED, {\r\n                            seekTarget: seekTarget,\r\n                            replacement: replacement\r\n                        }, streamInfo.id, type);\r\n                        checkPlaybackQuality = true;\r\n                    }\r\n                }\r\n            };\r\n\r\n            setFragmentProcessState(true);\r\n            if (!isReplacement && checkPlaybackQuality) {\r\n                abrController.checkPlaybackQuality(type);\r\n            }\r\n\r\n            getNextFragment();\r\n\r\n        } else {\r\n            startScheduleTimer(500);\r\n        }\r\n    }\r\n\r\n    function validateExecutedFragmentRequest() {\r\n        // Validate that the fragment request executed and appended into the source buffer is as\r\n        // good of quality as the current quality and is the correct media track.\r\n        const time = playbackController.getTime();\r\n        let safeBufferLevel = 1.5;\r\n\r\n        if (isNaN(currentRepresentationInfo.fragmentDuration)) { //fragmentDuration of representationInfo is not defined,\r\n            // call metrics function to have data in the latest scheduling info...\r\n            // if no metric, returns 0. In this case, rule will return false.\r\n            const schedulingInfo = dashMetrics.getCurrentSchedulingInfo(currentRepresentationInfo.mediaInfo.type);\r\n            safeBufferLevel = schedulingInfo ? schedulingInfo.duration * 1.5 : 1.5;\r\n        }\r\n        const request = fragmentModel.getRequests({\r\n            state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\r\n            time: time + safeBufferLevel,\r\n            threshold: 0\r\n        })[0];\r\n\r\n        if (request && replaceRequestArray.indexOf(request) === -1 && !adapter.getIsTextTrack(mimeType)) {\r\n            const fastSwitchModeEnabled = settings.get().streaming.fastSwitchEnabled;\r\n            const bufferLevel = bufferController.getBufferLevel();\r\n            const abandonmentState = abrController.getAbandonmentStateFor(type);\r\n\r\n            // Only replace on track switch when NEVER_REPLACE\r\n            const trackChanged = !mediaController.isCurrentTrack(request.mediaInfo) && mediaController.getSwitchMode(request.mediaInfo.type) === MediaController.TRACK_SWITCH_MODE_NEVER_REPLACE;\r\n            const qualityChanged = request.quality < currentRepresentationInfo.quality;\r\n\r\n            if (fastSwitchModeEnabled && (trackChanged || qualityChanged) && bufferLevel >= safeBufferLevel && abandonmentState !== MetricsConstants.ABANDON_LOAD) {\r\n                replaceRequest(request);\r\n                isReplacementRequest = true;\r\n                logger.debug('Reloading outdated fragment at index: ', request.index);\r\n            } else if (request.quality > currentRepresentationInfo.quality && !replacingBuffer) {\r\n                // The buffer has better quality it in then what we would request so set append point to end of buffer!!\r\n                setSeekTarget(playbackController.getTime() + bufferLevel);\r\n            }\r\n        }\r\n    }\r\n\r\n    function startScheduleTimer(value) {\r\n        clearTimeout(scheduleTimeout);\r\n\r\n        scheduleTimeout = setTimeout(schedule, value);\r\n    }\r\n\r\n    function setFragmentProcessState (state) {\r\n        if (isFragmentProcessingInProgress !== state ) {\r\n            isFragmentProcessingInProgress = state;\r\n        } else {\r\n            logger.debug('isFragmentProcessingInProgress is already equal to', state);\r\n        }\r\n    }\r\n\r\n    function processInitRequest(request) {\r\n        if (request) {\r\n            setFragmentProcessState(true);\r\n            fragmentModel.executeRequest(request);\r\n        }\r\n    }\r\n\r\n    function processMediaRequest(request) {\r\n        if (request) {\r\n            logger.debug('Next fragment request url is ' + request.url);\r\n            fragmentModel.executeRequest(request);\r\n        } else { // Use case - Playing at the bleeding live edge and frag is not available yet. Cycle back around.\r\n            if (playbackController.getIsDynamic()) {\r\n                logger.debug('Next fragment seems to be at the bleeding live edge and is not available yet. Rescheduling.');\r\n            }\r\n            setFragmentProcessState(false);\r\n            startScheduleTimer(settings.get().streaming.lowLatencyEnabled ? 100 : 500);\r\n        }\r\n    }\r\n\r\n    function switchTrackAsked() {\r\n        switchTrack = true;\r\n    }\r\n\r\n    function replaceRequest(request) {\r\n        replaceRequestArray.push(request);\r\n    }\r\n\r\n    function completeQualityChange(trigger) {\r\n        if (playbackController && fragmentModel) {\r\n            const item = fragmentModel.getRequests({\r\n                state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\r\n                time: playbackController.getTime(),\r\n                threshold: 0\r\n            })[0];\r\n            if (item && playbackController.getTime() >= item.startTime) {\r\n                if ((!lastFragmentRequest.mediaInfo || (item.mediaInfo.type === lastFragmentRequest.mediaInfo.type && item.mediaInfo.id !== lastFragmentRequest.mediaInfo.id)) && trigger) {\r\n                    eventBus.trigger(Events.TRACK_CHANGE_RENDERED, {\r\n                        mediaType: type,\r\n                        oldMediaInfo: lastFragmentRequest.mediaInfo,\r\n                        newMediaInfo: item.mediaInfo\r\n                    });\r\n                }\r\n                if ((item.quality !== lastFragmentRequest.quality || item.adaptationIndex !== lastFragmentRequest.adaptationIndex) && trigger) {\r\n                    eventBus.trigger(Events.QUALITY_CHANGE_RENDERED, {\r\n                        mediaType: type,\r\n                        oldQuality: lastFragmentRequest.quality,\r\n                        newQuality: item.quality\r\n                    });\r\n                }\r\n                lastFragmentRequest = {\r\n                    mediaInfo: item.mediaInfo,\r\n                    quality: item.quality,\r\n                    adaptationIndex: item.adaptationIndex\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    function onStreamCompleted(e) {\r\n        if (e.request.mediaInfo.streamInfo.id !== streamInfo.id || e.request.mediaType !== type) return;\r\n\r\n        stop();\r\n        setFragmentProcessState(false);\r\n        logger.info('Stream is complete');\r\n    }\r\n\r\n    function onFragmentLoadingCompleted(e) {\r\n        if (e.request.mediaInfo.streamInfo.id !== streamInfo.id || e.request.mediaType !== type) return;\r\n\r\n        logger.info('OnFragmentLoadingCompleted - Url:', e.request ? e.request.url : 'undefined', e.request.range ? ', Range:' + e.request.range : '');\r\n\r\n        if (adapter.getIsTextTrack(mimeType)) {\r\n            setFragmentProcessState(false);\r\n        }\r\n\r\n        if (e.error && e.request.serviceLocation && !isStopped) {\r\n            replaceRequest(e.request);\r\n            setFragmentProcessState(false);\r\n            startScheduleTimer(0);\r\n        }\r\n\r\n        if (replacingBuffer) {\r\n            mediaRequest = e.request;\r\n        }\r\n    }\r\n\r\n    function onPlaybackTimeUpdated() {\r\n        completeQualityChange(true);\r\n    }\r\n\r\n    function onBytesAppended(e) {\r\n        if (replacingBuffer && !isNaN(e.startTime)) {\r\n            replacingBuffer = false;\r\n            fragmentModel.addExecutedRequest(mediaRequest);\r\n        }\r\n\r\n        setFragmentProcessState(false);\r\n        if (isReplacementRequest && !isNaN(e.startTime)) {\r\n            //replace requests process is in progress, call schedule in n seconds.\r\n            //it is done in order to not add a fragment at the new quality at the end of the buffer before replace process is over.\r\n            //Indeed, if schedule is called too early, the executed request tested is the same that the one tested during previous schedule (at the new quality).\r\n            const currentTime = playbackController.getTime();\r\n            const fragEndTime = e.startTime + currentRepresentationInfo.fragmentDuration;\r\n            const safeBufferLevel = currentRepresentationInfo.fragmentDuration * 1.5;\r\n            if ((currentTime + safeBufferLevel) >= fragEndTime) {\r\n                startScheduleTimer(0);\r\n            } else {\r\n                startScheduleTimer((fragEndTime - (currentTime + safeBufferLevel)) * 1000);\r\n            }\r\n            isReplacementRequest = false;\r\n        } else {\r\n            startScheduleTimer(0);\r\n        }\r\n    }\r\n\r\n    function onFragmentLoadingAbandoned(e) {\r\n        logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has been aborted');\r\n        if (!playbackController.isSeeking() && !switchTrack) {\r\n            logger.info('onFragmentLoadingAbandoned request: ' + e.request.url + ' has to be downloaded again, origin is not seeking process or switch track call');\r\n            replaceRequest(e.request);\r\n        }\r\n        setFragmentProcessState(false);\r\n        startScheduleTimer(0);\r\n    }\r\n\r\n    function onDataUpdateStarted(/*e*/) {\r\n        // stop();\r\n    }\r\n\r\n    function onBufferingCompleted(/*e*/) {\r\n        stop();\r\n    }\r\n\r\n    function onBufferCleared(e) {\r\n        // (Re)start schedule once buffer has been pruned after a QuotaExceededError\r\n        if (e.hasEnoughSpaceToAppend && e.quotaExceeded) {\r\n            start();\r\n        }\r\n    }\r\n\r\n    function onQuotaExceeded(/*e*/) {\r\n        // Stop scheduler (will be restarted once buffer is pruned)\r\n        stop();\r\n        setFragmentProcessState(false);\r\n    }\r\n\r\n    function onURLResolutionFailed() {\r\n        fragmentModel.abortRequests();\r\n        stop();\r\n    }\r\n\r\n    function onPlaybackStarted() {\r\n        if (isStopped || !settings.get().streaming.scheduleWhilePaused) {\r\n            start();\r\n        }\r\n    }\r\n\r\n    function onPlaybackSeeking(e) {\r\n        setSeekTarget(e.seekTime);\r\n        setTimeToLoadDelay(0);\r\n\r\n        if (isStopped) {\r\n            start();\r\n        }\r\n\r\n        const latency = currentRepresentationInfo.DVRWindow && playbackController ? currentRepresentationInfo.DVRWindow.end - playbackController.getTime() : NaN;\r\n        dashMetrics.updateManifestUpdateInfo({\r\n            latency: latency\r\n        });\r\n\r\n        if (!isFragmentProcessingInProgress) {\r\n            // No pending request, request next segment at seek target\r\n            startScheduleTimer(0);\r\n        } else {\r\n            // Abort current request\r\n            fragmentModel.abortRequests();\r\n        }\r\n    }\r\n\r\n    function onPlaybackRateChanged(e) {\r\n        dashMetrics.updatePlayListTraceMetrics({playbackspeed: e.playbackRate.toString()});\r\n    }\r\n\r\n    function setSeekTarget(value) {\r\n        seekTarget = value;\r\n    }\r\n\r\n    function setTimeToLoadDelay(value) {\r\n        timeToLoadDelay = value;\r\n    }\r\n\r\n    function getTimeToLoadDelay() {\r\n        return timeToLoadDelay;\r\n    }\r\n\r\n    function getBufferTarget() {\r\n        return bufferLevelRule.getBufferTarget(type, currentRepresentationInfo);\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        checkPlaybackQuality = true;\r\n        isFragmentProcessingInProgress = false;\r\n        timeToLoadDelay = 0;\r\n        seekTarget = NaN;\r\n        initialRequest = true;\r\n        lastInitQuality = NaN;\r\n        lastFragmentRequest = {\r\n            mediaInfo: undefined,\r\n            quality: NaN,\r\n            adaptationIndex: NaN\r\n        };\r\n        topQualityIndex = {};\r\n        replaceRequestArray = [];\r\n        isStopped = true;\r\n        switchTrack = false;\r\n        replacingBuffer = false;\r\n        mediaRequest = null;\r\n        isReplacementRequest = false;\r\n    }\r\n\r\n    function reset() {\r\n        //eventBus.off(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\r\n        eventBus.off(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\r\n        eventBus.off(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\r\n        eventBus.off(Events.STREAM_COMPLETED, onStreamCompleted, this);\r\n        eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, this);\r\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\r\n        eventBus.off(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\r\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\r\n        eventBus.off(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\r\n        eventBus.off(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\r\n        eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\r\n        eventBus.off(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\r\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\r\n        eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, this);\r\n\r\n        stop();\r\n        completeQualityChange(false);\r\n        resetInitialSettings();\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        getType: getType,\r\n        getStreamId: getStreamId,\r\n        setCurrentRepresentation: setCurrentRepresentation,\r\n        setSeekTarget: setSeekTarget,\r\n        setTimeToLoadDelay: setTimeToLoadDelay,\r\n        getTimeToLoadDelay: getTimeToLoadDelay,\r\n        switchTrackAsked: switchTrackAsked,\r\n        isStarted: isStarted,\r\n        start: start,\r\n        stop: stop,\r\n        reset: reset,\r\n        getBufferTarget: getBufferTarget,\r\n        processInitRequest: processInitRequest,\r\n        processMediaRequest: processMediaRequest\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nScheduleController.__dashjs_factory_name = 'ScheduleController';\r\nexport default FactoryMaker.getClassFactory(ScheduleController);\r\n"]}