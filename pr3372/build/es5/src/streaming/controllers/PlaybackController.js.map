{"version":3,"sources":["../../../../../src/streaming/controllers/PlaybackController.js"],"names":["LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS","PlaybackController","context","eventBus","getInstance","instance","logger","streamController","dashMetrics","adapter","videoModel","timelineConverter","streamSwitch","streamSeekTime","wallclockTimeIntervalId","liveDelay","streamInfo","isDynamic","mediaPlayerModel","playOnceInitialized","lastLivePlaybackTime","availabilityStartTime","seekTarget","isLowLatencySeekingInProgress","playbackStalled","minPlaybackRateChange","uriFragmentModel","settings","setup","getLogger","reset","initialize","sInfo","periodSwitch","seekTime","addAllListeners","manifestInfo","ua","navigator","userAgent","toLowerCase","isSafari","test","on","Events","STREAM_INITIALIZED","onStreamInitialized","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","LOADING_PROGRESS","onFragmentLoadProgress","BUFFER_LEVEL_STATE_CHANGED","onBufferLevelStateChanged","PLAYBACK_PROGRESS","onPlaybackProgression","PLAYBACK_TIME_UPDATED","PLAYBACK_ENDED","onPlaybackEnded","EventBus","EVENT_PRIORITY_HIGH","STREAM_INITIALIZING","onStreamInitializing","play","e","isNaN","startTime","liveStartTime","dvrInfo","getCurrentDVRInfo","dvrWindow","range","startTimeFromUri","getStartTimeFromUriParameters","start","info","Math","max","min","duration","getTime","trigger","PLAYBACK_SEEKING","seek","getTimeToStreamEnd","parseFloat","getStreamEndTime","toFixed","getElement","isPaused","pause","isSeeking","time","stickToBuffered","internalSeek","currentTime","removeEventListener","onPlaybackSeeking","setCurrentTime","PLAYBACK_SEEK_ASKED","seekToLive","DVRMetrics","DVRWindow","end","getLiveDelay","getNormalizedTime","t","timeOffset","getPlaybackRate","getPlayedRanges","getEnded","getIsDynamic","getStreamController","computeAndSetLiveDelay","fragmentDuration","dvrWindowSize","minBufferTime","delay","ret","END_OF_PLAYLIST_PADDING","MIN_BUFFER_TIME_FACTOR","FRAGMENT_DURATION_FACTOR","adjustedFragmentDuration","isFinite","NaN","suggestedPresentationDelay","getSuggestedPresentationDelay","get","streaming","lowLatencyEnabled","liveDelayFragmentCount","useSuggestedPresentationDelay","getAvailabilityStartTime","targetDelayCapping","setLiveDelay","value","useMaxValue","getCurrentLiveLatency","now","Date","getClientTimeOffset","off","stopUpdatingWallclockTime","removeAllListeners","setConfig","config","rangeStart","fragData","getURIFragmentData","split","indexOf","parseInt","substring","getActualPresentationTime","actualTime","debug","abs","startUpdatingWallclockTime","tick","onWallclockTime","setInterval","wallclockTimeUpdateInterval","clearInterval","updateCurrentTime","getReadyState","timeChanged","error","representationInfo","convertDataToRepresentationInfo","currentRepresentation","mediaInfo","id","onCanPlay","CAN_PLAY","onPlaybackStart","PLAYBACK_STARTED","onPlaybackWaiting","PLAYBACK_WAITING","playingTime","onPlaybackPlaying","PLAYBACK_PLAYING","onPlaybackPaused","PLAYBACK_PAUSED","ended","onPlaybackSeeked","PLAYBACK_SEEKED","addEventListener","onPlaybackTimeUpdated","timeToEnd","updateLivePlaybackTime","onPlaybackProgress","onPlaybackRateChanged","rate","PLAYBACK_RATE_CHANGED","playbackRate","onPlaybackMetaDataLoaded","PLAYBACK_METADATA_LOADED","onNativePlaybackEnded","getActiveStreamInfo","isLast","onPlaybackError","event","target","srcElement","PLAYBACK_ERROR","WALLCLOCK_TIME_UPDATED","liveCatchUpPlaybackRate","needToCatchUp","startPlaybackCatchUp","stopPlaybackCatchUp","getBufferLevel","bufferLevel","getActiveStreamProcessors","forEach","bl","p","currentLiveLatency","latencyDrift","liveCatchupLatencyThreshold","getLiveCatchupLatencyThreshold","liveCatchUpMinDrift","cpr","deltaLatency","d","s","pow","E","newRate","setPlaybackRate","liveCatchUpMaxDrift","stream","request","minDelay","warn","update","streamId","state","MetricsConstants","BUFFER_EMPTY","setStallState","mediaType","onPlaybackStalled","PLAYBACK_STALLED","applyServiceDescription","serviceDescriptions","llsd","i","length","sd","schemeIdUri","Constants","SERVICE_DESCRIPTION_LL_SCHEME","supplementalProperties","SUPPLEMENTAL_PROPERTY_LL_SCHEME","latency","undefined","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"PlaybackController.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport Constants from '../constants/Constants';\r\nimport MetricsConstants from '../constants/MetricsConstants';\r\nimport EventBus from '../../core/EventBus';\r\nimport Events from '../../core/events/Events';\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport Debug from '../../core/Debug';\r\n\r\nconst LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS = 500;\r\n\r\nfunction PlaybackController() {\r\n\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n\r\n    let instance,\r\n        logger,\r\n        streamController,\r\n        dashMetrics,\r\n        adapter,\r\n        videoModel,\r\n        timelineConverter,\r\n        streamSwitch,\r\n        streamSeekTime,\r\n        wallclockTimeIntervalId,\r\n        liveDelay,\r\n        streamInfo,\r\n        isDynamic,\r\n        mediaPlayerModel,\r\n        playOnceInitialized,\r\n        lastLivePlaybackTime,\r\n        availabilityStartTime,\r\n        seekTarget,\r\n        isLowLatencySeekingInProgress,\r\n        playbackStalled,\r\n        minPlaybackRateChange,\r\n        uriFragmentModel,\r\n        settings;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n\r\n        reset();\r\n    }\r\n\r\n    function initialize(sInfo, periodSwitch, seekTime) {\r\n        streamInfo = sInfo;\r\n        addAllListeners();\r\n        isDynamic = streamInfo.manifestInfo.isDynamic;\r\n        isLowLatencySeekingInProgress = false;\r\n        playbackStalled = false;\r\n        streamSwitch = periodSwitch === true;\r\n        streamSeekTime = seekTime;\r\n\r\n        const ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';\r\n\r\n        // Detect safari browser (special behavior for low latency streams)\r\n        const isSafari = /safari/.test(ua) && !/chrome/.test(ua);\r\n        minPlaybackRateChange = isSafari ? 0.25 : 0.02;\r\n\r\n        eventBus.on(Events.STREAM_INITIALIZED, onStreamInitialized, this);\r\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\r\n        eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\r\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\r\n        eventBus.on(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\r\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\r\n        eventBus.on(Events.PLAYBACK_ENDED, onPlaybackEnded, this, EventBus.EVENT_PRIORITY_HIGH);\r\n        eventBus.on(Events.STREAM_INITIALIZING, onStreamInitializing, this);\r\n\r\n        if (playOnceInitialized) {\r\n            playOnceInitialized = false;\r\n            play();\r\n        }\r\n    }\r\n\r\n    function onStreamInitialized(e) {\r\n        // Seamless period switch\r\n        if (streamSwitch && isNaN(streamSeekTime)) return;\r\n\r\n        // Seek new stream in priority order:\r\n        // - at seek time (streamSeekTime) when switching period\r\n        // - at start time provided in URI parameters\r\n        // - at stream/period start time (for static streams) or live start time (for dynamic streams)\r\n        let startTime = streamSeekTime;\r\n        if (isNaN(startTime)) {\r\n            if (isDynamic) {\r\n                // For dynamic stream, start by default at (live edge - live delay)\r\n                startTime = e.liveStartTime;\r\n                // If start time in URI, take min value between live edge time and time from URI (capped by DVR window range)\r\n                const dvrInfo = dashMetrics.getCurrentDVRInfo();\r\n                const dvrWindow = dvrInfo ? dvrInfo.range : null;\r\n                if (dvrWindow) {\r\n                    // #t shall be relative to period start\r\n                    const startTimeFromUri = getStartTimeFromUriParameters(streamInfo.start, true);\r\n                    if (!isNaN(startTimeFromUri)) {\r\n                        logger.info('Start time from URI parameters: ' + startTimeFromUri);\r\n                        startTime = Math.max(Math.min(startTime, startTimeFromUri), dvrWindow.start);\r\n                    }\r\n                }\r\n            } else {\r\n                // For static stream, start by default at period start\r\n                startTime = streamInfo.start;\r\n                // If start time in URI, take max value between period start and time from URI (if in period range)\r\n                const startTimeFromUri = getStartTimeFromUriParameters(streamInfo.start, false);\r\n                if (!isNaN(startTimeFromUri) && startTimeFromUri < (startTime + streamInfo.duration)) {\r\n                    logger.info('Start time from URI parameters: ' + startTimeFromUri);\r\n                    startTime = Math.max(startTime, startTimeFromUri);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!isNaN(startTime) && startTime !== videoModel.getTime()) {\r\n            // Trigger PLAYBACK_SEEKING event for controllers\r\n            eventBus.trigger(Events.PLAYBACK_SEEKING, { seekTime: startTime });\r\n            // Seek video model\r\n            seek(startTime, false, true);\r\n        }\r\n    }\r\n\r\n    function getTimeToStreamEnd() {\r\n        return parseFloat((getStreamEndTime() - getTime()).toFixed(5));\r\n    }\r\n\r\n    function getStreamEndTime() {\r\n        return streamInfo.start + streamInfo.duration;\r\n    }\r\n\r\n    function play() {\r\n        if (streamInfo && videoModel && videoModel.getElement()) {\r\n            videoModel.play();\r\n        } else {\r\n            playOnceInitialized = true;\r\n        }\r\n    }\r\n\r\n    function isPaused() {\r\n        return streamInfo && videoModel ? videoModel.isPaused() : null;\r\n    }\r\n\r\n    function pause() {\r\n        if (streamInfo && videoModel) {\r\n            videoModel.pause();\r\n        }\r\n    }\r\n\r\n    function isSeeking() {\r\n        return streamInfo && videoModel ? videoModel.isSeeking() : null;\r\n    }\r\n\r\n    function seek(time, stickToBuffered, internalSeek) {\r\n        if (!streamInfo || !videoModel) return;\r\n\r\n        let currentTime = !isNaN(seekTarget) ? seekTarget : videoModel.getTime();\r\n        if (time === currentTime) return;\r\n\r\n        if (internalSeek === true) {\r\n            // Internal seek = seek video model only (disable 'seeking' listener)\r\n            // buffer(s) are already appended at requested time\r\n            videoModel.removeEventListener('seeking', onPlaybackSeeking);\r\n            logger.info('Requesting internal seek to time: ' + time);\r\n            videoModel.setCurrentTime(time, stickToBuffered);\r\n        } else {\r\n            seekTarget = time;\r\n            eventBus.trigger(Events.PLAYBACK_SEEK_ASKED);\r\n            logger.info('Requesting seek to time: ' + time);\r\n            videoModel.setCurrentTime(time, stickToBuffered);\r\n        }\r\n    }\r\n\r\n    function seekToLive() {\r\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo();\r\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\r\n\r\n        seek(DVRWindow.end - mediaPlayerModel.getLiveDelay(), true, false);\r\n    }\r\n\r\n    function getTime() {\r\n        return streamInfo && videoModel ? videoModel.getTime() : null;\r\n    }\r\n\r\n    function getNormalizedTime() {\r\n        let t = getTime();\r\n\r\n        if (isDynamic && !isNaN(availabilityStartTime)) {\r\n            const timeOffset = availabilityStartTime / 1000;\r\n            // Fix current time for firefox and safari (returned as an absolute time)\r\n            if (t > timeOffset) {\r\n                t -= timeOffset;\r\n            }\r\n        }\r\n        return t;\r\n    }\r\n\r\n    function getPlaybackRate() {\r\n        return streamInfo && videoModel ? videoModel.getPlaybackRate() : null;\r\n    }\r\n\r\n    function getPlayedRanges() {\r\n        return streamInfo && videoModel ? videoModel.getPlayedRanges() : null;\r\n    }\r\n\r\n    function getEnded() {\r\n        return streamInfo && videoModel ? videoModel.getEnded() : null;\r\n    }\r\n\r\n    function getIsDynamic() {\r\n        return isDynamic;\r\n    }\r\n\r\n    function getStreamController() {\r\n        return streamController;\r\n    }\r\n\r\n    /**\r\n     * Computes the desirable delay for the live edge to avoid a risk of getting 404 when playing at the bleeding edge\r\n     * @param {number} fragmentDuration - seconds?\r\n     * @param {number} dvrWindowSize - seconds?\r\n     * @param {number} minBufferTime - seconds?\r\n     * @returns {number} object\r\n     * @memberof PlaybackController#\r\n     */\r\n    function computeAndSetLiveDelay(fragmentDuration, dvrWindowSize, minBufferTime) {\r\n        let delay,\r\n            ret,\r\n            startTime;\r\n        const END_OF_PLAYLIST_PADDING = 10;\r\n        const MIN_BUFFER_TIME_FACTOR = 4;\r\n        const FRAGMENT_DURATION_FACTOR = 4;\r\n        const adjustedFragmentDuration = !isNaN(fragmentDuration) && isFinite(fragmentDuration) ? fragmentDuration : NaN;\r\n\r\n        let suggestedPresentationDelay = adapter.getSuggestedPresentationDelay();\r\n\r\n        if (settings.get().streaming.lowLatencyEnabled) {\r\n            delay = 0;\r\n        } else if (mediaPlayerModel.getLiveDelay()) {\r\n            delay = mediaPlayerModel.getLiveDelay(); // If set by user, this value takes precedence\r\n        } else if (settings.get().streaming.liveDelayFragmentCount !== null && !isNaN(settings.get().streaming.liveDelayFragmentCount) && !isNaN(adjustedFragmentDuration)) {\r\n            delay = adjustedFragmentDuration * settings.get().streaming.liveDelayFragmentCount;\r\n        } else if (settings.get().streaming.useSuggestedPresentationDelay === true && suggestedPresentationDelay !== null && !isNaN(suggestedPresentationDelay) && suggestedPresentationDelay > 0) {\r\n            delay = suggestedPresentationDelay;\r\n        } else if (!isNaN(adjustedFragmentDuration)) {\r\n            delay = adjustedFragmentDuration * FRAGMENT_DURATION_FACTOR;\r\n        } else {\r\n            delay = !isNaN(minBufferTime) ? minBufferTime * MIN_BUFFER_TIME_FACTOR : streamInfo.manifestInfo.minBufferTime * MIN_BUFFER_TIME_FACTOR;\r\n        }\r\n\r\n        startTime = adapter.getAvailabilityStartTime();\r\n\r\n        if (startTime !== null) {\r\n            availabilityStartTime = startTime;\r\n        }\r\n\r\n        if (dvrWindowSize > 0) {\r\n            // cap target latency to:\r\n            // - dvrWindowSize / 2 for short playlists\r\n            // - dvrWindowSize - END_OF_PLAYLIST_PADDING for longer playlists\r\n            const targetDelayCapping = Math.max(dvrWindowSize - END_OF_PLAYLIST_PADDING, dvrWindowSize / 2);\r\n            ret = Math.min(delay, targetDelayCapping);\r\n        } else {\r\n            ret = delay;\r\n        }\r\n        liveDelay = ret;\r\n        return ret;\r\n    }\r\n\r\n    function getLiveDelay() {\r\n        return liveDelay;\r\n    }\r\n\r\n    function setLiveDelay(value, useMaxValue = false) {\r\n        if (useMaxValue && value < liveDelay) {\r\n            return;\r\n        }\r\n\r\n        liveDelay = value;\r\n    }\r\n\r\n    function getCurrentLiveLatency() {\r\n        if (!isDynamic || isNaN(availabilityStartTime)) {\r\n            return NaN;\r\n        }\r\n        let currentTime = getNormalizedTime();\r\n        if (isNaN(currentTime) || currentTime === 0) {\r\n            return 0;\r\n        }\r\n\r\n        const now = new Date().getTime() + timelineConverter.getClientTimeOffset() * 1000;\r\n        return Math.max(((now - availabilityStartTime - currentTime * 1000) / 1000).toFixed(3), 0);\r\n    }\r\n\r\n    function reset() {\r\n        playOnceInitialized = false;\r\n        streamSwitch = false;\r\n        streamSeekTime = NaN;\r\n        liveDelay = 0;\r\n        availabilityStartTime = 0;\r\n        seekTarget = NaN;\r\n        if (videoModel) {\r\n            eventBus.off(Events.STREAM_INITIALIZED, onStreamInitialized, this);\r\n            eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\r\n            eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\r\n            eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\r\n            eventBus.off(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\r\n            eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\r\n            eventBus.off(Events.PLAYBACK_ENDED, onPlaybackEnded, this);\r\n            eventBus.off(Events.STREAM_INITIALIZING, onStreamInitializing, this);\r\n            stopUpdatingWallclockTime();\r\n            removeAllListeners();\r\n        }\r\n        wallclockTimeIntervalId = null;\r\n        videoModel = null;\r\n        streamInfo = null;\r\n        isDynamic = null;\r\n    }\r\n\r\n    function setConfig(config) {\r\n        if (!config) return;\r\n\r\n        if (config.streamController) {\r\n            streamController = config.streamController;\r\n        }\r\n        if (config.dashMetrics) {\r\n            dashMetrics = config.dashMetrics;\r\n        }\r\n        if (config.mediaPlayerModel) {\r\n            mediaPlayerModel = config.mediaPlayerModel;\r\n        }\r\n        if (config.adapter) {\r\n            adapter = config.adapter;\r\n        }\r\n        if (config.videoModel) {\r\n            videoModel = config.videoModel;\r\n        }\r\n        if (config.timelineConverter) {\r\n            timelineConverter = config.timelineConverter;\r\n        }\r\n        if (config.uriFragmentModel) {\r\n            uriFragmentModel = config.uriFragmentModel;\r\n        }\r\n        if (config.settings) {\r\n            settings = config.settings;\r\n        }\r\n    }\r\n\r\n    function getStartTimeFromUriParameters(rangeStart, isDynamic) {\r\n        const fragData = uriFragmentModel.getURIFragmentData();\r\n        if (!fragData || !fragData.t) {\r\n            return NaN;\r\n        }\r\n\r\n        let startTime = NaN;\r\n\r\n        // Consider only start time of MediaRange\r\n        // TODO: consider end time of MediaRange to stop playback at provided end time\r\n        fragData.t = fragData.t.split(',')[0];\r\n\r\n        // \"t=<time>\" : time is relative to period start (for static streams) or DVR window range start (for dynamic streams)\r\n        // \"t=posix:<time>\" : time is absolute start time as number of seconds since 01-01-1970\r\n        startTime = (isDynamic && fragData.t.indexOf('posix:') !== -1) ? parseInt(fragData.t.substring(6)) : (rangeStart + parseInt(fragData.t));\r\n\r\n        return startTime;\r\n    }\r\n\r\n    function getActualPresentationTime(currentTime) {\r\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo();\r\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\r\n        let actualTime;\r\n\r\n        if (!DVRWindow) {\r\n            return NaN;\r\n        }\r\n\r\n        logger.debug(`Checking DVR window for at ${currentTime} with DVR window range ${DVRWindow.start} - ${DVRWindow.end}`);\r\n        if (currentTime > DVRWindow.end) {\r\n            actualTime = Math.max(DVRWindow.end - liveDelay, DVRWindow.start);\r\n\r\n        } else if (currentTime > 0 && currentTime + 0.250 < DVRWindow.start && Math.abs(currentTime - DVRWindow.start) < 315360000) {\r\n\r\n            // Checking currentTime plus 250ms as the 'timeupdate' is fired with a frequency between 4Hz and 66Hz\r\n            // https://developer.mozilla.org/en-US/docs/Web/Events/timeupdate\r\n            // http://w3c.github.io/html/single-page.html#offsets-into-the-media-resource\r\n            // Checking also duration of the DVR makes sense. We detected temporary situations in which currentTime\r\n            // is bad reported by the browser which causes playback to jump to start (315360000 = 1 year)\r\n            //actualTime = DVRWindow.start;\r\n            actualTime = DVRWindow.start;\r\n        } else {\r\n            actualTime = currentTime;\r\n        }\r\n\r\n        return actualTime;\r\n    }\r\n\r\n    function startUpdatingWallclockTime() {\r\n        if (wallclockTimeIntervalId !== null) return;\r\n\r\n        const tick = function () {\r\n            onWallclockTime();\r\n        };\r\n\r\n        wallclockTimeIntervalId = setInterval(tick, settings.get().streaming.wallclockTimeUpdateInterval);\r\n    }\r\n\r\n    function stopUpdatingWallclockTime() {\r\n        clearInterval(wallclockTimeIntervalId);\r\n        wallclockTimeIntervalId = null;\r\n    }\r\n\r\n    function updateCurrentTime() {\r\n        if (isPaused() || !isDynamic || videoModel.getReadyState() === 0) return;\r\n        const currentTime = getNormalizedTime();\r\n        const actualTime = getActualPresentationTime(currentTime);\r\n        const timeChanged = (!isNaN(actualTime) && actualTime !== currentTime);\r\n        if (timeChanged) {\r\n            logger.debug(`UpdateCurrentTime: Seek to actual time: ${actualTime} from currentTime: ${currentTime}`);\r\n            seek(actualTime);\r\n        }\r\n    }\r\n\r\n    function onDataUpdateCompleted(e) {\r\n        if (e.error) return;\r\n\r\n        const representationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation);\r\n        const info = representationInfo ? representationInfo.mediaInfo.streamInfo : null;\r\n\r\n        if (info === null || streamInfo.id !== info.id) return;\r\n        streamInfo = info;\r\n\r\n        updateCurrentTime();\r\n    }\r\n\r\n    function onCanPlay() {\r\n        eventBus.trigger(Events.CAN_PLAY);\r\n    }\r\n\r\n    function onPlaybackStart() {\r\n        logger.info('Native video element event: play');\r\n        updateCurrentTime();\r\n        startUpdatingWallclockTime();\r\n        eventBus.trigger(Events.PLAYBACK_STARTED, { startTime: getTime() });\r\n    }\r\n\r\n    function onPlaybackWaiting() {\r\n        logger.info('Native video element event: waiting');\r\n        eventBus.trigger(Events.PLAYBACK_WAITING, { playingTime: getTime() });\r\n    }\r\n\r\n    function onPlaybackPlaying() {\r\n        logger.info('Native video element event: playing');\r\n        eventBus.trigger(Events.PLAYBACK_PLAYING, { playingTime: getTime() });\r\n    }\r\n\r\n    function onPlaybackPaused() {\r\n        logger.info('Native video element event: pause');\r\n        eventBus.trigger(Events.PLAYBACK_PAUSED, { ended: getEnded() });\r\n    }\r\n\r\n    function onPlaybackSeeking() {\r\n        let seekTime = getTime();\r\n        // On some browsers/devices, in case of live streams, setting current time on video element fails when there is no buffered data at requested time\r\n        // Then re-set seek target time and video element will be seeked afterwhile once data is buffered (see BufferContoller)\r\n        if (!isNaN(seekTarget) && seekTarget !== seekTime) {\r\n            seekTime = seekTarget;\r\n        }\r\n        seekTarget = NaN;\r\n\r\n        logger.info('Seeking to: ' + seekTime);\r\n        startUpdatingWallclockTime();\r\n        eventBus.trigger(Events.PLAYBACK_SEEKING, { seekTime: seekTime });\r\n    }\r\n\r\n    function onPlaybackSeeked() {\r\n        logger.info('Native video element event: seeked');\r\n        eventBus.trigger(Events.PLAYBACK_SEEKED);\r\n        // Reactivate 'seeking' event listener (see seek())\r\n        videoModel.addEventListener('seeking', onPlaybackSeeking);\r\n    }\r\n\r\n    function onPlaybackTimeUpdated() {\r\n        if (streamInfo) {\r\n            eventBus.trigger(Events.PLAYBACK_TIME_UPDATED, {\r\n                timeToEnd: getTimeToStreamEnd(),\r\n                time: getTime()\r\n            });\r\n        }\r\n    }\r\n\r\n    function updateLivePlaybackTime() {\r\n        const now = Date.now();\r\n        if (!lastLivePlaybackTime || now > lastLivePlaybackTime + LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS) {\r\n            lastLivePlaybackTime = now;\r\n            onPlaybackTimeUpdated();\r\n        }\r\n    }\r\n\r\n    function onPlaybackProgress() {\r\n        eventBus.trigger(Events.PLAYBACK_PROGRESS);\r\n    }\r\n\r\n    function onPlaybackRateChanged() {\r\n        const rate = getPlaybackRate();\r\n        logger.info('Native video element event: ratechange: ', rate);\r\n        eventBus.trigger(Events.PLAYBACK_RATE_CHANGED, { playbackRate: rate });\r\n    }\r\n\r\n    function onPlaybackMetaDataLoaded() {\r\n        logger.info('Native video element event: loadedmetadata');\r\n        eventBus.trigger(Events.PLAYBACK_METADATA_LOADED);\r\n        startUpdatingWallclockTime();\r\n    }\r\n\r\n    // Event to handle the native video element ended event\r\n    function onNativePlaybackEnded() {\r\n        logger.info('Native video element event: ended');\r\n        pause();\r\n        stopUpdatingWallclockTime();\r\n        eventBus.trigger(Events.PLAYBACK_ENDED, { 'isLast': streamController.getActiveStreamInfo().isLast });\r\n    }\r\n\r\n    // Handle DASH PLAYBACK_ENDED event\r\n    function onPlaybackEnded(e) {\r\n        if (wallclockTimeIntervalId && e.isLast) {\r\n            // PLAYBACK_ENDED was triggered elsewhere, react.\r\n            logger.info('onPlaybackEnded -- PLAYBACK_ENDED but native video element didn\\'t fire ended');\r\n            const seekTime = e.seekTime ? e.seekTime : getStreamEndTime();\r\n            videoModel.setCurrentTime(seekTime);\r\n            pause();\r\n            stopUpdatingWallclockTime();\r\n        }\r\n    }\r\n\r\n    function onPlaybackError(event) {\r\n        const target = event.target || event.srcElement;\r\n        eventBus.trigger(Events.PLAYBACK_ERROR, { error: target.error });\r\n    }\r\n\r\n    function onWallclockTime() {\r\n        eventBus.trigger(Events.WALLCLOCK_TIME_UPDATED, {\r\n            isDynamic: isDynamic,\r\n            time: new Date()\r\n        });\r\n\r\n        // Updates playback time for paused dynamic streams\r\n        // (video element doesn't call timeupdate when the playback is paused)\r\n        if (getIsDynamic() && isPaused()) {\r\n            updateLivePlaybackTime();\r\n        }\r\n    }\r\n\r\n    function onPlaybackProgression() {\r\n        if (\r\n            isDynamic &&\r\n            settings.get().streaming.lowLatencyEnabled &&\r\n            settings.get().streaming.liveCatchUpPlaybackRate > 0 &&\r\n            !isPaused() &&\r\n            !isSeeking()\r\n        ) {\r\n            if (needToCatchUp()) {\r\n                startPlaybackCatchUp();\r\n            } else {\r\n                stopPlaybackCatchUp();\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBufferLevel() {\r\n        let bufferLevel = null;\r\n        streamController.getActiveStreamProcessors().forEach(p => {\r\n            const bl = p.getBufferLevel();\r\n            if (bufferLevel === null) {\r\n                bufferLevel = bl;\r\n            } else {\r\n                bufferLevel = Math.min(bufferLevel, bl);\r\n            }\r\n        });\r\n\r\n        return bufferLevel;\r\n    }\r\n\r\n    function needToCatchUp() {\r\n        const currentLiveLatency = getCurrentLiveLatency();\r\n        const latencyDrift = Math.abs(currentLiveLatency - mediaPlayerModel.getLiveDelay());\r\n        const liveCatchupLatencyThreshold = mediaPlayerModel.getLiveCatchupLatencyThreshold();\r\n\r\n        return settings.get().streaming.lowLatencyEnabled && settings.get().streaming.liveCatchUpPlaybackRate > 0 && getTime() > 0 &&\r\n            latencyDrift > settings.get().streaming.liveCatchUpMinDrift && (isNaN(liveCatchupLatencyThreshold) || currentLiveLatency <= liveCatchupLatencyThreshold);\r\n    }\r\n\r\n    function startPlaybackCatchUp() {\r\n        if (videoModel) {\r\n            const cpr = settings.get().streaming.liveCatchUpPlaybackRate;\r\n            const liveDelay = mediaPlayerModel.getLiveDelay();\r\n            const deltaLatency = getCurrentLiveLatency() - liveDelay;\r\n            const d = deltaLatency * 5;\r\n            // Playback rate must be between (1 - cpr) - (1 + cpr)\r\n            // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\r\n            const s = (cpr * 2) / (1 + Math.pow(Math.E, -d));\r\n            let newRate = (1 - cpr) + s;\r\n            // take into account situations in which there are buffer stalls,\r\n            // in which increasing playbackRate to reach target latency will\r\n            // just cause more and more stall situations\r\n            if (playbackStalled) {\r\n                const bufferLevel = getBufferLevel();\r\n                if (bufferLevel > liveDelay / 2) {\r\n                    playbackStalled = false;\r\n                } else if (deltaLatency > 0) {\r\n                    newRate = 1.0;\r\n                }\r\n            }\r\n\r\n            // don't change playbackrate for small variations (don't overload element with playbackrate changes)\r\n            if (Math.abs(videoModel.getPlaybackRate() - newRate) > minPlaybackRateChange) {\r\n                videoModel.setPlaybackRate(newRate);\r\n            }\r\n\r\n            if (settings.get().streaming.liveCatchUpMaxDrift > 0 && !isLowLatencySeekingInProgress &&\r\n                deltaLatency > settings.get().streaming.liveCatchUpMaxDrift) {\r\n                logger.info('Low Latency catchup mechanism. Latency too high, doing a seek to live point');\r\n                isLowLatencySeekingInProgress = true;\r\n                seekToLive();\r\n            } else {\r\n                isLowLatencySeekingInProgress = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function stopPlaybackCatchUp() {\r\n        if (videoModel) {\r\n            videoModel.setPlaybackRate(1.0);\r\n        }\r\n    }\r\n\r\n    function onFragmentLoadProgress(e) {\r\n        // If using fetch and stream mode is not available, readjust live latency so it is 20% higher than segment duration\r\n        if (e.stream === false && settings.get().streaming.lowLatencyEnabled && !isNaN(e.request.duration)) {\r\n            const minDelay = 1.2 * e.request.duration;\r\n            if (minDelay > mediaPlayerModel.getLiveDelay()) {\r\n                logger.warn('Browser does not support fetch API with StreamReader. Increasing live delay to be 20% higher than segment duration:', minDelay.toFixed(2));\r\n                const s = {streaming: {liveDelay: minDelay}};\r\n                settings.update(s);\r\n            }\r\n        }\r\n    }\r\n\r\n    function onBufferLevelStateChanged(e) {\r\n        // do not stall playback when get an event from Stream that is not active\r\n        if (e.streamId !== streamInfo.id) return;\r\n\r\n        if (settings.get().streaming.lowLatencyEnabled) {\r\n            if (e.state === MetricsConstants.BUFFER_EMPTY && !isSeeking()) {\r\n                if (!playbackStalled) {\r\n                    playbackStalled = true;\r\n                    stopPlaybackCatchUp();\r\n                }\r\n            }\r\n        } else {\r\n            videoModel.setStallState(e.mediaType, e.state === MetricsConstants.BUFFER_EMPTY);\r\n        }\r\n    }\r\n\r\n    function onPlaybackStalled(e) {\r\n        eventBus.trigger(Events.PLAYBACK_STALLED, { e: e });\r\n    }\r\n\r\n    function onStreamInitializing(e) {\r\n        applyServiceDescription(e.streamInfo, e.mediaInfo);\r\n    }\r\n\r\n    function applyServiceDescription(streamInfo, mediaInfo) {\r\n        if (streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.serviceDescriptions) {\r\n            // is there a service description for low latency defined?\r\n            let llsd;\r\n\r\n            for (let i = 0; i < streamInfo.manifestInfo.serviceDescriptions.length; i++) {\r\n                const sd = streamInfo.manifestInfo.serviceDescriptions[i];\r\n                if (sd.schemeIdUri === Constants.SERVICE_DESCRIPTION_LL_SCHEME) {\r\n                    llsd = sd;\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (llsd) {\r\n                if (mediaInfo && mediaInfo.supplementalProperties &&\r\n                    mediaInfo.supplementalProperties[Constants.SUPPLEMENTAL_PROPERTY_LL_SCHEME] === 'true') {\r\n                    if (llsd.latency && llsd.latency.target > 0) {\r\n                        logger.debug('Apply LL properties coming from service description. Target Latency (ms):', llsd.latency.target);\r\n                        settings.update({\r\n                            streaming: {\r\n                                lowLatencyEnabled: true,\r\n                                liveDelay: llsd.latency.target / 1000,\r\n                                liveCatchUpMinDrift: llsd.latency.max > llsd.latency.target ? (llsd.latency.max - llsd.latency.target) / 1000 : undefined\r\n                            }\r\n                        });\r\n                    }\r\n                    if (llsd.playbackRate && llsd.playbackRate.max > 1.0) {\r\n                        logger.debug('Apply LL properties coming from service description. Max PlaybackRate:', llsd.playbackRate.max);\r\n                        settings.update({\r\n                            streaming: {\r\n                                lowLatencyEnabled: true,\r\n                                liveCatchUpPlaybackRate: llsd.playbackRate.max - 1.0\r\n                            }\r\n                        });\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function addAllListeners() {\r\n        videoModel.addEventListener('canplay', onCanPlay);\r\n        videoModel.addEventListener('play', onPlaybackStart);\r\n        videoModel.addEventListener('waiting', onPlaybackWaiting);\r\n        videoModel.addEventListener('playing', onPlaybackPlaying);\r\n        videoModel.addEventListener('pause', onPlaybackPaused);\r\n        videoModel.addEventListener('error', onPlaybackError);\r\n        videoModel.addEventListener('seeking', onPlaybackSeeking);\r\n        videoModel.addEventListener('seeked', onPlaybackSeeked);\r\n        videoModel.addEventListener('timeupdate', onPlaybackTimeUpdated);\r\n        videoModel.addEventListener('progress', onPlaybackProgress);\r\n        videoModel.addEventListener('ratechange', onPlaybackRateChanged);\r\n        videoModel.addEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\r\n        videoModel.addEventListener('stalled', onPlaybackStalled);\r\n        videoModel.addEventListener('ended', onNativePlaybackEnded);\r\n    }\r\n\r\n    function removeAllListeners() {\r\n        videoModel.removeEventListener('canplay', onCanPlay);\r\n        videoModel.removeEventListener('play', onPlaybackStart);\r\n        videoModel.removeEventListener('waiting', onPlaybackWaiting);\r\n        videoModel.removeEventListener('playing', onPlaybackPlaying);\r\n        videoModel.removeEventListener('pause', onPlaybackPaused);\r\n        videoModel.removeEventListener('error', onPlaybackError);\r\n        videoModel.removeEventListener('seeking', onPlaybackSeeking);\r\n        videoModel.removeEventListener('seeked', onPlaybackSeeked);\r\n        videoModel.removeEventListener('timeupdate', onPlaybackTimeUpdated);\r\n        videoModel.removeEventListener('progress', onPlaybackProgress);\r\n        videoModel.removeEventListener('ratechange', onPlaybackRateChanged);\r\n        videoModel.removeEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\r\n        videoModel.removeEventListener('stalled', onPlaybackStalled);\r\n        videoModel.removeEventListener('ended', onNativePlaybackEnded);\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        setConfig: setConfig,\r\n        getStartTimeFromUriParameters: getStartTimeFromUriParameters,\r\n        getTimeToStreamEnd: getTimeToStreamEnd,\r\n        getTime: getTime,\r\n        getNormalizedTime: getNormalizedTime,\r\n        getPlaybackRate: getPlaybackRate,\r\n        getPlayedRanges: getPlayedRanges,\r\n        getEnded: getEnded,\r\n        getIsDynamic: getIsDynamic,\r\n        getStreamController: getStreamController,\r\n        computeAndSetLiveDelay: computeAndSetLiveDelay,\r\n        getLiveDelay: getLiveDelay,\r\n        setLiveDelay: setLiveDelay,\r\n        getCurrentLiveLatency: getCurrentLiveLatency,\r\n        play: play,\r\n        isPaused: isPaused,\r\n        pause: pause,\r\n        isSeeking: isSeeking,\r\n        getStreamEndTime,\r\n        seek: seek,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nPlaybackController.__dashjs_factory_name = 'PlaybackController';\r\nexport default FactoryMaker.getSingletonFactory(PlaybackController);\r\n"]}