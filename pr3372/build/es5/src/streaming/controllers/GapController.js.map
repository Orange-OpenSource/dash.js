{"version":3,"sources":["../../../../../src/streaming/controllers/GapController.js"],"names":["GAP_HANDLER_INTERVAL","THRESHOLD_TO_STALLS","GAP_THRESHOLD","GapController","context","eventBus","getInstance","instance","lastPlaybackTime","settings","wallclockTicked","gapHandlerInterval","lastGapJumpPosition","playbackController","streamController","videoModel","logger","initialize","registerEvents","setup","getLogger","reset","stopGapHandler","unregisterEvents","resetInitialSettings","NaN","setConfig","config","on","Events","WALLCLOCK_TIME_UPDATED","onWallclockTimeUpdated","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","off","startGapHandler","_shouldCheckForGaps","get","streaming","jumpGaps","getActiveStreamProcessors","length","isSeeking","isPaused","getIsStreamSwitchInProgress","getHasMediaOrIntialisationError","currentTime","getTime","jumpGap","getNextRangeStartTime","ranges","getBufferRange","nextRangeStartTime","j","rangeEnd","end","start","e","debug","setInterval","clearInterval","playbackStalled","smallGapLimit","jumpLargeGaps","seekToPosition","jumpToStreamEnd","gap","timeToStreamEnd","getTimeToStreamEnd","isNaN","isFinite","parseFloat","toFixed","warn","trigger","GAP_CAUSED_PLAYBACK_SEEK","seekTime","seek","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"GapController.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport Debug from '../../core/Debug';\r\nimport Events from '../../core/events/Events';\r\nimport EventBus from '../../core/EventBus';\r\n\r\nconst GAP_HANDLER_INTERVAL = 100;\r\nconst THRESHOLD_TO_STALLS = 10;\r\nconst GAP_THRESHOLD = 0.1;\r\n\r\nfunction GapController() {\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n\r\n    let instance,\r\n        lastPlaybackTime,\r\n        settings,\r\n        wallclockTicked,\r\n        gapHandlerInterval,\r\n        lastGapJumpPosition,\r\n        playbackController,\r\n        streamController,\r\n        videoModel,\r\n        logger;\r\n\r\n    function initialize() {\r\n        registerEvents();\r\n    }\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n\r\n        reset();\r\n    }\r\n\r\n    function reset() {\r\n        stopGapHandler();\r\n        unregisterEvents();\r\n        resetInitialSettings();\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        gapHandlerInterval = null;\r\n        lastGapJumpPosition = NaN;\r\n        wallclockTicked = 0;\r\n    }\r\n\r\n    function setConfig(config) {\r\n        if (!config) {\r\n            return;\r\n        }\r\n        if (config.settings) {\r\n            settings = config.settings;\r\n        }\r\n        if (config.playbackController) {\r\n            playbackController = config.playbackController;\r\n        }\r\n        if (config.streamController) {\r\n            streamController = config.streamController;\r\n        }\r\n        if (config.videoModel) {\r\n            videoModel = config.videoModel;\r\n        }\r\n    }\r\n\r\n    function registerEvents() {\r\n        eventBus.on(Events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\r\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\r\n    }\r\n\r\n    function unregisterEvents() {\r\n        eventBus.off(Events.WALLCLOCK_TIME_UPDATED, onWallclockTimeUpdated, instance);\r\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, instance);\r\n    }\r\n\r\n    function onBytesAppended() {\r\n        if (!gapHandlerInterval) {\r\n            startGapHandler();\r\n        }\r\n    }\r\n\r\n    function _shouldCheckForGaps() {\r\n        return settings.get().streaming.jumpGaps && streamController.getActiveStreamProcessors().length > 0 &&\r\n            !playbackController.isSeeking() && !playbackController.isPaused() && !streamController.getIsStreamSwitchInProgress() &&\r\n            !streamController.getHasMediaOrIntialisationError();\r\n    }\r\n\r\n    function onWallclockTimeUpdated(/*e*/) {\r\n        if (!_shouldCheckForGaps()) {\r\n            return;\r\n        }\r\n\r\n        wallclockTicked++;\r\n        if (wallclockTicked >= THRESHOLD_TO_STALLS) {\r\n            const currentTime = playbackController.getTime();\r\n            if (lastPlaybackTime === currentTime) {\r\n                jumpGap(currentTime, true);\r\n            } else {\r\n                lastPlaybackTime = currentTime;\r\n            }\r\n            wallclockTicked = 0;\r\n        }\r\n    }\r\n\r\n    function getNextRangeStartTime(currentTime) {\r\n        try {\r\n            const ranges = videoModel.getBufferRange();\r\n            if (!ranges || (ranges.length <= 1 && currentTime > 0)) {\r\n                return null;\r\n            }\r\n            let nextRangeStartTime = null;\r\n            let j = 0;\r\n\r\n            while (!nextRangeStartTime && j < ranges.length) {\r\n                const rangeEnd = j > 0 ? ranges.end(j - 1) : 0;\r\n                if (currentTime < ranges.start(j) && rangeEnd - currentTime < GAP_THRESHOLD) {\r\n                    nextRangeStartTime = ranges.start(j);\r\n                }\r\n                j += 1;\r\n            }\r\n            return nextRangeStartTime;\r\n\r\n        } catch (e) {\r\n            return null;\r\n        }\r\n    }\r\n\r\n\r\n    function startGapHandler() {\r\n        try {\r\n            if (!gapHandlerInterval) {\r\n                logger.debug('Starting the gap controller');\r\n                gapHandlerInterval = setInterval(() => {\r\n                    if (!_shouldCheckForGaps()) {\r\n                        return;\r\n                    }\r\n                    const currentTime = playbackController.getTime();\r\n                    jumpGap(currentTime);\r\n\r\n                }, GAP_HANDLER_INTERVAL);\r\n            }\r\n        } catch (e) {\r\n        }\r\n    }\r\n\r\n    function stopGapHandler() {\r\n        logger.debug('Stopping the gap controller');\r\n        if (gapHandlerInterval) {\r\n            clearInterval(gapHandlerInterval);\r\n            gapHandlerInterval = null;\r\n        }\r\n    }\r\n\r\n    function jumpGap(currentTime, playbackStalled = false) {\r\n        const smallGapLimit = settings.get().streaming.smallGapLimit;\r\n        const jumpLargeGaps = settings.get().streaming.jumpLargeGaps;\r\n        let nextRangeStartTime = null;\r\n        let seekToPosition = NaN;\r\n        let jumpToStreamEnd = false;\r\n\r\n\r\n        // Get the range just after current time position\r\n        nextRangeStartTime = getNextRangeStartTime(currentTime);\r\n\r\n        if (nextRangeStartTime && nextRangeStartTime > 0) {\r\n            const gap = nextRangeStartTime - currentTime;\r\n            if (gap > 0 && (gap <= smallGapLimit || jumpLargeGaps)) {\r\n                seekToPosition = nextRangeStartTime;\r\n            }\r\n        }\r\n\r\n        const timeToStreamEnd = playbackController.getTimeToStreamEnd();\r\n        if (isNaN(seekToPosition) && playbackStalled && isFinite(timeToStreamEnd) && !isNaN(timeToStreamEnd) && (timeToStreamEnd < smallGapLimit)) {\r\n            seekToPosition = parseFloat(currentTime + timeToStreamEnd).toFixed(5);\r\n            jumpToStreamEnd = true;\r\n        }\r\n\r\n        if (seekToPosition > 0 && lastGapJumpPosition !== seekToPosition) {\r\n            if (jumpToStreamEnd) {\r\n                logger.warn(`Jumping to end of stream because of gap from ${currentTime} to ${seekToPosition}. Gap duration: ${seekToPosition - currentTime}`);\r\n                eventBus.trigger(Events.GAP_CAUSED_PLAYBACK_SEEK, {seekTime: seekToPosition});\r\n            } else {\r\n                logger.warn(`Jumping gap from ${currentTime} to ${seekToPosition}. Gap duration: ${seekToPosition - currentTime}`);\r\n                playbackController.seek(seekToPosition, true, true);\r\n            }\r\n            lastGapJumpPosition = seekToPosition;\r\n        }\r\n    }\r\n\r\n    instance = {\r\n        reset,\r\n        setConfig,\r\n        initialize\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nGapController.__dashjs_factory_name = 'GapController';\r\nexport default FactoryMaker.getSingletonFactory(GapController);\r\n"]}