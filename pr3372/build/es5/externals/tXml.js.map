{"version":3,"sources":["../../../externals/tXml.js"],"names":["tXml","S","options","attrMatchers","arrayChildNames","pos","openBracket","openBracketCC","charCodeAt","closeBracket","closeBracketCC","minus","minusCC","slash","slashCC","exclamation","exclamationCC","singleQuote","singleQuoteCC","doubleQuote","doubleQuoteCC","openCornerBracket","openCornerBracketCC","closeCornerBracket","closeCornerBracketCC","parseChildren","parent","children","indexOf","length","substr","toLowerCase","cdataEndIndex","push","substring","child","parseNode","tagName","text","parseText","trim","__text","processAttr","attrName","value","parseInt","attrValue","forEach","matcher","test","converter","start","slice","nameSpacer","parseName","node","c","name","code","parseString","startChar","startpos","findElements","r","RegExp","exec","index","out","undefined","lastIndexOf","setPos","module","exports","xml"],"mappings":"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","file":"tXml.js","sourcesContent":["/**\n* The MIT License (MIT)\n*\n* Copyright (c) 2015 Tobias Nickel\n*\n* Permission is hereby granted, free of charge, to any person obtaining a copy\n* of this software and associated documentation files (the \"Software\"), to deal\n* in the Software without restriction, including without limitation the rights\n* to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n* copies of the Software, and to permit persons to whom the Software is\n* furnished to do so, subject to the following conditions:\n*\n* The above copyright notice and this permission notice shall be included in all\n* copies or substantial portions of the Software.\n*\n* THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n* IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n* FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n* AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n* LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n* OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n* SOFTWARE.\n\n/**\n * @author: Tobias Nickel\n * @created: 06.04.2015\n * I needed a small xmlparser chat can be used in a worker.\n */\n\n/**\n * @typedef tNode\n * @property {string} tagName\n * @property {object} attributes\n * @property {tNode|string|number[]} children\n **/\n\n/**\n * parseXML / html into a DOM Object. with no validation and some failur tolerance\n * @param {string} S your XML to parse\n * @param options {object} all other options:\n * searchId {string} the id of a single element, that should be returned. using this will increase the speed rapidly\n * filter {function} filter method, as you know it from Array.filter. but is goes throw the DOM.\n\n * @return {tNode[]}\n */\nfunction tXml(S, options, attrMatchers, arrayChildNames) {\n    \"use strict\";\n    options = options || {};\n    attrMatchers = attrMatchers || {};\n    arrayChildNames = arrayChildNames || [];\n\n    var pos = options.pos || 0;\n\n    var openBracket = \"<\";\n    var openBracketCC = \"<\".charCodeAt(0);\n    var closeBracket = \">\";\n    var closeBracketCC = \">\".charCodeAt(0);\n    var minus = \"-\";\n    var minusCC = \"-\".charCodeAt(0);\n    var slash = \"/\";\n    var slashCC = \"/\".charCodeAt(0);\n    var exclamation = '!';\n    var exclamationCC = '!'.charCodeAt(0);\n    var singleQuote = \"'\";\n    var singleQuoteCC = \"'\".charCodeAt(0);\n    var doubleQuote = '\"';\n    var doubleQuoteCC = '\"'.charCodeAt(0);\n    var openCornerBracket = '[';\n    var openCornerBracketCC = '['.charCodeAt(0);\n    var closeCornerBracket = ']';\n    var closeCornerBracketCC = ']'.charCodeAt(0);\n\n\n    /**\n     * parsing a list of entries\n     */\n    function parseChildren(parent) {\n        var children = [];\n        while (S[pos]) {\n            if (S.charCodeAt(pos) == openBracketCC) {\n                if (S.charCodeAt(pos + 1) === slashCC) {\n                    pos = S.indexOf(closeBracket, pos);\n                    if (pos + 1) pos += 1\n                    return children;\n                } else if (S.charCodeAt(pos + 1) === exclamationCC) {\n                    if (S.charCodeAt(pos + 2) == minusCC) {\n                        //comment support\n                        while (pos !== -1 && !(S.charCodeAt(pos) === closeBracketCC && S.charCodeAt(pos - 1) == minusCC && S.charCodeAt(pos - 2) == minusCC && pos != -1)) {\n                            pos = S.indexOf(closeBracket, pos + 1);\n                        }\n                        if (pos === -1) {\n                            pos = S.length\n                        }\n                    }else if(\n                        S.charCodeAt(pos + 2) === openCornerBracketCC\n                        && S.charCodeAt(pos + 8) === openCornerBracketCC\n                        && S.substr(pos+3, 5).toLowerCase() === 'cdata'\n                    ){\n                        // cdata\n                        var cdataEndIndex = S.indexOf(']]>',pos)\n                        if (cdataEndIndex==-1) {\n                            children.push(S.substr(pos+8));\n                            pos=S.length;\n                        } else {\n                            children.push(S.substring(pos+9, cdataEndIndex));\n                            pos = cdataEndIndex + 3;\n                        }\n                        continue\n                    } else {\n                        // doctypesupport\n                        pos += 2;\n                        while (S.charCodeAt(pos) !== closeBracketCC && S[pos]) {\n                            pos++;\n                        }\n                    }\n                    pos++;\n                    continue;\n                }\n                // if parent is provided then add children as object(s)\n                var child = parseNode();\n                if (parent) {\n                    let tagName = child.tagName;\n                    delete child.tagName;\n                    if (arrayChildNames.indexOf(tagName) !== -1) {\n                        if (!parent[tagName]) {\n                            parent[tagName] = [];\n                        }\n                        parent[tagName].push(child);\n                    } else {\n                        parent[tagName] = child;\n                    }\n                }\n                children.push(child);\n            } else {\n                var text = parseText()\n                if (text.trim().length > 0)\n                    if (parent) parent.__text = text;\n                    else children.push(text);\n                pos++;\n            }\n        }\n        return children;\n    }\n\n    function processAttr(tagName, attrName, value) {\n\n        // Specific use case for SegmentTimeline <S> tag\n        if (tagName === 'S') {\n            return parseInt(value);\n        }\n\n        let attrValue = value;\n        attrMatchers.forEach(matcher => {\n            if (matcher.test(tagName, attrName, value)) {\n                attrValue = matcher.converter(value);\n            }\n        });\n        return attrValue;\n    }\n\n    /**\n     *    returns the text outside of texts until the first '<'\n     */\n    function parseText() {\n        var start = pos;\n        pos = S.indexOf(openBracket, pos) - 1;\n        if (pos === -2)\n            pos = S.length;\n        return S.slice(start, pos + 1);\n    }\n    /**\n     *    returns text until the first nonAlphebetic letter\n     */\n    var nameSpacer = '\\r\\n\\t>/= ';\n\n    function parseName() {\n        var start = pos;\n        while (nameSpacer.indexOf(S[pos]) === -1 && S[pos]) {\n            pos++;\n        }\n        return S.slice(start, pos);\n    }\n    /**\n     *    is parsing a node, including tagName, Attributes and its children,\n     * to parse children it uses the parseChildren again, that makes the parsing recursive\n     */\n\n    function parseNode() {\n        pos++;\n        let node = {\n            tagName: parseName()\n        };\n\n        // parsing attributes\n        while (S.charCodeAt(pos) !== closeBracketCC && S[pos]) {\n            var c = S.charCodeAt(pos);\n            if ((c > 64 && c < 91) || (c > 96 && c < 123)) {\n                //if('abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.indexOf(S[pos])!==-1 ){\n                var name = parseName();\n                // search beginning of the string\n                var code = S.charCodeAt(pos);\n                while (code && code !== singleQuoteCC && code !== doubleQuoteCC && !((code > 64 && code < 91) || (code > 96 && code < 123)) && code !== closeBracketCC) {\n                    pos++;\n                    code = S.charCodeAt(pos);\n                }\n                if (code === singleQuoteCC || code === doubleQuoteCC) {\n                    var value = parseString();\n                    if (pos === -1) {\n                        return node;\n                    }\n                } else {\n                    value = null;\n                    pos--;\n                }\n                value = processAttr(node.tagName, name, value);\n                node[name] = value;\n            }\n            pos++;\n        }\n        // optional parsing of children\n        if (S.charCodeAt(pos - 1) !== slashCC) {\n            pos++;\n            parseChildren(node);\n        } else {\n            pos++;\n        }\n        return node;\n    }\n\n    /**\n     *    is parsing a string, that starts with a char and with the same usually  ' or \"\n     */\n\n    function parseString() {\n        var startChar = S[pos];\n        var startpos = pos+1;\n        pos = S.indexOf(startChar, startpos)\n        return S.slice(startpos, pos);\n    }\n\n    /**\n     *\n     */\n    function findElements() {\n        var r = new RegExp('\\\\s' + options.attrName + '\\\\s*=[\\'\"]' + options.attrValue + '[\\'\"]').exec(S)\n        if (r) {\n            return r.index;\n        } else {\n            return -1;\n        }\n    }\n\n    var out = null;\n    if (options.attrValue !== undefined) {\n        options.attrName = options.attrName || 'id';\n        var out = [];\n\n        while ((pos = findElements()) !== -1) {\n            pos = S.lastIndexOf('<', pos);\n            if (pos !== -1) {\n                out.push(parseNode());\n            }\n            S = S.substr(pos);\n            pos = 0;\n        }\n    } else if (options.parseNode) {\n        out = parseNode()\n    } else {\n        out = parseChildren();\n    }\n\n    if (options.setPos) {\n        out.pos = pos;\n    }\n\n    return out;\n}\n\n\nif ('object' === typeof module) {\n    module.exports = tXml;\n    tXml.xml = tXml;\n}\n\n"]}