{"version":3,"sources":["../../../../src/streaming/SourceBufferSink.js"],"names":["Debug","DashJSError","EventBus","Events","FactoryMaker","TextController","Errors","MAX_ALLOWED_DISCONTINUITY","SourceBufferSink","mediaSource","mediaInfo","onAppendedCallback","oldBuffer","context","eventBus","getInstance","instance","logger","buffer","isAppendingInProgress","intervalId","callbacks","appendQueue","onAppended","setup","getLogger","codec","match","Error","addSourceBuffer","changeType","debug","CHECK_INTERVAL","addEventListener","updateEndHandler","errHandler","err","setInterval","checkIsUpdateEnded","ex","isText","indexOf","textController","getTextSourceBuffer","reset","keepBuffer","removeEventListener","clearInterval","getClassName","removeSourceBuffer","e","error","getBuffer","getAllBufferRanges","buffered","message","hasDiscontinuitiesAfter","time","ranges","length","i","len","start","end","append","chunk","APPEND_ERROR_CODE","APPEND_ERROR_MESSAGE","push","waitForUpdateEnd","appendNextInQueue","bind","updateTimestampOffset","MSETimeOffset","timestampOffset","isNaN","remove","forceRemoval","sourceBufferSink","readyState","trigger","SOURCEBUFFER_REMOVE_COMPLETED","from","to","unintended","code","nextChunk","splice","oldRanges","afterSuccess","newRanges","checkBufferGapsAfterAppend","call","bytes","appendBuffer","fatal","isChunkAlignedWithRange","Math","round","abort","setTextTrack","executeCallback","cb","shift","updating","type","callback","__dashjs_factory_name","factory","getClassFactory"],"mappings":"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","file":"SourceBufferSink.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport Debug from '../core/Debug';\r\nimport DashJSError from './vo/DashJSError';\r\nimport EventBus from '../core/EventBus';\r\nimport Events from '../core/events/Events';\r\nimport FactoryMaker from '../core/FactoryMaker';\r\nimport TextController from './text/TextController';\r\nimport Errors from '../core/errors/Errors';\r\n\r\nconst MAX_ALLOWED_DISCONTINUITY = 0.1; // 100 milliseconds\r\n\r\n/**\r\n * @class SourceBufferSink\r\n * @implements FragmentSink\r\n */\r\nfunction SourceBufferSink(mediaSource, mediaInfo, onAppendedCallback, oldBuffer) {\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n\r\n    let instance,\r\n        logger,\r\n        buffer,\r\n        isAppendingInProgress,\r\n        intervalId;\r\n\r\n    let callbacks = [];\r\n    let appendQueue = [];\r\n    let onAppended = onAppendedCallback;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        isAppendingInProgress = false;\r\n\r\n        const codec = mediaInfo.codec;\r\n        try {\r\n            // Safari claims to support anything starting 'application/mp4'.\r\n            // it definitely doesn't understand 'application/mp4;codecs=\"stpp\"'\r\n            // - currently no browser does, so check for it and use our own\r\n            // implementation. The same is true for codecs=\"wvtt\".\r\n            if (codec.match(/application\\/mp4;\\s*codecs=\"(stpp|wvtt).*\"/i)) {\r\n                throw new Error('not really supported');\r\n            }\r\n            buffer = oldBuffer ? oldBuffer : mediaSource.addSourceBuffer(codec);\r\n            if (buffer.changeType && oldBuffer) {\r\n                logger.debug('Doing period transition with changeType');\r\n                buffer.changeType(codec);\r\n            }\r\n\r\n            const CHECK_INTERVAL = 50;\r\n            // use updateend event if possible\r\n            if (typeof buffer.addEventListener === 'function') {\r\n                try {\r\n                    buffer.addEventListener('updateend', updateEndHandler, false);\r\n                    buffer.addEventListener('error', errHandler, false);\r\n                    buffer.addEventListener('abort', errHandler, false);\r\n\r\n                } catch (err) {\r\n                    // use setInterval to periodically check if updating has been completed\r\n                    intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\r\n                }\r\n            } else {\r\n                // use setInterval to periodically check if updating has been completed\r\n                intervalId = setInterval(checkIsUpdateEnded, CHECK_INTERVAL);\r\n            }\r\n        } catch (ex) {\r\n            // Note that in the following, the quotes are open to allow for extra text after stpp and wvtt\r\n            if ((mediaInfo.isText) || (codec.indexOf('codecs=\"stpp') !== -1) || (codec.indexOf('codecs=\"wvtt') !== -1)) {\r\n                const textController = TextController(context).getInstance();\r\n                buffer = textController.getTextSourceBuffer();\r\n            } else {\r\n                throw ex;\r\n            }\r\n        }\r\n    }\r\n\r\n    function reset(keepBuffer) {\r\n        if (buffer) {\r\n            if (typeof buffer.removeEventListener === 'function') {\r\n                buffer.removeEventListener('updateend', updateEndHandler, false);\r\n                buffer.removeEventListener('error', errHandler, false);\r\n                buffer.removeEventListener('abort', errHandler, false);\r\n            }\r\n            clearInterval(intervalId);\r\n            if (!keepBuffer) {\r\n                try {\r\n                    if (!buffer.getClassName || buffer.getClassName() !== 'TextSourceBuffer') {\r\n                        mediaSource.removeSourceBuffer(buffer);\r\n                    }\r\n                } catch (e) {\r\n                    logger.error('Failed to remove source buffer from media source.');\r\n                }\r\n                buffer = null;\r\n            }\r\n            isAppendingInProgress = false;\r\n        }\r\n        appendQueue = [];\r\n        onAppended = null;\r\n    }\r\n\r\n    function getBuffer() {\r\n        return buffer;\r\n    }\r\n\r\n    function getAllBufferRanges() {\r\n        try {\r\n            return buffer.buffered;\r\n        } catch (e) {\r\n            logger.error('getAllBufferRanges exception: ' + e.message);\r\n            return null;\r\n        }\r\n    }\r\n\r\n    function hasDiscontinuitiesAfter(time) {\r\n        try {\r\n            const ranges = getAllBufferRanges();\r\n            if (ranges && ranges.length > 1) {\r\n                for (let i = 0, len = ranges.length; i < len; i++) {\r\n                    if (i > 0) {\r\n                        if (time < ranges.start(i) && ranges.start(i) > ranges.end(i - 1) + MAX_ALLOWED_DISCONTINUITY) {\r\n                            return true;\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        } catch (e) {\r\n            logger.error('hasDiscontinuities exception: ' + e.message);\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function append(chunk) {\r\n        if (!chunk) {\r\n            onAppended({\r\n                chunk: chunk,\r\n                error: new DashJSError(Errors.APPEND_ERROR_CODE, Errors.APPEND_ERROR_MESSAGE)\r\n            });\r\n            return;\r\n        }\r\n        appendQueue.push(chunk);\r\n        if (!isAppendingInProgress) {\r\n            waitForUpdateEnd(buffer, appendNextInQueue.bind(this));\r\n        }\r\n    }\r\n\r\n    function updateTimestampOffset(MSETimeOffset) {\r\n        if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\r\n            waitForUpdateEnd(buffer, () => {\r\n                buffer.timestampOffset = MSETimeOffset;\r\n            });\r\n        }\r\n    }\r\n\r\n    function remove(start, end, forceRemoval) {\r\n        const sourceBufferSink = this;\r\n        // make sure that the given time range is correct. Otherwise we will get InvalidAccessError\r\n        waitForUpdateEnd(buffer, function () {\r\n            try {\r\n                if ((start >= 0) && (end > start) && (forceRemoval || mediaSource.readyState !== 'ended')) {\r\n                    buffer.remove(start, end);\r\n                }\r\n                // updating is in progress, we should wait for it to complete before signaling that this operation is done\r\n                waitForUpdateEnd(buffer, function () {\r\n                    eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\r\n                        buffer: sourceBufferSink,\r\n                        from: start,\r\n                        to: end,\r\n                        unintended: false\r\n                    });\r\n                });\r\n            } catch (err) {\r\n                eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\r\n                    buffer: sourceBufferSink,\r\n                    from: start,\r\n                    to: end,\r\n                    unintended: false,\r\n                    error: new DashJSError(err.code, err.message)\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    function appendNextInQueue() {\r\n        const sourceBufferSink = this;\r\n\r\n        if (appendQueue.length > 0) {\r\n            isAppendingInProgress = true;\r\n            const nextChunk = appendQueue[0];\r\n            appendQueue.splice(0,1);\r\n            let oldRanges = [];\r\n            const afterSuccess = function () {\r\n                // Safari sometimes drops a portion of a buffer after appending. Handle these situations here\r\n                const newRanges = getAllBufferRanges();\r\n                checkBufferGapsAfterAppend(sourceBufferSink, oldRanges, newRanges, nextChunk);\r\n                if (appendQueue.length > 0) {\r\n                    appendNextInQueue.call(this);\r\n                } else {\r\n                    isAppendingInProgress = false;\r\n                    if (onAppended) {\r\n                        onAppended({\r\n                            chunk: nextChunk\r\n                        });\r\n                    }\r\n                }\r\n            };\r\n\r\n            try {\r\n                if (nextChunk.bytes.length === 0) {\r\n                    afterSuccess.call(this);\r\n                } else {\r\n                    oldRanges = getAllBufferRanges();\r\n                    if (buffer.appendBuffer) {\r\n                        buffer.appendBuffer(nextChunk.bytes);\r\n                    } else {\r\n                        buffer.append(nextChunk.bytes, nextChunk);\r\n                    }\r\n                    // updating is in progress, we should wait for it to complete before signaling that this operation is done\r\n                    waitForUpdateEnd(buffer, afterSuccess.bind(this));\r\n                }\r\n            } catch (err) {\r\n                logger.fatal('SourceBuffer append failed \"' + err + '\"');\r\n                if (appendQueue.length > 0) {\r\n                    appendNextInQueue();\r\n                } else {\r\n                    isAppendingInProgress = false;\r\n                }\r\n\r\n                if (onAppended) {\r\n                    onAppended({\r\n                        chunk: nextChunk,\r\n                        error: new DashJSError(err.code, err.message)\r\n                    });\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function checkBufferGapsAfterAppend(buffer, oldRanges, newRanges, chunk) {\r\n        if (oldRanges && oldRanges.length > 0 && oldRanges.length < newRanges.length &&\r\n            isChunkAlignedWithRange(oldRanges, chunk)) {\r\n            // A split in the range was created while appending\r\n            eventBus.trigger(Events.SOURCEBUFFER_REMOVE_COMPLETED, {\r\n                buffer: buffer,\r\n                from: newRanges.end(newRanges.length - 2),\r\n                to: newRanges.start(newRanges.length - 1),\r\n                unintended: true\r\n            });\r\n        }\r\n    }\r\n\r\n    function isChunkAlignedWithRange(oldRanges, chunk) {\r\n        for (let i = 0; i < oldRanges.length; i++ ) {\r\n            const start = Math.round(oldRanges.start(i));\r\n            const end = Math.round(oldRanges.end(i));\r\n            if (end === chunk.start || start === chunk.end || (chunk.start >= start && chunk.end <= end) ) {\r\n                return true;\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function abort() {\r\n        try {\r\n            if (mediaSource.readyState === 'open') {\r\n                buffer.abort();\r\n            } else if (buffer.setTextTrack && mediaSource.readyState === 'ended') {\r\n                buffer.abort(); //The cues need to be removed from the TextSourceBuffer via a call to abort()\r\n            }\r\n        } catch (ex) {\r\n            logger.error('SourceBuffer append abort failed: \"' + ex + '\"');\r\n        }\r\n        appendQueue = [];\r\n    }\r\n\r\n    function executeCallback() {\r\n        if (callbacks.length > 0) {\r\n            const cb = callbacks.shift();\r\n            if (buffer.updating) {\r\n                waitForUpdateEnd(buffer, cb);\r\n            } else {\r\n                cb();\r\n                // Try to execute next callback if still not updating\r\n                executeCallback();\r\n            }\r\n        }\r\n    }\r\n\r\n    function checkIsUpdateEnded() {\r\n        // if updating is still in progress do nothing and wait for the next check again.\r\n        if (buffer.updating) return;\r\n        // updating is completed, now we can stop checking and resolve the promise\r\n        executeCallback();\r\n    }\r\n\r\n    function updateEndHandler() {\r\n        if (buffer.updating) return;\r\n\r\n        executeCallback();\r\n    }\r\n\r\n    function errHandler() {\r\n        logger.error('SourceBufferSink error', mediaInfo.type);\r\n    }\r\n\r\n    function waitForUpdateEnd(buffer, callback) {\r\n        callbacks.push(callback);\r\n\r\n        if (!buffer.updating) {\r\n            executeCallback();\r\n        }\r\n    }\r\n\r\n    instance = {\r\n        getAllBufferRanges: getAllBufferRanges,\r\n        getBuffer: getBuffer,\r\n        append: append,\r\n        remove: remove,\r\n        abort: abort,\r\n        reset: reset,\r\n        updateTimestampOffset: updateTimestampOffset,\r\n        hasDiscontinuitiesAfter: hasDiscontinuitiesAfter\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nSourceBufferSink.__dashjs_factory_name = 'SourceBufferSink';\r\nconst factory = FactoryMaker.getClassFactory(SourceBufferSink);\r\nexport default factory;\r\n"]}