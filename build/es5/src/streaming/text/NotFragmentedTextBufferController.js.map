{"version":3,"sources":["../../../../../src/streaming/text/NotFragmentedTextBufferController.js"],"names":["Constants","EventBus","Events","FactoryMaker","InitCache","SourceBufferSink","TextController","DashJSError","Errors","BUFFER_CONTROLLER_TYPE","NotFragmentedTextBufferController","config","context","eventBus","getInstance","textController","errHandler","type","mimeType","streamProcessor","instance","isBufferingCompleted","initialized","mediaSource","buffer","initCache","setup","on","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","INIT_FRAGMENT_LOADED","onInitFragmentLoaded","getBufferControllerType","initialize","source","setMediaSource","createBuffer","mediaInfo","create","textBuffer","getBuffer","hasOwnProperty","INITIALIZE","e","isText","codec","indexOf","getTextSourceBuffer","mediaSourceError","error","MEDIASOURCE_TYPE_UNSUPPORTED_CODE","MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE","message","getType","value","getMediaSource","getStreamProcessor","getIsPruningInProgress","dischargePreBuffer","setSeekStartTime","getBufferLevel","getIsBufferingCompleted","reset","errored","off","abort","sender","chunk","extract","getStreamInfo","id","getCurrentRepresentation","trigger","TIMED_TEXT_REQUESTED","index","fragmentModel","getFragmentModel","bytes","save","append","STREAM_COMPLETED","request","switchInitData","streamId","representationId","getRangeAt","updateTimestampOffset","MSETimeOffset","timestampOffset","isNaN","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"NotFragmentedTextBufferController.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport Constants from '../constants/Constants';\r\nimport EventBus from '../../core/EventBus';\r\nimport Events from '../../core/events/Events';\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport InitCache from '../utils/InitCache';\r\nimport SourceBufferSink from '../SourceBufferSink';\r\nimport TextController from '../../streaming/text/TextController';\r\nimport DashJSError from '../../streaming/vo/DashJSError';\r\nimport Errors from '../../core/errors/Errors';\r\n\r\nconst BUFFER_CONTROLLER_TYPE = 'NotFragmentedTextBufferController';\r\nfunction NotFragmentedTextBufferController(config) {\r\n\r\n    config = config || {};\r\n    let context = this.context;\r\n    let eventBus = EventBus(context).getInstance();\r\n    const textController = TextController(context).getInstance();\r\n\r\n    let errHandler = config.errHandler;\r\n    let type = config.type;\r\n    let mimeType = config.mimeType;\r\n    let streamProcessor = config.streamProcessor;\r\n\r\n    let instance,\r\n        isBufferingCompleted,\r\n        initialized,\r\n        mediaSource,\r\n        buffer,\r\n        initCache;\r\n\r\n    function setup() {\r\n        initialized = false;\r\n        mediaSource = null;\r\n        isBufferingCompleted = false;\r\n\r\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\r\n        eventBus.on(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\r\n    }\r\n\r\n    function getBufferControllerType() {\r\n        return BUFFER_CONTROLLER_TYPE;\r\n    }\r\n\r\n    function initialize(source) {\r\n        setMediaSource(source);\r\n        initCache = InitCache(context).getInstance();\r\n    }\r\n\r\n    /**\r\n     * @param {MediaInfo }mediaInfo\r\n     * @memberof BufferController#\r\n     */\r\n    function createBuffer(mediaInfo) {\r\n        try {\r\n            buffer = SourceBufferSink(context).create(mediaSource, mediaInfo);\r\n            if (!initialized) {\r\n                const textBuffer = buffer.getBuffer();\r\n                if (textBuffer.hasOwnProperty(Constants.INITIALIZE)) {\r\n                    textBuffer.initialize(mimeType, streamProcessor);\r\n                }\r\n                initialized = true;\r\n            }\r\n            return buffer;\r\n        } catch (e) {\r\n            if ((mediaInfo.isText) || (mediaInfo.codec.indexOf('codecs=\"stpp') !== -1) || (mediaInfo.codec.indexOf('codecs=\"wvtt') !== -1)) {\r\n                try {\r\n                    buffer = textController.getTextSourceBuffer();\r\n                } catch (e) {\r\n                    errHandler.mediaSourceError('Error creating ' + type + ' source buffer.');\r\n                    errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type + ' : ' + e.message));\r\n                }\r\n            } else {\r\n                errHandler.mediaSourceError('Error creating ' + type + ' source buffer.');\r\n                errHandler.error(new DashJSError(Errors.MEDIASOURCE_TYPE_UNSUPPORTED_CODE, Errors.MEDIASOURCE_TYPE_UNSUPPORTED_MESSAGE + type));\r\n            }\r\n        }\r\n    }\r\n\r\n    function getType() {\r\n        return type;\r\n    }\r\n\r\n    function getBuffer() {\r\n        return buffer;\r\n    }\r\n\r\n    function setMediaSource(value) {\r\n        mediaSource = value;\r\n    }\r\n\r\n    function getMediaSource() {\r\n        return mediaSource;\r\n    }\r\n\r\n    function getStreamProcessor() {\r\n        return streamProcessor;\r\n    }\r\n\r\n    function getIsPruningInProgress() {\r\n        return false;\r\n    }\r\n\r\n    function dischargePreBuffer() {\r\n    }\r\n\r\n    function setSeekStartTime() { //Unused - TODO Remove need for stub function\r\n    }\r\n\r\n    function getBufferLevel() {\r\n        return 0;\r\n    }\r\n\r\n    function getIsBufferingCompleted() {\r\n        return isBufferingCompleted;\r\n    }\r\n\r\n    function reset(errored) {\r\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\r\n        eventBus.off(Events.INIT_FRAGMENT_LOADED, onInitFragmentLoaded, instance);\r\n\r\n        if (!errored && buffer) {\r\n            buffer.abort();\r\n            buffer.reset();\r\n            buffer = null;\r\n        }\r\n    }\r\n\r\n    function onDataUpdateCompleted(e) {\r\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\r\n            return;\r\n        }\r\n\r\n        const chunk = initCache.extract(streamProcessor.getStreamInfo().id, e.sender.getCurrentRepresentation().id);\r\n\r\n        if (!chunk) {\r\n            eventBus.trigger(Events.TIMED_TEXT_REQUESTED, {\r\n                index: 0,\r\n                sender: e.sender\r\n            }); //TODO make index dynamic if referring to MP?\r\n        }\r\n    }\r\n\r\n    function onInitFragmentLoaded(e) {\r\n        if (e.fragmentModel !== streamProcessor.getFragmentModel() || (!e.chunk.bytes)) {\r\n            return;\r\n        }\r\n\r\n        initCache.save(e.chunk);\r\n        buffer.append(e.chunk);\r\n\r\n        eventBus.trigger(Events.STREAM_COMPLETED, {\r\n            request: e.request,\r\n            fragmentModel: e.fragmentModel\r\n        });\r\n    }\r\n\r\n    function switchInitData(streamId, representationId) {\r\n        const chunk = initCache.extract(streamId, representationId);\r\n\r\n        if (!chunk) {\r\n            eventBus.trigger(Events.TIMED_TEXT_REQUESTED, {\r\n                index: 0,\r\n                sender: instance\r\n            });\r\n        }\r\n    }\r\n\r\n    function getRangeAt() {\r\n        return null;\r\n    }\r\n\r\n    function updateTimestampOffset(MSETimeOffset) {\r\n        if (buffer.timestampOffset !== MSETimeOffset && !isNaN(MSETimeOffset)) {\r\n            buffer.timestampOffset = MSETimeOffset;\r\n        }\r\n    }\r\n\r\n    instance = {\r\n        getBufferControllerType: getBufferControllerType,\r\n        initialize: initialize,\r\n        createBuffer: createBuffer,\r\n        getType: getType,\r\n        getStreamProcessor: getStreamProcessor,\r\n        setSeekStartTime: setSeekStartTime,\r\n        getBuffer: getBuffer,\r\n        getBufferLevel: getBufferLevel,\r\n        setMediaSource: setMediaSource,\r\n        getMediaSource: getMediaSource,\r\n        getIsBufferingCompleted: getIsBufferingCompleted,\r\n        getIsPruningInProgress: getIsPruningInProgress,\r\n        dischargePreBuffer: dischargePreBuffer,\r\n        switchInitData: switchInitData,\r\n        getRangeAt: getRangeAt,\r\n        reset: reset,\r\n        updateTimestampOffset: updateTimestampOffset\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nNotFragmentedTextBufferController.__dashjs_factory_name = BUFFER_CONTROLLER_TYPE;\r\nexport default FactoryMaker.getClassFactory(NotFragmentedTextBufferController);\r\n"]}