{"version":3,"sources":["../../../../../../src/streaming/protection/models/ProtectionModel_01b.js"],"names":["ProtectionKeyController","NeedKey","DashJSError","KeyMessage","KeySystemConfiguration","KeySystemAccess","ProtectionErrors","ProtectionModel_01b","config","context","eventBus","events","debug","api","errHandler","instance","logger","videoElement","keySystem","protectionKeyController","pendingSessions","sessions","moreSessionsAllowed","eventHandler","setup","getLogger","getInstance","createEventHandler","reset","removeEventListeners","i","length","closeKeySession","trigger","TEARDOWN_COMPLETE","getKeySystem","getAllInitData","retVal","push","initData","requestKeySystemAccess","ksConfigurations","ve","document","createElement","found","ksIdx","systemString","ks","configs","supportedAudio","supportedVideo","configIdx","videos","videoCapabilities","videoIdx","canPlayType","contentType","ksConfig","getKeySystemBySystemString","KEY_SYSTEM_ACCESS_COMPLETE","data","error","selectKeySystem","keySystemAccess","INTERNAL_KEY_SYSTEM_SELECTED","setMediaElement","mediaElement","addEventListener","keyerror","needkey","keymessage","keyadded","VIDEO_ELEMENT_SELECTED","createKeySession","Error","newSession","sessionID","getSessionID","getExpirationTime","NaN","getSessionType","generateKeyRequest","Uint8Array","updateKeySession","sessionToken","message","isClearKey","addKey","keyPairs","key","keyID","cancelKeyRequest","KEY_SESSION_CLOSED","setServerCertificate","loadKeySession","removeKeySession","handleEvent","event","type","ArrayBuffer","isView","buffer","NEED_KEY","findSessionByID","sessionId","code","MEDIA_KEYERR_CODE","msg","errorCode","MEDIA_KEYERR_UNKNOWN_CODE","MEDIA_KEYERR_UNKNOWN_MESSAGE","MEDIA_KEYERR_CLIENT_CODE","MEDIA_KEYERR_CLIENT_MESSAGE","MEDIA_KEYERR_SERVICE_CODE","MEDIA_KEYERR_SERVICE_MESSAGE","MEDIA_KEYERR_OUTPUT_CODE","MEDIA_KEYERR_OUTPUT_MESSAGE","MEDIA_KEYERR_HARDWARECHANGE_CODE","MEDIA_KEYERR_HARDWARECHANGE_MESSAGE","MEDIA_KEYERR_DOMAIN_CODE","MEDIA_KEYERR_DOMAIN_MESSAGE","systemCode","KEY_ERROR","KEY_ADDED","undefined","shift","KEY_SESSION_CREATED","mediaKeyMessageError","MEDIA_KEY_MESSAGE_ERROR_MESSAGE","MEDIA_KEY_MESSAGE_ERROR_CODE","keyMessage","INTERNAL_KEY_MESSAGE","defaultURL","warn","sessionArray","len","removeEventListener","stop","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"ProtectionModel_01b.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n/**\r\n * Initial implementation of EME\r\n *\r\n * Implemented by Google Chrome prior to v36\r\n *\r\n * @implements ProtectionModel\r\n * @class\r\n */\r\nimport ProtectionKeyController from '../controllers/ProtectionKeyController';\r\nimport NeedKey from '../vo/NeedKey';\r\nimport DashJSError from '../../vo/DashJSError';\r\nimport KeyMessage from '../vo/KeyMessage';\r\nimport KeySystemConfiguration from '../vo/KeySystemConfiguration';\r\nimport KeySystemAccess from '../vo/KeySystemAccess';\r\nimport ProtectionErrors from '../errors/ProtectionErrors';\r\n\r\nfunction ProtectionModel_01b(config) {\r\n\r\n    config = config || {};\r\n    const context = this.context;\r\n    const eventBus = config.eventBus;//Need to pass in here so we can use same instance since this is optional module\r\n    const events = config.events;\r\n    const debug = config.debug;\r\n    const api = config.api;\r\n    const errHandler = config.errHandler;\r\n\r\n    let instance,\r\n        logger,\r\n        videoElement,\r\n        keySystem,\r\n        protectionKeyController,\r\n\r\n        // With this version of the EME APIs, sessionIDs are not assigned to\r\n        // sessions until the first key message is received.  We are assuming\r\n        // that in the case of multiple sessions, key messages will be received\r\n        // in the order that generateKeyRequest() is called.\r\n        // Holding spot for newly-created sessions until we determine whether or\r\n        // not the CDM supports sessionIDs\r\n        pendingSessions,\r\n\r\n        // List of sessions that have been initialized.  Only the first position will\r\n        // be used in the case that the CDM does not support sessionIDs\r\n        sessions,\r\n\r\n        // Not all CDMs support the notion of sessionIDs.  Without sessionIDs\r\n        // there is no way for us to differentiate between sessions, therefore\r\n        // we must only allow a single session.  Once we receive the first key\r\n        // message we can set this flag to determine if more sessions are allowed\r\n        moreSessionsAllowed,\r\n\r\n        // This is our main event handler for all desired HTMLMediaElement events\r\n        // related to EME.  These events are translated into our API-independent\r\n        // versions of the same events\r\n        eventHandler;\r\n\r\n    function setup() {\r\n        logger = debug.getLogger(instance);\r\n        videoElement = null;\r\n        keySystem = null;\r\n        pendingSessions = [];\r\n        sessions = [];\r\n        protectionKeyController = ProtectionKeyController(context).getInstance();\r\n        eventHandler = createEventHandler();\r\n    }\r\n\r\n    function reset() {\r\n        if (videoElement) {\r\n            removeEventListeners();\r\n        }\r\n        for (let i = 0; i < sessions.length; i++) {\r\n            closeKeySession(sessions[i]);\r\n        }\r\n        eventBus.trigger(events.TEARDOWN_COMPLETE);\r\n    }\r\n\r\n    function getKeySystem() {\r\n        return keySystem;\r\n    }\r\n\r\n    function getAllInitData() {\r\n        const retVal = [];\r\n        for (let i = 0; i < pendingSessions.length; i++) {\r\n            retVal.push(pendingSessions[i].initData);\r\n        }\r\n        for (let i = 0; i < sessions.length; i++) {\r\n            retVal.push(sessions[i].initData);\r\n        }\r\n        return retVal;\r\n    }\r\n\r\n    function requestKeySystemAccess(ksConfigurations) {\r\n        let ve = videoElement;\r\n        if (!ve) { // Must have a video element to do this capability tests\r\n            ve = document.createElement('video');\r\n        }\r\n\r\n        // Try key systems in order, first one with supported key system configuration\r\n        // is used\r\n        let found = false;\r\n        for (let ksIdx = 0; ksIdx < ksConfigurations.length; ksIdx++) {\r\n            const systemString = ksConfigurations[ksIdx].ks.systemString;\r\n            const configs = ksConfigurations[ksIdx].configs;\r\n            let supportedAudio = null;\r\n            let supportedVideo = null;\r\n\r\n            // Try key system configs in order, first one with supported audio/video\r\n            // is used\r\n            for (let configIdx = 0; configIdx < configs.length; configIdx++) {\r\n                //let audios = configs[configIdx].audioCapabilities;\r\n                const videos = configs[configIdx].videoCapabilities;\r\n                // Look for supported video container/codecs\r\n                if (videos && videos.length !== 0) {\r\n                    supportedVideo = []; // Indicates that we have a requested video config\r\n                    for (let videoIdx = 0; videoIdx < videos.length; videoIdx++) {\r\n                        if (ve.canPlayType(videos[videoIdx].contentType, systemString) !== '') {\r\n                            supportedVideo.push(videos[videoIdx]);\r\n                        }\r\n                    }\r\n                }\r\n\r\n                // No supported audio or video in this configuration OR we have\r\n                // requested audio or video configuration that is not supported\r\n                if ((!supportedAudio && !supportedVideo) ||\r\n                    (supportedAudio && supportedAudio.length === 0) ||\r\n                    (supportedVideo && supportedVideo.length === 0)) {\r\n                    continue;\r\n                }\r\n\r\n                // This configuration is supported\r\n                found = true;\r\n                const ksConfig = new KeySystemConfiguration(supportedAudio, supportedVideo);\r\n                const ks = protectionKeyController.getKeySystemBySystemString(systemString);\r\n                eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, { data: new KeySystemAccess(ks, ksConfig) });\r\n                break;\r\n            }\r\n        }\r\n        if (!found) {\r\n            eventBus.trigger(events.KEY_SYSTEM_ACCESS_COMPLETE, {error: 'Key system access denied! -- No valid audio/video content configurations detected!'});\r\n        }\r\n    }\r\n\r\n    function selectKeySystem(keySystemAccess) {\r\n        keySystem = keySystemAccess.keySystem;\r\n        eventBus.trigger(events.INTERNAL_KEY_SYSTEM_SELECTED);\r\n    }\r\n\r\n    function setMediaElement(mediaElement) {\r\n        if (videoElement === mediaElement) {\r\n            return;\r\n        }\r\n\r\n        // Replacing the previous element\r\n        if (videoElement) {\r\n            removeEventListeners();\r\n\r\n            // Close any open sessions - avoids memory leak on LG webOS 2016/2017 TVs\r\n            for (var i = 0; i < sessions.length; i++) {\r\n                closeKeySession(sessions[i]);\r\n            }\r\n            sessions = [];\r\n        }\r\n\r\n        videoElement = mediaElement;\r\n\r\n        // Only if we are not detaching from the existing element\r\n        if (videoElement) {\r\n            videoElement.addEventListener(api.keyerror, eventHandler);\r\n            videoElement.addEventListener(api.needkey, eventHandler);\r\n            videoElement.addEventListener(api.keymessage, eventHandler);\r\n            videoElement.addEventListener(api.keyadded, eventHandler);\r\n            eventBus.trigger(events.VIDEO_ELEMENT_SELECTED);\r\n        }\r\n    }\r\n\r\n    function createKeySession(initData /*, protData, keySystemType */) {\r\n        if (!keySystem) {\r\n            throw new Error('Can not create sessions until you have selected a key system');\r\n        }\r\n\r\n        // Determine if creating a new session is allowed\r\n        if (moreSessionsAllowed || sessions.length === 0) {\r\n            const newSession = { // Implements SessionToken\r\n                sessionID: null,\r\n                initData: initData,\r\n                getSessionID: function () {\r\n                    return this.sessionID;\r\n                },\r\n\r\n                getExpirationTime: function () {\r\n                    return NaN;\r\n                },\r\n\r\n                getSessionType: function () {\r\n                    return 'temporary';\r\n                }\r\n            };\r\n            pendingSessions.push(newSession);\r\n\r\n            // Send our request to the CDM\r\n            videoElement[api.generateKeyRequest](keySystem.systemString, new Uint8Array(initData));\r\n\r\n            return newSession;\r\n\r\n        } else {\r\n            throw new Error('Multiple sessions not allowed!');\r\n        }\r\n\r\n    }\r\n\r\n    function updateKeySession(sessionToken, message) {\r\n        const sessionID = sessionToken.sessionID;\r\n        if (!protectionKeyController.isClearKey(keySystem)) {\r\n            // Send our request to the CDM\r\n            videoElement[api.addKey](keySystem.systemString,\r\n                new Uint8Array(message), new Uint8Array(sessionToken.initData), sessionID);\r\n        } else {\r\n            // For clearkey, message is a ClearKeyKeySet\r\n            for (let i = 0; i < message.keyPairs.length; i++) {\r\n                videoElement[api.addKey](keySystem.systemString,\r\n                    message.keyPairs[i].key, message.keyPairs[i].keyID, sessionID);\r\n            }\r\n        }\r\n    }\r\n\r\n    function closeKeySession(sessionToken) {\r\n        // Send our request to the CDM\r\n        try {\r\n            videoElement[api.cancelKeyRequest](keySystem.systemString, sessionToken.sessionID);\r\n        } catch (error) {\r\n            eventBus.trigger(events.KEY_SESSION_CLOSED, {data: null, error: 'Error closing session (' + sessionToken.sessionID + ') ' + error.message});\r\n        }\r\n    }\r\n\r\n    function setServerCertificate(/*serverCertificate*/) { /* Not supported */ }\r\n    function loadKeySession(/*sessionID*/) { /* Not supported */ }\r\n    function removeKeySession(/*sessionToken*/) { /* Not supported */ }\r\n\r\n    function createEventHandler() {\r\n        return {\r\n            handleEvent: function (event) {\r\n                let sessionToken = null;\r\n                switch (event.type) {\r\n                    case api.needkey:\r\n                        let initData = ArrayBuffer.isView(event.initData) ? event.initData.buffer : event.initData;\r\n                        eventBus.trigger(events.NEED_KEY, {key: new NeedKey(initData, 'cenc')});\r\n                        break;\r\n\r\n                    case api.keyerror:\r\n                        sessionToken = findSessionByID(sessions, event.sessionId);\r\n                        if (!sessionToken) {\r\n                            sessionToken = findSessionByID(pendingSessions, event.sessionId);\r\n                        }\r\n\r\n                        if (sessionToken) {\r\n                            let code = ProtectionErrors.MEDIA_KEYERR_CODE;\r\n                            let msg = '';\r\n                            switch (event.errorCode.code) {\r\n                                case 1:\r\n                                    code = ProtectionErrors.MEDIA_KEYERR_UNKNOWN_CODE;\r\n                                    msg += 'MEDIA_KEYERR_UNKNOWN - ' + ProtectionErrors.MEDIA_KEYERR_UNKNOWN_MESSAGE;\r\n                                    break;\r\n                                case 2:\r\n                                    code = ProtectionErrors.MEDIA_KEYERR_CLIENT_CODE;\r\n                                    msg += 'MEDIA_KEYERR_CLIENT - ' + ProtectionErrors.MEDIA_KEYERR_CLIENT_MESSAGE;\r\n                                    break;\r\n                                case 3:\r\n                                    code = ProtectionErrors.MEDIA_KEYERR_SERVICE_CODE;\r\n                                    msg += 'MEDIA_KEYERR_SERVICE - ' + ProtectionErrors.MEDIA_KEYERR_SERVICE_MESSAGE;\r\n                                    break;\r\n                                case 4:\r\n                                    code = ProtectionErrors.MEDIA_KEYERR_OUTPUT_CODE;\r\n                                    msg += 'MEDIA_KEYERR_OUTPUT - ' + ProtectionErrors.MEDIA_KEYERR_OUTPUT_MESSAGE;\r\n                                    break;\r\n                                case 5:\r\n                                    code = ProtectionErrors.MEDIA_KEYERR_HARDWARECHANGE_CODE;\r\n                                    msg += 'MEDIA_KEYERR_HARDWARECHANGE - ' + ProtectionErrors.MEDIA_KEYERR_HARDWARECHANGE_MESSAGE;\r\n                                    break;\r\n                                case 6:\r\n                                    code = ProtectionErrors.MEDIA_KEYERR_DOMAIN_CODE;\r\n                                    msg += 'MEDIA_KEYERR_DOMAIN - ' + ProtectionErrors.MEDIA_KEYERR_DOMAIN_MESSAGE;\r\n                                    break;\r\n                            }\r\n                            msg += '  System Code = ' + event.systemCode;\r\n                            // TODO: Build error string based on key error\r\n                            eventBus.trigger(events.KEY_ERROR, {data: new DashJSError(code, msg, sessionToken)});\r\n                        } else {\r\n                            logger.error('No session token found for key error');\r\n                        }\r\n                        break;\r\n\r\n                    case api.keyadded:\r\n                        sessionToken = findSessionByID(sessions, event.sessionId);\r\n                        if (!sessionToken) {\r\n                            sessionToken = findSessionByID(pendingSessions, event.sessionId);\r\n                        }\r\n\r\n                        if (sessionToken) {\r\n                            logger.debug('DRM: Key added.');\r\n                            eventBus.trigger(events.KEY_ADDED, {data: sessionToken});//TODO not sure anything is using sessionToken? why there?\r\n                        } else {\r\n                            logger.debug('No session token found for key added');\r\n                        }\r\n                        break;\r\n\r\n                    case api.keymessage:\r\n                        // If this CDM does not support session IDs, we will be limited\r\n                        // to a single session\r\n                        moreSessionsAllowed = (event.sessionId !== null) && (event.sessionId !== undefined);\r\n\r\n                        // SessionIDs supported\r\n                        if (moreSessionsAllowed) {\r\n                            // Attempt to find an uninitialized token with this sessionID\r\n                            sessionToken = findSessionByID(sessions, event.sessionId);\r\n                            if (!sessionToken && pendingSessions.length > 0) {\r\n\r\n                                // This is the first message for our latest session, so set the\r\n                                // sessionID and add it to our list\r\n                                sessionToken = pendingSessions.shift();\r\n                                sessions.push(sessionToken);\r\n                                sessionToken.sessionID = event.sessionId;\r\n\r\n                                eventBus.trigger(events.KEY_SESSION_CREATED, {data: sessionToken});\r\n                            }\r\n                        } else if (pendingSessions.length > 0) { // SessionIDs not supported\r\n                            sessionToken = pendingSessions.shift();\r\n                            sessions.push(sessionToken);\r\n\r\n                            if (pendingSessions.length !== 0) {\r\n                                errHandler.mediaKeyMessageError(ProtectionErrors.MEDIA_KEY_MESSAGE_ERROR_MESSAGE);\r\n                                errHandler.error(new DashJSError(ProtectionErrors.MEDIA_KEY_MESSAGE_ERROR_CODE, ProtectionErrors.MEDIA_KEY_MESSAGE_ERROR_MESSAGE));\r\n                            }\r\n                        }\r\n\r\n                        if (sessionToken) {\r\n                            let message = ArrayBuffer.isView(event.message) ? event.message.buffer : event.message;\r\n\r\n                            // For ClearKey, the spec mandates that you pass this message to the\r\n                            // addKey method, so we always save it to the token since there is no\r\n                            // way to tell which key system is in use\r\n                            sessionToken.keyMessage = message;\r\n                            eventBus.trigger(events.INTERNAL_KEY_MESSAGE, {data: new KeyMessage(sessionToken, message, event.defaultURL)});\r\n\r\n                        } else {\r\n                            logger.warn('No session token found for key message');\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n        };\r\n    }\r\n\r\n\r\n    /**\r\n     * Helper function to retrieve the stored session token based on a given\r\n     * sessionID value\r\n     *\r\n     * @param {Array} sessionArray - the array of sessions to search\r\n     * @param {*} sessionID - the sessionID to search for\r\n     * @returns {*} the session token with the given sessionID\r\n     */\r\n    function findSessionByID(sessionArray, sessionID) {\r\n        if (!sessionID || !sessionArray) {\r\n            return null;\r\n        } else {\r\n            const len = sessionArray.length;\r\n            for (let i = 0; i < len; i++) {\r\n                if (sessionArray[i].sessionID == sessionID) {\r\n                    return sessionArray[i];\r\n                }\r\n            }\r\n            return null;\r\n        }\r\n    }\r\n\r\n    function removeEventListeners() {\r\n        videoElement.removeEventListener(api.keyerror, eventHandler);\r\n        videoElement.removeEventListener(api.needkey, eventHandler);\r\n        videoElement.removeEventListener(api.keymessage, eventHandler);\r\n        videoElement.removeEventListener(api.keyadded, eventHandler);\r\n    }\r\n\r\n    instance = {\r\n        getAllInitData: getAllInitData,\r\n        requestKeySystemAccess: requestKeySystemAccess,\r\n        getKeySystem: getKeySystem,\r\n        selectKeySystem: selectKeySystem,\r\n        setMediaElement: setMediaElement,\r\n        createKeySession: createKeySession,\r\n        updateKeySession: updateKeySession,\r\n        closeKeySession: closeKeySession,\r\n        setServerCertificate: setServerCertificate,\r\n        loadKeySession: loadKeySession,\r\n        removeKeySession: removeKeySession,\r\n        stop: reset,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nProtectionModel_01b.__dashjs_factory_name = 'ProtectionModel_01b';\r\nexport default dashjs.FactoryMaker.getClassFactory(ProtectionModel_01b); /* jshint ignore:line */\r\n"]}