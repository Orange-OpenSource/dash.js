{"version":3,"sources":["../../../../../src/streaming/utils/BoxParser.js"],"names":["Debug","IsoFile","FactoryMaker","ISOBoxer","IsoBoxSearchInfo","BoxParser","logger","instance","context","setup","getInstance","getLogger","parse","data","fileStart","undefined","parsedFile","parseBuffer","dashIsoFile","create","setData","findLastTopIsoBoxCompleted","types","buffer","offset","byteLength","ArrayBuffer","Uint8Array","boxInfo","lastCompletedOffset","boxSize","parseUint32","boxType","parseIsoBoxType","indexOf","getSamplesInfo","ab","sampleList","lastSequenceNumber","NaN","totalDuration","numSequences","isoFile","moofBoxes","getBoxes","mfhdBoxes","sampleDuration","sampleCompositionTimeOffset","sampleCount","sampleSize","sampleDts","sample","i","j","k","l","m","n","dataOffset","length","sequence_number","subsIndex","nextSubsSample","moofBox","trafBoxes","getChildBoxes","trafBox","tfhdBox","getChildBox","tfdtBox","baseMediaDecodeTime","trunBoxes","subsBoxes","trunBox","sample_count","base_data_offset","data_offset","samples","sample_duration","default_sample_duration","sample_size","default_sample_size","sample_composition_time_offset","sampleData","subsBox","entry_count","entries","sample_delta","subSizes","entry","subsample_count","push","subsamples","subsample_size","getMediaTimescaleFromMoov","mdhdBox","getBox","timescale","String","fromCharCode","findInitRange","initRange","start","end","ftyp","moov","debug","isComplete","size","__dashjs_factory_name","getSingletonFactory"],"mappings":"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","file":"BoxParser.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nimport Debug from '../../core/Debug';\r\nimport IsoFile from './IsoFile';\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport ISOBoxer from 'codem-isoboxer';\r\n\r\nimport IsoBoxSearchInfo from '../vo/IsoBoxSearchInfo';\r\n\r\nfunction BoxParser(/*config*/) {\r\n\r\n    let logger,\r\n        instance;\r\n    let context = this.context;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n    }\r\n\r\n    /**\r\n     * @param {ArrayBuffer} data\r\n     * @returns {IsoFile|null}\r\n     * @memberof BoxParser#\r\n     */\r\n    function parse(data) {\r\n        if (!data) return null;\r\n\r\n        if (data.fileStart === undefined) {\r\n            data.fileStart = 0;\r\n        }\r\n\r\n        let parsedFile = ISOBoxer.parseBuffer(data);\r\n        let dashIsoFile = IsoFile(context).create();\r\n\r\n        dashIsoFile.setData(parsedFile);\r\n\r\n        return dashIsoFile;\r\n    }\r\n\r\n    /**\r\n     * From the list of type boxes to look for, returns the latest one that is fully completed (header + payload). This\r\n     * method only looks into the list of top boxes and doesn't analyze nested boxes.\r\n     * @param {string[]} types\r\n     * @param {ArrayBuffer|uint8Array} buffer\r\n     * @param {number} offset\r\n     * @returns {IsoBoxSearchInfo}\r\n     * @memberof BoxParser#\r\n     */\r\n    function findLastTopIsoBoxCompleted(types, buffer, offset) {\r\n        if (offset === undefined) {\r\n            offset = 0;\r\n        }\r\n\r\n        // 8 = size (uint32) + type (4 characters)\r\n        if (!buffer || offset + 8 >= buffer.byteLength) {\r\n            return new IsoBoxSearchInfo(0, false);\r\n        }\r\n\r\n        const data = (buffer instanceof ArrayBuffer) ? new Uint8Array(buffer) : buffer;\r\n        let boxInfo;\r\n        let lastCompletedOffset = 0;\r\n        while (offset < data.byteLength) {\r\n            const boxSize = parseUint32(data, offset);\r\n            const boxType = parseIsoBoxType(data, offset + 4);\r\n\r\n            if (boxSize === 0) {\r\n                break;\r\n            }\r\n\r\n            if (offset + boxSize <= data.byteLength) {\r\n                if (types.indexOf(boxType) >= 0) {\r\n                    boxInfo = new IsoBoxSearchInfo(offset, true, boxSize);\r\n                } else {\r\n                    lastCompletedOffset = offset + boxSize;\r\n                }\r\n            }\r\n\r\n            offset += boxSize;\r\n        }\r\n\r\n        if (!boxInfo) {\r\n            return new IsoBoxSearchInfo(lastCompletedOffset, false);\r\n        }\r\n\r\n        return boxInfo;\r\n    }\r\n\r\n    function getSamplesInfo(ab) {\r\n        if (!ab || ab.byteLength === 0) {\r\n            return {sampleList: [], lastSequenceNumber: NaN, totalDuration: NaN, numSequences: NaN};\r\n        }\r\n        let isoFile = parse(ab);\r\n        // zero or more moofs\r\n        let moofBoxes = isoFile.getBoxes('moof');\r\n        // exactly one mfhd per moof\r\n        let mfhdBoxes = isoFile.getBoxes('mfhd');\r\n\r\n        let sampleDuration,\r\n            sampleCompositionTimeOffset,\r\n            sampleCount,\r\n            sampleSize,\r\n            sampleDts,\r\n            sampleList,\r\n            sample,\r\n            i, j, k, l, m, n,\r\n            dataOffset,\r\n            lastSequenceNumber,\r\n            numSequences,\r\n            totalDuration;\r\n\r\n        numSequences = isoFile.getBoxes('moof').length;\r\n        lastSequenceNumber = mfhdBoxes[mfhdBoxes.length - 1].sequence_number;\r\n        sampleCount = 0;\r\n\r\n        sampleList = [];\r\n        let subsIndex = -1;\r\n        let nextSubsSample = -1;\r\n        for (l = 0; l < moofBoxes.length; l++) {\r\n            let moofBox = moofBoxes[l];\r\n            // zero or more trafs per moof\r\n            let trafBoxes = moofBox.getChildBoxes('traf');\r\n            for (j = 0; j < trafBoxes.length; j++) {\r\n                let trafBox = trafBoxes[j];\r\n                // exactly one tfhd per traf\r\n                let tfhdBox = trafBox.getChildBox('tfhd');\r\n                // zero or one tfdt per traf\r\n                let tfdtBox = trafBox.getChildBox('tfdt');\r\n                sampleDts = tfdtBox.baseMediaDecodeTime;\r\n                // zero or more truns per traf\r\n                let trunBoxes = trafBox.getChildBoxes('trun');\r\n                // zero or more subs per traf\r\n                let subsBoxes = trafBox.getChildBoxes('subs');\r\n                for (k = 0; k < trunBoxes.length; k++) {\r\n                    let trunBox = trunBoxes[k];\r\n                    sampleCount = trunBox.sample_count;\r\n                    dataOffset = (tfhdBox.base_data_offset || 0) + (trunBox.data_offset || 0);\r\n\r\n                    for (i = 0; i < sampleCount; i++) {\r\n                        sample = trunBox.samples[i];\r\n                        sampleDuration = (sample.sample_duration !== undefined) ? sample.sample_duration : tfhdBox.default_sample_duration;\r\n                        sampleSize = (sample.sample_size !== undefined) ? sample.sample_size : tfhdBox.default_sample_size;\r\n                        sampleCompositionTimeOffset = (sample.sample_composition_time_offset !== undefined) ? sample.sample_composition_time_offset : 0;\r\n                        let sampleData = {\r\n                            'dts': sampleDts,\r\n                            'cts': (sampleDts + sampleCompositionTimeOffset),\r\n                            'duration': sampleDuration,\r\n                            'offset': moofBox.offset + dataOffset,\r\n                            'size': sampleSize,\r\n                            'subSizes': [sampleSize]\r\n                        };\r\n                        if (subsBoxes) {\r\n                            for (m = 0; m < subsBoxes.length; m++) {\r\n                                let subsBox = subsBoxes[m];\r\n                                if (subsIndex < (subsBox.entry_count - 1) && i > nextSubsSample) {\r\n                                    subsIndex++;\r\n                                    nextSubsSample += subsBox.entries[subsIndex].sample_delta;\r\n                                }\r\n                                if (i == nextSubsSample) {\r\n                                    sampleData.subSizes = [];\r\n                                    let entry = subsBox.entries[subsIndex];\r\n                                    for (n = 0; n < entry.subsample_count; n++) {\r\n                                        sampleData.subSizes.push(entry.subsamples[n].subsample_size);\r\n                                    }\r\n                                }\r\n                            }\r\n                        }\r\n                        sampleList.push(sampleData);\r\n                        dataOffset += sampleSize;\r\n                        sampleDts += sampleDuration;\r\n                    }\r\n                }\r\n                totalDuration = sampleDts - tfdtBox.baseMediaDecodeTime;\r\n            }\r\n        }\r\n        return {sampleList: sampleList, lastSequenceNumber: lastSequenceNumber, totalDuration: totalDuration, numSequences: numSequences};\r\n    }\r\n\r\n    function getMediaTimescaleFromMoov(ab) {\r\n        let isoFile = parse(ab);\r\n        let mdhdBox = isoFile ? isoFile.getBox('mdhd') : undefined;\r\n\r\n        return mdhdBox ? mdhdBox.timescale : NaN;\r\n    }\r\n\r\n    function parseUint32(data, offset) {\r\n        return data[offset + 3] >>> 0 |\r\n            (data[offset + 2] << 8) >>> 0 |\r\n            (data[offset + 1] << 16) >>> 0 |\r\n            (data[offset] << 24) >>> 0;\r\n    }\r\n\r\n    function parseIsoBoxType(data, offset) {\r\n        return String.fromCharCode(data[offset++]) +\r\n            String.fromCharCode(data[offset++]) +\r\n            String.fromCharCode(data[offset++]) +\r\n            String.fromCharCode(data[offset]);\r\n    }\r\n\r\n    function findInitRange(data) {\r\n        let initRange = null;\r\n        let start,\r\n            end;\r\n\r\n        const isoFile = parse(data);\r\n\r\n        if (!isoFile) {\r\n            return initRange;\r\n        }\r\n\r\n        const ftyp = isoFile.getBox('ftyp');\r\n        const moov = isoFile.getBox('moov');\r\n\r\n        logger.debug('Searching for initialization.');\r\n\r\n        if (moov && moov.isComplete) {\r\n            start = ftyp ? ftyp.offset : moov.offset;\r\n            end = moov.offset + moov.size - 1;\r\n            initRange = start + '-' + end;\r\n\r\n            logger.debug('Found the initialization.  Range: ' + initRange);\r\n        }\r\n\r\n        return initRange;\r\n    }\r\n\r\n    instance = {\r\n        parse: parse,\r\n        findLastTopIsoBoxCompleted: findLastTopIsoBoxCompleted,\r\n        getMediaTimescaleFromMoov: getMediaTimescaleFromMoov,\r\n        getSamplesInfo: getSamplesInfo,\r\n        findInitRange: findInitRange\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\nBoxParser.__dashjs_factory_name = 'BoxParser';\r\nexport default FactoryMaker.getSingletonFactory(BoxParser);\r\n"]}