{"version":3,"sources":["../../../../../src/streaming/controllers/TimeSyncController.js"],"names":["HTTP_TIMEOUT_MS","TimeSyncController","context","eventBus","getInstance","urlUtils","instance","logger","offsetToDeviceTimeMs","isSynchronizing","useManifestDateHeaderTimeSource","handlers","metricsModel","dashMetrics","baseURLController","setup","getLogger","initialize","timingSources","useManifestDateHeader","httpHeadHandler","httpHandler","bind","xsdatetimeDecoder","iso8601Decoder","directHandler","notSupportedHandler","getIsSynchronizing","attemptSync","setConfig","config","getOffsetToDeviceTimeMs","getOffsetMs","setIsSynchronizing","value","setOffsetMs","alternateXsdatetimeDecoder","xsdatetimeStr","SECONDS_IN_MIN","MINUTES_IN_HOUR","MILLISECONDS_IN_SECONDS","datetimeRegex","utcDate","timezoneOffset","match","exec","Date","UTC","parseInt","parseFloat","getTime","parsedDate","parse","isNaN","isoStr","rfc1123Decoder","dateStr","url","onSuccessCB","onFailureCB","time","decoder","isHeadRequest","oncomplete","onload","complete","req","XMLHttpRequest","verb","HTTPRequest","HEAD","GET","urls","shift","length","join","result","status","getResponseHeader","response","isRelative","baseUrl","resolve","open","timeout","onloadend","send","checkForDateHeader","metrics","getReadOnlyMetricsFor","Constants","STREAM","dateHeaderValue","getLatestMPDRequestHeaderValueByID","dateHeaderTime","Number","NaN","completeTimeSyncSequence","failed","offset","trigger","Events","TIME_SYNCHRONIZATION_COMPLETED","error","DashJSError","Errors","TIME_SYNC_FAILED_ERROR_CODE","TIME_SYNC_FAILED_ERROR_MESSAGE","calculateTimeOffset","serverTime","deviceTime","sources","sourceIndex","index","source","onComplete","hasOwnProperty","schemeIdUri","info","reset","__dashjs_factory_name","factory","FactoryMaker","getSingletonFactory","updateSingletonFactory"],"mappings":"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","file":"TimeSyncController.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport Constants from '../constants/Constants';\r\nimport DashJSError from './../vo/DashJSError';\r\nimport {HTTPRequest} from './../vo/metrics/HTTPRequest';\r\nimport EventBus from './../../core/EventBus';\r\nimport Events from './../../core/events/Events';\r\nimport Errors from './../../core/errors/Errors';\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport Debug from '../../core/Debug';\r\nimport URLUtils from '../utils/URLUtils';\r\n\r\nconst HTTP_TIMEOUT_MS = 5000;\r\n\r\nfunction TimeSyncController() {\r\n\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n    const urlUtils = URLUtils(context).getInstance();\r\n\r\n    let instance,\r\n        logger,\r\n        offsetToDeviceTimeMs,\r\n        isSynchronizing,\r\n        useManifestDateHeaderTimeSource,\r\n        handlers,\r\n        metricsModel,\r\n        dashMetrics,\r\n        baseURLController;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n    }\r\n\r\n    function initialize(timingSources, useManifestDateHeader) {\r\n        useManifestDateHeaderTimeSource = useManifestDateHeader;\r\n        offsetToDeviceTimeMs = 0;\r\n        isSynchronizing = false;\r\n\r\n        // a list of known schemeIdUris and a method to call with @value\r\n        handlers = {\r\n            'urn:mpeg:dash:utc:http-head:2014':     httpHeadHandler,\r\n            'urn:mpeg:dash:utc:http-xsdate:2014':   httpHandler.bind(null, xsdatetimeDecoder),\r\n            'urn:mpeg:dash:utc:http-iso:2014':      httpHandler.bind(null, iso8601Decoder),\r\n            'urn:mpeg:dash:utc:direct:2014':        directHandler,\r\n\r\n            // some specs referencing early ISO23009-1 drafts incorrectly use\r\n            // 2012 in the URI, rather than 2014. support these for now.\r\n            'urn:mpeg:dash:utc:http-head:2012':     httpHeadHandler,\r\n            'urn:mpeg:dash:utc:http-xsdate:2012':   httpHandler.bind(null, xsdatetimeDecoder),\r\n            'urn:mpeg:dash:utc:http-iso:2012':      httpHandler.bind(null, iso8601Decoder),\r\n            'urn:mpeg:dash:utc:direct:2012':        directHandler,\r\n\r\n            // it isn't clear how the data returned would be formatted, and\r\n            // no public examples available so http-ntp not supported for now.\r\n            // presumably you would do an arraybuffer type xhr and decode the\r\n            // binary data returned but I would want to see a sample first.\r\n            'urn:mpeg:dash:utc:http-ntp:2014':      notSupportedHandler,\r\n\r\n            // not clear how this would be supported in javascript (in browser)\r\n            'urn:mpeg:dash:utc:ntp:2014':           notSupportedHandler,\r\n            'urn:mpeg:dash:utc:sntp:2014':          notSupportedHandler\r\n        };\r\n\r\n        if (!getIsSynchronizing()) {\r\n            attemptSync(timingSources);\r\n        }\r\n    }\r\n\r\n    function setConfig(config) {\r\n        if (!config) return;\r\n\r\n        if (config.metricsModel) {\r\n            metricsModel = config.metricsModel;\r\n        }\r\n\r\n        if (config.dashMetrics) {\r\n            dashMetrics = config.dashMetrics;\r\n        }\r\n\r\n        if (config.baseURLController) {\r\n            baseURLController = config.baseURLController;\r\n        }\r\n    }\r\n\r\n    function getOffsetToDeviceTimeMs() {\r\n        return getOffsetMs();\r\n    }\r\n\r\n    function setIsSynchronizing(value) {\r\n        isSynchronizing = value;\r\n    }\r\n\r\n    function getIsSynchronizing() {\r\n        return isSynchronizing;\r\n    }\r\n\r\n    function setOffsetMs(value) {\r\n        offsetToDeviceTimeMs = value;\r\n    }\r\n\r\n    function getOffsetMs() {\r\n        return offsetToDeviceTimeMs;\r\n    }\r\n\r\n    // takes xsdatetime and returns milliseconds since UNIX epoch\r\n    // may not be necessary as xsdatetime is very similar to ISO 8601\r\n    // which is natively understood by javascript Date parser\r\n    function alternateXsdatetimeDecoder(xsdatetimeStr) {\r\n        // taken from DashParser - should probably refactor both uses\r\n        const SECONDS_IN_MIN = 60;\r\n        const MINUTES_IN_HOUR = 60;\r\n        const MILLISECONDS_IN_SECONDS = 1000;\r\n        let datetimeRegex = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\\.[0-9]*)?)?(?:([+\\-])([0-9]{2})([0-9]{2}))?/;\r\n\r\n        let utcDate,\r\n            timezoneOffset;\r\n\r\n        let match = datetimeRegex.exec(xsdatetimeStr);\r\n\r\n        // If the string does not contain a timezone offset different browsers can interpret it either\r\n        // as UTC or as a local time so we have to parse the string manually to normalize the given date value for\r\n        // all browsers\r\n        utcDate = Date.UTC(\r\n            parseInt(match[1], 10),\r\n            parseInt(match[2], 10) - 1, // months start from zero\r\n            parseInt(match[3], 10),\r\n            parseInt(match[4], 10),\r\n            parseInt(match[5], 10),\r\n            (match[6] && (parseInt(match[6], 10) || 0)),\r\n            (match[7] && parseFloat(match[7]) * MILLISECONDS_IN_SECONDS) || 0\r\n        );\r\n        // If the date has timezone offset take it into account as well\r\n        if (match[9] && match[10]) {\r\n            timezoneOffset = parseInt(match[9], 10) * MINUTES_IN_HOUR + parseInt(match[10], 10);\r\n            utcDate += (match[8] === '+' ? -1 : +1) * timezoneOffset * SECONDS_IN_MIN * MILLISECONDS_IN_SECONDS;\r\n        }\r\n\r\n        return new Date(utcDate).getTime();\r\n    }\r\n\r\n    // try to use the built in parser, since xsdate is a constrained ISO8601\r\n    // which is supported natively by Date.parse. if that fails, try a\r\n    // regex-based version used elsewhere in this application.\r\n    function xsdatetimeDecoder(xsdatetimeStr) {\r\n        let parsedDate = Date.parse(xsdatetimeStr);\r\n\r\n        if (isNaN(parsedDate)) {\r\n            parsedDate = alternateXsdatetimeDecoder(xsdatetimeStr);\r\n        }\r\n\r\n        return parsedDate;\r\n    }\r\n\r\n    // takes ISO 8601 timestamp and returns milliseconds since UNIX epoch\r\n    function iso8601Decoder(isoStr) {\r\n        return Date.parse(isoStr);\r\n    }\r\n\r\n    // takes RFC 1123 timestamp (which is same as ISO8601) and returns\r\n    // milliseconds since UNIX epoch\r\n    function rfc1123Decoder(dateStr) {\r\n        return Date.parse(dateStr);\r\n    }\r\n\r\n    function notSupportedHandler(url, onSuccessCB, onFailureCB) {\r\n        onFailureCB();\r\n    }\r\n\r\n    function directHandler(xsdatetimeStr, onSuccessCB, onFailureCB) {\r\n        let time = xsdatetimeDecoder(xsdatetimeStr);\r\n\r\n        if (!isNaN(time)) {\r\n            onSuccessCB(time);\r\n            return;\r\n        }\r\n\r\n        onFailureCB();\r\n    }\r\n\r\n    function httpHandler(decoder, url, onSuccessCB, onFailureCB, isHeadRequest) {\r\n        let oncomplete,\r\n            onload;\r\n        let complete = false;\r\n        let req = new XMLHttpRequest();\r\n\r\n        let verb = isHeadRequest ? HTTPRequest.HEAD : HTTPRequest.GET;\r\n        let urls = url.match(/\\S+/g);\r\n\r\n        // according to ISO 23009-1, url could be a white-space\r\n        // separated list of URLs. just handle one at a time.\r\n        url = urls.shift();\r\n\r\n        oncomplete = function () {\r\n            if (complete) {\r\n                return;\r\n            }\r\n\r\n            // we only want to pass through here once per xhr,\r\n            // regardless of whether the load was successful.\r\n            complete = true;\r\n\r\n            // if there are more urls to try, call self.\r\n            if (urls.length) {\r\n                httpHandler(decoder, urls.join(' '), onSuccessCB, onFailureCB, isHeadRequest);\r\n            } else {\r\n                onFailureCB();\r\n            }\r\n        };\r\n\r\n        onload = function () {\r\n            let time,\r\n                result;\r\n\r\n            if (req.status === 200) {\r\n                time = isHeadRequest ?\r\n                        req.getResponseHeader('Date') :\r\n                        req.response;\r\n\r\n                result = decoder(time);\r\n\r\n                // decoder returns NaN if non-standard input\r\n                if (!isNaN(result)) {\r\n                    onSuccessCB(result);\r\n                    complete = true;\r\n                }\r\n            }\r\n        };\r\n\r\n        if (urlUtils.isRelative(url)) {\r\n            // passing no path to resolve will return just MPD BaseURL/baseUri\r\n            const baseUrl = baseURLController.resolve();\r\n            if (baseUrl) {\r\n                url = urlUtils.resolve(url, baseUrl.url);\r\n            }\r\n        }\r\n\r\n        req.open(verb, url);\r\n        req.timeout = HTTP_TIMEOUT_MS || 0;\r\n        req.onload = onload;\r\n        req.onloadend = oncomplete;\r\n        req.send();\r\n    }\r\n\r\n    function httpHeadHandler(url, onSuccessCB, onFailureCB) {\r\n        httpHandler(rfc1123Decoder, url, onSuccessCB, onFailureCB, true);\r\n    }\r\n\r\n    function checkForDateHeader() {\r\n        let metrics = metricsModel.getReadOnlyMetricsFor(Constants.STREAM);\r\n        let dateHeaderValue = dashMetrics.getLatestMPDRequestHeaderValueByID(metrics, 'Date');\r\n        let dateHeaderTime = dateHeaderValue !== null ? new Date(dateHeaderValue).getTime() : Number.NaN;\r\n\r\n        if (!isNaN(dateHeaderTime)) {\r\n            setOffsetMs(dateHeaderTime - new Date().getTime());\r\n            completeTimeSyncSequence(false, dateHeaderTime / 1000, offsetToDeviceTimeMs);\r\n        } else {\r\n            completeTimeSyncSequence(true);\r\n        }\r\n    }\r\n\r\n    function completeTimeSyncSequence(failed, time, offset) {\r\n        setIsSynchronizing(false);\r\n        eventBus.trigger(Events.TIME_SYNCHRONIZATION_COMPLETED, { time: time, offset: offset, error: failed ? new DashJSError(Errors.TIME_SYNC_FAILED_ERROR_CODE, Errors.TIME_SYNC_FAILED_ERROR_MESSAGE) : null });\r\n    }\r\n\r\n    function calculateTimeOffset(serverTime, deviceTime) {\r\n        return serverTime - deviceTime;\r\n    }\r\n\r\n    function attemptSync(sources, sourceIndex) {\r\n\r\n        // if called with no sourceIndex, use zero (highest priority)\r\n        let  index = sourceIndex || 0;\r\n\r\n        // the sources should be ordered in priority from the manifest.\r\n        // try each in turn, from the top, until either something\r\n        // sensible happens, or we run out of sources to try.\r\n        let source = sources[index];\r\n\r\n        // callback to emit event to listeners\r\n        const onComplete = function (time, offset) {\r\n            let failed = !time || !offset;\r\n            if (failed && useManifestDateHeaderTimeSource) {\r\n                //Before falling back to binary search , check if date header exists on MPD. if so, use for a time source.\r\n                checkForDateHeader();\r\n            } else {\r\n                completeTimeSyncSequence(failed, time, offset);\r\n            }\r\n        };\r\n\r\n        setIsSynchronizing(true);\r\n\r\n        if (source) {\r\n            // check if there is a handler for this @schemeIdUri\r\n            if (handlers.hasOwnProperty(source.schemeIdUri)) {\r\n                // if so, call it with its @value\r\n                handlers[source.schemeIdUri](\r\n                    source.value,\r\n                    function (serverTime) {\r\n                        // the timing source returned something useful\r\n                        const deviceTime = new Date().getTime();\r\n                        const offset = calculateTimeOffset(serverTime, deviceTime);\r\n\r\n                        setOffsetMs(offset);\r\n\r\n                        logger.info('Local time: ' + new Date(deviceTime));\r\n                        logger.info('Server time: ' + new Date(serverTime));\r\n                        logger.info('Server Time - Local Time (ms): ' + offset);\r\n\r\n                        onComplete(serverTime, offset);\r\n                    },\r\n                    function () {\r\n                        // the timing source was probably uncontactable\r\n                        // or returned something we can't use - try again\r\n                        // with the remaining sources\r\n                        attemptSync(sources, index + 1);\r\n                    }\r\n                );\r\n            } else {\r\n                // an unknown schemeIdUri must have been found\r\n                // try again with the remaining sources\r\n                attemptSync(sources, index + 1);\r\n            }\r\n        } else {\r\n            // no valid time source could be found, just use device time\r\n            setOffsetMs(0);\r\n            onComplete();\r\n        }\r\n    }\r\n\r\n    function reset() {\r\n        setIsSynchronizing(false);\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        getOffsetToDeviceTimeMs: getOffsetToDeviceTimeMs,\r\n        setConfig: setConfig,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nTimeSyncController.__dashjs_factory_name = 'TimeSyncController';\r\nconst factory = FactoryMaker.getSingletonFactory(TimeSyncController);\r\nfactory.HTTP_TIMEOUT_MS = HTTP_TIMEOUT_MS;\r\nFactoryMaker.updateSingletonFactory(TimeSyncController.__dashjs_factory_name, factory);\r\nexport default factory;\r\n"]}