{"version":3,"sources":["../../../../../src/streaming/controllers/ScheduleController.js"],"names":["ScheduleController","config","context","eventBus","getInstance","metricsModel","adapter","dashMetrics","dashManifestModel","timelineConverter","mediaPlayerModel","abrController","playbackController","streamController","textController","type","streamProcessor","mediaController","instance","logger","fragmentModel","currentRepresentationInfo","initialRequest","isStopped","playListMetrics","playListTraceMetrics","playListTraceMetricsClosed","isFragmentProcessingInProgress","timeToLoadDelay","scheduleTimeout","seekTarget","bufferLevelRule","nextFragmentRequestRule","lastFragmentRequest","topQualityIndex","lastInitQuality","replaceRequestArray","switchTrack","bufferResetInProgress","mediaRequest","isReplacementRequest","isGoogleCast","setup","getLogger","resetInitialSettings","initialize","getFragmentModel","create","getIsTextTrack","mimeType","on","Events","TIMED_TEXT_REQUESTED","onTimedTextRequested","ua","navigator","userAgent","toLowerCase","test","QUALITY_CHANGE_REQUESTED","onQualityChanged","DATA_UPDATE_STARTED","onDataUpdateStarted","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","FRAGMENT_LOADING_COMPLETED","onFragmentLoadingCompleted","STREAM_COMPLETED","onStreamCompleted","STREAM_INITIALIZED","onStreamInitialized","BUFFER_LEVEL_STATE_CHANGED","onBufferLevelStateChanged","BUFFER_CLEARED","onBufferCleared","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","INIT_REQUESTED","onInitRequested","QUOTA_EXCEEDED","onQuotaExceeded","PLAYBACK_SEEKING","onPlaybackSeeking","PLAYBACK_STARTED","onPlaybackStarted","PLAYBACK_RATE_CHANGED","onPlaybackRateChanged","PLAYBACK_TIME_UPDATED","onPlaybackTimeUpdated","URL_RESOLUTION_FAILED","onURLResolutionFailed","FRAGMENT_LOADING_ABANDONED","onFragmentLoadingAbandoned","isStarted","start","isBufferingCompleted","warn","debug","addPlaylistTraceMetrics","startScheduleTimer","stop","clearTimeout","hasTopQualityChanged","id","newTopQualityIndex","getTopQualityIndexFor","info","schedule","bufferController","getBufferController","isPaused","getScheduleWhilePaused","Constants","FRAGMENTED_TEXT","TEXT","isTextEnabled","getIsBufferingCompleted","validateExecutedFragmentRequest","isReplacement","length","streamInfo","getStreamInfo","isNaN","mediaInfo","execute","isTrackTypePresent","VIDEO","getNextFragment","fragmentController","getFragmentController","quality","getSwitchMode","MediaController","TRACK_SWITCH_MODE_ALWAYS_REPLACE","switchInitData","replacement","shift","isInitializationRequest","representationId","request","getIsPruningInProgress","setSeekTarget","NaN","startTime","duration","setIndexHandlerTime","delayLoadingTime","Date","getTime","setTimeToLoadDelay","manifestInfo","isDynamic","url","executeRequest","setFragmentProcessState","getLowLatencyEnabled","checkPlaybackQuality","time","safeBufferLevel","fragmentDuration","getRequests","state","FragmentModel","FRAGMENT_MODEL_EXECUTED","threshold","indexOf","fastSwitchModeEnabled","getFastSwitchEnabled","bufferLevel","getBufferLevel","abandonmentState","getAbandonmentStateFor","trackChanged","isCurrentTrack","TRACK_SWITCH_MODE_NEVER_REPLACE","qualityChanged","AbrController","ABANDON_LOAD","replaceRequest","index","value","setTimeout","e","sender","getStreamProcessor","getInitRequest","bandwidth","switchTrackAsked","push","mediaType","getRepresentationInfo","newQuality","undefined","Error","clearPlayListTraceMetrics","PlayListTrace","REPRESENTATION_SWITCH_STOP_REASON","completeQualityChange","trigger","item","TRACK_CHANGE_RENDERED","oldMediaInfo","newMediaInfo","adaptationIndex","QUALITY_CHANGE_RENDERED","oldQuality","error","convertDataToRepresentationInfo","currentRepresentation","getIsDynamic","setTimeSyncCompleted","setLiveEdgeSeekTarget","getStreamStartTime","setSeekStartTime","liveEdgeFinder","getLiveEdgeFinder","liveEdge","getLiveEdge","computeLiveDelay","DVRWindowSize","getFragmentRequest","ignoreIsFinished","liveStartTime","getLiveDelay","setLiveStartTime","seek","manifestUpdateInfo","getCurrentManifestUpdate","getMetricsFor","STREAM","updateManifestUpdateInfo","currentTime","presentationStartTime","latency","clientTimeOffset","getClientTimeOffset","range","serviceLocation","addExecutedRequest","fragEndTime","isSeeking","unintended","removeExecutedRequestsAfterTime","from","syncExecutedRequestsWithBufferedRange","getBuffer","getAllBufferRanges","hasEnoughSpaceToAppend","quotaExceeded","BufferController","BUFFER_EMPTY","REBUFFERING_REASON","abortRequests","seekTime","DVRWindow","end","playbackspeed","playbackRate","toString","getBufferTarget","getType","setPlayList","playList","finalisePlayList","reason","endTime","stopreason","trace","representationid","mstart","getPlaybackRate","reset","off","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"ScheduleController.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport Constants from '../constants/Constants';\r\nimport {PlayListTrace} from '../vo/metrics/PlayList';\r\nimport AbrController from './AbrController';\r\nimport BufferController from './BufferController';\r\nimport BufferLevelRule from '../rules/scheduling/BufferLevelRule';\r\nimport NextFragmentRequestRule from '../rules/scheduling/NextFragmentRequestRule';\r\nimport FragmentModel from '../models/FragmentModel';\r\nimport EventBus from '../../core/EventBus';\r\nimport Events from '../../core/events/Events';\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport Debug from '../../core/Debug';\r\nimport MediaController from './MediaController';\r\nimport {replaceTokenForTemplate} from '../../dash/utils/SegmentsUtils';\r\n\r\nfunction ScheduleController(config) {\r\n\r\n    config = config || {};\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n    const metricsModel = config.metricsModel;\r\n    const adapter = config.adapter;\r\n    const dashMetrics = config.dashMetrics;\r\n    const dashManifestModel = config.dashManifestModel;\r\n    const timelineConverter = config.timelineConverter;\r\n    const mediaPlayerModel = config.mediaPlayerModel;\r\n    const abrController = config.abrController;\r\n    const playbackController = config.playbackController;\r\n    const streamController = config.streamController;\r\n    const textController = config.textController;\r\n    const type = config.type;\r\n    const streamProcessor = config.streamProcessor;\r\n    const mediaController = config.mediaController;\r\n\r\n    let instance,\r\n        logger,\r\n        fragmentModel,\r\n        currentRepresentationInfo,\r\n        initialRequest,\r\n        isStopped,\r\n        playListMetrics,\r\n        playListTraceMetrics,\r\n        playListTraceMetricsClosed,\r\n        isFragmentProcessingInProgress,\r\n        timeToLoadDelay,\r\n        scheduleTimeout,\r\n        seekTarget,\r\n        bufferLevelRule,\r\n        nextFragmentRequestRule,\r\n        lastFragmentRequest,\r\n        topQualityIndex,\r\n        lastInitQuality,\r\n        replaceRequestArray,\r\n        switchTrack,\r\n        bufferResetInProgress,\r\n        mediaRequest,\r\n        isReplacementRequest,\r\n        isGoogleCast;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        resetInitialSettings();\r\n    }\r\n\r\n    function initialize() {\r\n        fragmentModel = streamProcessor.getFragmentModel();\r\n\r\n        bufferLevelRule = BufferLevelRule(context).create({\r\n            abrController: abrController,\r\n            dashMetrics: dashMetrics,\r\n            metricsModel: metricsModel,\r\n            mediaPlayerModel: mediaPlayerModel,\r\n            textController: textController\r\n        });\r\n\r\n        nextFragmentRequestRule = NextFragmentRequestRule(context).create({\r\n            adapter: adapter,\r\n            textController: textController,\r\n            playbackController: playbackController\r\n        });\r\n\r\n        if (dashManifestModel.getIsTextTrack(config.mimeType)) {\r\n            eventBus.on(Events.TIMED_TEXT_REQUESTED, onTimedTextRequested, this);\r\n        }\r\n\r\n        const ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';\r\n        // Detect safari browser (special behavior for low latency streams)\r\n        isGoogleCast = /crkey/.test(ua);\r\n\r\n        //eventBus.on(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\r\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, this);\r\n        eventBus.on(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\r\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\r\n        eventBus.on(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\r\n        eventBus.on(Events.STREAM_COMPLETED, onStreamCompleted, this);\r\n        eventBus.on(Events.STREAM_INITIALIZED, onStreamInitialized, this);\r\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\r\n        eventBus.on(Events.BUFFER_CLEARED, onBufferCleared, this);\r\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\r\n        eventBus.on(Events.INIT_REQUESTED, onInitRequested, this);\r\n        eventBus.on(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\r\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\r\n        eventBus.on(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\r\n        eventBus.on(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\r\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\r\n        eventBus.on(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\r\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\r\n    }\r\n\r\n    function isStarted() {\r\n        return (isStopped === false);\r\n    }\r\n\r\n    function start() {\r\n        if (!currentRepresentationInfo || streamProcessor.isBufferingCompleted()) {\r\n            logger.warn('Start denied to Schedule Controller');\r\n            return;\r\n        }\r\n        logger.debug('Schedule Controller starts');\r\n        addPlaylistTraceMetrics();\r\n        isStopped = false;\r\n\r\n        if (initialRequest) {\r\n            initialRequest = false;\r\n        }\r\n\r\n        startScheduleTimer(0);\r\n    }\r\n\r\n    function stop() {\r\n        if (isStopped) {\r\n            return;\r\n        }\r\n        logger.debug('Schedule Controller stops');\r\n        isStopped = true;\r\n        clearTimeout(scheduleTimeout);\r\n    }\r\n\r\n    function hasTopQualityChanged(type, id) {\r\n        topQualityIndex[id] = topQualityIndex[id] || {};\r\n        const newTopQualityIndex = abrController.getTopQualityIndexFor(type, id);\r\n\r\n        if (topQualityIndex[id][type] != newTopQualityIndex) {\r\n            logger.info('Top quality ' + type + ' index has changed from ' + topQualityIndex[id][type] + ' to ' + newTopQualityIndex);\r\n            topQualityIndex[id][type] = newTopQualityIndex;\r\n            return true;\r\n        }\r\n        return false;\r\n\r\n    }\r\n\r\n    function schedule() {\r\n        const bufferController = streamProcessor.getBufferController();\r\n        if (isStopped || isFragmentProcessingInProgress || !bufferController ||\r\n            (playbackController.isPaused() && !mediaPlayerModel.getScheduleWhilePaused()) ||\r\n            ((type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) && !textController.isTextEnabled())) {\r\n            logger.debug('Schedule stop!');\r\n            return;\r\n        }\r\n\r\n        if (bufferController.getIsBufferingCompleted()) {\r\n            logger.debug('Schedule stop because buffering is completed!');\r\n            return;\r\n        }\r\n\r\n        validateExecutedFragmentRequest();\r\n\r\n        const isReplacement = replaceRequestArray.length > 0;\r\n        const streamInfo = streamProcessor.getStreamInfo();\r\n        if (bufferResetInProgress || isNaN(lastInitQuality) || switchTrack || isReplacement ||\r\n            hasTopQualityChanged(currentRepresentationInfo.mediaInfo.type, streamInfo.id) ||\r\n            bufferLevelRule.execute(streamProcessor, streamController.isTrackTypePresent(Constants.VIDEO))) {\r\n\r\n            const getNextFragment = function () {\r\n                const fragmentController = streamProcessor.getFragmentController();\r\n                if ((currentRepresentationInfo.quality !== lastInitQuality || switchTrack) && (!bufferResetInProgress)) {\r\n                    logger.debug('Quality has changed, get init request for representationid = ' + currentRepresentationInfo.id);\r\n                    if (switchTrack) {\r\n                        bufferResetInProgress = mediaController.getSwitchMode(type) === MediaController.TRACK_SWITCH_MODE_ALWAYS_REPLACE ? true : false;\r\n                        logger.debug('Switch track has been asked, get init request for ' + type + ' with representationid = ' + currentRepresentationInfo.id + 'bufferResetInProgress = ' + bufferResetInProgress);\r\n                        streamProcessor.switchInitData(currentRepresentationInfo.id, bufferResetInProgress);\r\n                        switchTrack = false;\r\n                    } else {\r\n                        streamProcessor.switchInitData(currentRepresentationInfo.id);\r\n                    }\r\n                    lastInitQuality = currentRepresentationInfo.quality;\r\n\r\n                } else {\r\n                    const replacement = replaceRequestArray.shift();\r\n\r\n                    if (fragmentController.isInitializationRequest(replacement)) {\r\n                        // To be sure the specific init segment had not already been loaded.\r\n                        streamProcessor.switchInitData(replacement.representationId);\r\n                    } else {\r\n                        let request;\r\n                        // Don't schedule next fragments while pruning to avoid buffer inconsistencies\r\n                        if (!streamProcessor.getBufferController().getIsPruningInProgress()) {\r\n                            request = nextFragmentRequestRule.execute(streamProcessor, seekTarget, replacement);\r\n                            setSeekTarget(NaN);\r\n                            if (request && !replacement) {\r\n                                if (!isNaN(request.startTime + request.duration)) {\r\n                                    adapter.setIndexHandlerTime(streamProcessor, request.startTime + request.duration);\r\n                                }\r\n                                request.delayLoadingTime = new Date().getTime() + timeToLoadDelay;\r\n                                setTimeToLoadDelay(0);\r\n                            }\r\n                            if (!request && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic) {\r\n                                logger.debug('Next fragment seems to be at the bleeding live edge and is not available yet. Rescheduling.');\r\n                            }\r\n                        }\r\n\r\n                        if (request) {\r\n                            logger.debug('Next fragment request url is ' + request.url);\r\n                            fragmentModel.executeRequest(request);\r\n                        } else { // Use case - Playing at the bleeding live edge and frag is not available yet. Cycle back around.\r\n                            setFragmentProcessState(false);\r\n                            startScheduleTimer(mediaPlayerModel.getLowLatencyEnabled() ? 100 : 500);\r\n                        }\r\n                    }\r\n                }\r\n            };\r\n\r\n            setFragmentProcessState(true);\r\n            if (!isReplacement && !switchTrack) {\r\n                abrController.checkPlaybackQuality(type);\r\n            }\r\n\r\n            getNextFragment();\r\n\r\n        } else {\r\n            startScheduleTimer(500);\r\n        }\r\n    }\r\n\r\n    function validateExecutedFragmentRequest() {\r\n        // Validate that the fragment request executed and appended into the source buffer is as\r\n        // good of quality as the current quality and is the correct media track.\r\n        const time = playbackController.getTime();\r\n        const safeBufferLevel = currentRepresentationInfo.fragmentDuration * 1.5;\r\n        const request = fragmentModel.getRequests({\r\n            state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\r\n            time: time + safeBufferLevel,\r\n            threshold: 0\r\n        })[0];\r\n\r\n        if (request && replaceRequestArray.indexOf(request) === -1 && !dashManifestModel.getIsTextTrack(type)) {\r\n            const fastSwitchModeEnabled = mediaPlayerModel.getFastSwitchEnabled();\r\n            const bufferLevel = streamProcessor.getBufferLevel();\r\n            const abandonmentState = abrController.getAbandonmentStateFor(type);\r\n\r\n            // Only replace on track switch when NEVER_REPLACE\r\n            const trackChanged = !mediaController.isCurrentTrack(request.mediaInfo) && mediaController.getSwitchMode(request.mediaInfo.type) === MediaController.TRACK_SWITCH_MODE_NEVER_REPLACE;\r\n            const qualityChanged = request.quality < currentRepresentationInfo.quality;\r\n\r\n            if (fastSwitchModeEnabled && (trackChanged || qualityChanged) && bufferLevel >= safeBufferLevel && abandonmentState !== AbrController.ABANDON_LOAD) {\r\n                replaceRequest(request);\r\n                isReplacementRequest = true;\r\n                logger.debug('Reloading outdated fragment at index: ', request.index);\r\n            } else if (request.quality > currentRepresentationInfo.quality && !bufferResetInProgress) {\r\n                // The buffer has better quality it in then what we would request so set append point to end of buffer!!\r\n                setSeekTarget(playbackController.getTime() + streamProcessor.getBufferLevel());\r\n            }\r\n        }\r\n    }\r\n\r\n    function startScheduleTimer(value) {\r\n        clearTimeout(scheduleTimeout);\r\n        scheduleTimeout = setTimeout(schedule, value);\r\n    }\r\n\r\n    function onInitRequested(e) {\r\n        if (!e.sender || e.sender.getStreamProcessor() !== streamProcessor) {\r\n            return;\r\n        }\r\n\r\n        getInitRequest(currentRepresentationInfo.quality);\r\n    }\r\n\r\n    function setFragmentProcessState (state) {\r\n        if (isFragmentProcessingInProgress !== state ) {\r\n            isFragmentProcessingInProgress = state;\r\n        } else {\r\n            logger.debug('isFragmentProcessingInProgress is already equal to', state);\r\n        }\r\n    }\r\n\r\n    function getInitRequest(quality) {\r\n        const request = adapter.getInitRequest(streamProcessor, quality);\r\n        if (request) {\r\n            setFragmentProcessState(true);\r\n            request.url = replaceTokenForTemplate(request.url, 'Bandwidth', currentRepresentationInfo ? currentRepresentationInfo.bandwidth : null);\r\n            fragmentModel.executeRequest(request);\r\n        }\r\n    }\r\n\r\n    function switchTrackAsked() {\r\n        switchTrack = true;\r\n    }\r\n\r\n    function replaceRequest(request) {\r\n        replaceRequestArray.push(request);\r\n    }\r\n\r\n    function onQualityChanged(e) {\r\n        if (type !== e.mediaType || streamProcessor.getStreamInfo().id !== e.streamInfo.id) {\r\n            return;\r\n        }\r\n\r\n        currentRepresentationInfo = streamProcessor.getRepresentationInfo(e.newQuality);\r\n\r\n        if (currentRepresentationInfo === null || currentRepresentationInfo === undefined) {\r\n            throw new Error('Unexpected error! - currentRepresentationInfo is null or undefined');\r\n        }\r\n\r\n        clearPlayListTraceMetrics(new Date(), PlayListTrace.REPRESENTATION_SWITCH_STOP_REASON);\r\n        addPlaylistTraceMetrics();\r\n    }\r\n\r\n    function completeQualityChange(trigger) {\r\n        if (playbackController && fragmentModel) {\r\n            const item = fragmentModel.getRequests({\r\n                state: FragmentModel.FRAGMENT_MODEL_EXECUTED,\r\n                time: playbackController.getTime(),\r\n                threshold: 0\r\n            })[0];\r\n            if (item && playbackController.getTime() >= item.startTime) {\r\n                if ((!lastFragmentRequest.mediaInfo || (item.mediaInfo.type === lastFragmentRequest.mediaInfo.type && item.mediaInfo.id !== lastFragmentRequest.mediaInfo.id)) && trigger) {\r\n                    eventBus.trigger(Events.TRACK_CHANGE_RENDERED, {\r\n                        mediaType: type,\r\n                        oldMediaInfo: lastFragmentRequest.mediaInfo,\r\n                        newMediaInfo: item.mediaInfo\r\n                    });\r\n                }\r\n                if ((item.quality !== lastFragmentRequest.quality || item.adaptationIndex !== lastFragmentRequest.adaptationIndex) && trigger) {\r\n                    eventBus.trigger(Events.QUALITY_CHANGE_RENDERED, {\r\n                        mediaType: type,\r\n                        oldQuality: lastFragmentRequest.quality,\r\n                        newQuality: item.quality\r\n                    });\r\n                }\r\n                lastFragmentRequest = {\r\n                    mediaInfo: item.mediaInfo,\r\n                    quality: item.quality,\r\n                    adaptationIndex: item.adaptationIndex\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    function onDataUpdateCompleted(e) {\r\n        if (e.error || e.sender.getStreamProcessor() !== streamProcessor) {\r\n            return;\r\n        }\r\n\r\n        currentRepresentationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation);\r\n    }\r\n\r\n    function onStreamInitialized(e) {\r\n        if (e.error || streamProcessor.getStreamInfo().id !== e.streamInfo.id) {\r\n            return;\r\n        }\r\n\r\n        currentRepresentationInfo = streamProcessor.getRepresentationInfo();\r\n\r\n        if (initialRequest) {\r\n            if (playbackController.getIsDynamic()) {\r\n                timelineConverter.setTimeSyncCompleted(true);\r\n                setLiveEdgeSeekTarget();\r\n            } else {\r\n                seekTarget = playbackController.getStreamStartTime(false);\r\n                streamProcessor.getBufferController().setSeekStartTime(seekTarget);\r\n            }\r\n        }\r\n\r\n        if (isStopped) {\r\n            start();\r\n        }\r\n    }\r\n\r\n    function setLiveEdgeSeekTarget() {\r\n        const liveEdgeFinder = streamProcessor.getLiveEdgeFinder();\r\n        if (liveEdgeFinder) {\r\n            const liveEdge = liveEdgeFinder.getLiveEdge();\r\n            const startTime = liveEdge - playbackController.computeLiveDelay(currentRepresentationInfo.fragmentDuration, currentRepresentationInfo.mediaInfo.streamInfo.manifestInfo.DVRWindowSize);\r\n            const request = adapter.getFragmentRequest(streamProcessor, currentRepresentationInfo, startTime, {\r\n                ignoreIsFinished: true\r\n            });\r\n\r\n            if (request) {\r\n                // When low latency mode is selected but browser doesn't support fetch\r\n                // start at the beginning of the segment to avoid consuming the whole buffer\r\n                if (mediaPlayerModel.getLowLatencyEnabled()) {\r\n                    const liveStartTime = request.duration < mediaPlayerModel.getLiveDelay() ? request.startTime : request.startTime + request.duration - mediaPlayerModel.getLiveDelay();\r\n                    playbackController.setLiveStartTime(liveStartTime);\r\n                } else {\r\n                    playbackController.setLiveStartTime(request.startTime);\r\n                }\r\n            } else {\r\n                logger.debug('setLiveEdgeSeekTarget : getFragmentRequest returned undefined request object');\r\n            }\r\n            seekTarget = playbackController.getStreamStartTime(false, liveEdge);\r\n            streamProcessor.getBufferController().setSeekStartTime(seekTarget);\r\n\r\n            //special use case for multi period stream. If the startTime is out of the current period, send a seek command.\r\n            //in onPlaybackSeeking callback (StreamController), the detection of switch stream is done.\r\n            if (seekTarget > (currentRepresentationInfo.mediaInfo.streamInfo.start + currentRepresentationInfo.mediaInfo.streamInfo.duration)) {\r\n                playbackController.seek(seekTarget);\r\n            }\r\n\r\n            const manifestUpdateInfo = dashMetrics.getCurrentManifestUpdate(metricsModel.getMetricsFor(Constants.STREAM));\r\n            metricsModel.updateManifestUpdateInfo(manifestUpdateInfo, {\r\n                currentTime: seekTarget,\r\n                presentationStartTime: liveEdge,\r\n                latency: liveEdge - seekTarget,\r\n                clientTimeOffset: timelineConverter.getClientTimeOffset()\r\n            });\r\n        }\r\n    }\r\n\r\n    function onStreamCompleted(e) {\r\n        if (e.fragmentModel !== fragmentModel) {\r\n            return;\r\n        }\r\n\r\n        stop();\r\n        setFragmentProcessState(false);\r\n        logger.info('Stream is complete');\r\n    }\r\n\r\n    function onFragmentLoadingCompleted(e) {\r\n        if (e.sender !== fragmentModel) {\r\n            return;\r\n        }\r\n        logger.info('OnFragmentLoadingCompleted - Url:', e.request ? e.request.url : 'undefined',\r\n            ', Range:', e.request.range ? e.request.range : 'undefined');\r\n        if (dashManifestModel.getIsTextTrack(type)) {\r\n            setFragmentProcessState(false);\r\n        }\r\n\r\n        if (e.error && e.request.serviceLocation && !isStopped) {\r\n            replaceRequest(e.request);\r\n            setFragmentProcessState(false);\r\n            startScheduleTimer(0);\r\n        }\r\n\r\n        if (bufferResetInProgress) {\r\n            mediaRequest = e.request;\r\n        }\r\n    }\r\n\r\n    function onPlaybackTimeUpdated() {\r\n        completeQualityChange(true);\r\n    }\r\n\r\n    function onBytesAppended(e) {\r\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\r\n            return;\r\n        }\r\n\r\n        if (bufferResetInProgress && !isNaN(e.startTime)) {\r\n            bufferResetInProgress = false;\r\n            fragmentModel.addExecutedRequest(mediaRequest);\r\n            // For some devices (like chromecast) it is necessary to seek the video element to\r\n            // reset the internal decoding buffer, otherwise audio track switch will be effective only after\r\n            // some more seconds\r\n            if (isGoogleCast) {\r\n                playbackController.seek(playbackController.getTime() - 0.001, false, true);\r\n            }\r\n        }\r\n\r\n        setFragmentProcessState(false);\r\n        if (isReplacementRequest && !isNaN(e.startTime)) {\r\n            //replace requests process is in progress, call schedule in n seconds.\r\n            //it is done in order to not add a fragment at the new quality at the end of the buffer before replace process is over.\r\n            //Indeed, if schedule is called too early, the executed request tested is the same that the one tested during previous schedule (at the new quality).\r\n            const currentTime = playbackController.getTime();\r\n            const fragEndTime = e.startTime + currentRepresentationInfo.fragmentDuration;\r\n            const safeBufferLevel = currentRepresentationInfo.fragmentDuration * 1.5;\r\n            if ((currentTime + safeBufferLevel) >= fragEndTime) {\r\n                startScheduleTimer(0);\r\n            }\r\n            else {\r\n                startScheduleTimer((fragEndTime - (currentTime + safeBufferLevel)) * 1000);\r\n            }\r\n            isReplacementRequest = false;\r\n        } else {\r\n            startScheduleTimer(0);\r\n        }\r\n    }\r\n\r\n    function onFragmentLoadingAbandoned(e) {\r\n        if (e.streamProcessor !== streamProcessor) {\r\n            return;\r\n        }\r\n        logger.info('onFragmentLoadingAbandoned for ' + type + ', request: ' + e.request.url + ' has been aborted');\r\n        if (!playbackController.isSeeking() && !switchTrack) {\r\n            logger.info('onFragmentLoadingAbandoned for ' + type + ', request: ' + e.request.url + ' has to be downloaded again, origin is not seeking process or switch track call');\r\n            replaceRequest(e.request);\r\n        }\r\n        setFragmentProcessState(false);\r\n        startScheduleTimer(0);\r\n    }\r\n\r\n    function onDataUpdateStarted(e) {\r\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\r\n            return;\r\n        }\r\n\r\n        stop();\r\n    }\r\n\r\n    function onBufferCleared(e) {\r\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\r\n            return;\r\n        }\r\n\r\n        const streamInfo = streamProcessor.getStreamInfo();\r\n        if (streamInfo) {\r\n            if (e.unintended) {\r\n                // There was an unintended buffer remove, probably creating a gap in the buffer, remove every saved request\r\n                fragmentModel.removeExecutedRequestsAfterTime(e.from,\r\n                    streamInfo.duration);\r\n            } else {\r\n                fragmentModel.syncExecutedRequestsWithBufferedRange(\r\n                    streamProcessor.getBufferController().getBuffer().getAllBufferRanges(),\r\n                    streamInfo.duration);\r\n            }\r\n        }\r\n\r\n        if (e.hasEnoughSpaceToAppend && e.quotaExceeded && isStopped) {\r\n            start();\r\n        }\r\n    }\r\n\r\n    function onBufferLevelStateChanged(e) {\r\n        if ((e.sender.getStreamProcessor() === streamProcessor) && e.state === BufferController.BUFFER_EMPTY && !playbackController.isSeeking()) {\r\n            logger.info('Buffer is empty! Stalling!');\r\n            clearPlayListTraceMetrics(new Date(), PlayListTrace.REBUFFERING_REASON);\r\n        }\r\n    }\r\n\r\n    function onQuotaExceeded(e) {\r\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\r\n            return;\r\n        }\r\n\r\n        stop();\r\n        setFragmentProcessState(false);\r\n    }\r\n\r\n    function onURLResolutionFailed() {\r\n        fragmentModel.abortRequests();\r\n        stop();\r\n    }\r\n\r\n    function onTimedTextRequested(e) {\r\n        if (e.sender.getStreamProcessor() !== streamProcessor) {\r\n            return;\r\n        }\r\n\r\n        //if subtitles are disabled, do not download subtitles file.\r\n        if (textController.isTextEnabled()) {\r\n            getInitRequest(e.index);\r\n        }\r\n    }\r\n\r\n    function onPlaybackStarted() {\r\n        if (isStopped || !mediaPlayerModel.getScheduleWhilePaused()) {\r\n            start();\r\n        }\r\n    }\r\n\r\n    function onPlaybackSeeking(e) {\r\n        seekTarget = e.seekTime;\r\n        setTimeToLoadDelay(0);\r\n\r\n        if (isStopped) {\r\n            start();\r\n        }\r\n\r\n        const manifestUpdateInfo = dashMetrics.getCurrentManifestUpdate(metricsModel.getMetricsFor(Constants.STREAM));\r\n        const latency = currentRepresentationInfo.DVRWindow && playbackController ? currentRepresentationInfo.DVRWindow.end - playbackController.getTime() : NaN;\r\n        metricsModel.updateManifestUpdateInfo(manifestUpdateInfo, {\r\n            latency: latency\r\n        });\r\n\r\n        //if, during the seek command, the scheduleController is waiting : stop waiting, request chunk as soon as possible\r\n        if (!isFragmentProcessingInProgress) {\r\n            startScheduleTimer(0);\r\n        } else {\r\n            logger.debug('onPlaybackSeeking for ' + type + ', call fragmentModel.abortRequests in order to seek quicker');\r\n            fragmentModel.abortRequests();\r\n        }\r\n    }\r\n\r\n    function onPlaybackRateChanged(e) {\r\n        if (playListTraceMetrics) {\r\n            playListTraceMetrics.playbackspeed = e.playbackRate.toString();\r\n        }\r\n    }\r\n\r\n    function setSeekTarget(value) {\r\n        seekTarget = value;\r\n    }\r\n\r\n    function setTimeToLoadDelay(value) {\r\n        timeToLoadDelay = value;\r\n    }\r\n\r\n    function getBufferTarget() {\r\n        return bufferLevelRule.getBufferTarget(streamProcessor, streamController.isTrackTypePresent(Constants.VIDEO));\r\n    }\r\n\r\n    function getType() {\r\n        return type;\r\n    }\r\n\r\n    function setPlayList(playList) {\r\n        playListMetrics = playList;\r\n    }\r\n\r\n    function finalisePlayList(time, reason) {\r\n        clearPlayListTraceMetrics(time, reason);\r\n        playListMetrics = null;\r\n    }\r\n\r\n    function clearPlayListTraceMetrics(endTime, stopreason) {\r\n        if (playListMetrics && playListTraceMetricsClosed === false) {\r\n            const startTime = playListTraceMetrics.start;\r\n            const duration = endTime.getTime() - startTime.getTime();\r\n            playListTraceMetrics.duration = duration;\r\n            playListTraceMetrics.stopreason = stopreason;\r\n            playListMetrics.trace.push(playListTraceMetrics);\r\n            playListTraceMetricsClosed = true;\r\n        }\r\n    }\r\n\r\n    function addPlaylistTraceMetrics() {\r\n        if (playListMetrics && playListTraceMetricsClosed === true && currentRepresentationInfo) {\r\n            playListTraceMetricsClosed = false;\r\n            playListTraceMetrics = new PlayListTrace();\r\n            playListTraceMetrics.representationid = currentRepresentationInfo.id;\r\n            playListTraceMetrics.start = new Date();\r\n            playListTraceMetrics.mstart = playbackController.getTime() * 1000;\r\n            playListTraceMetrics.playbackspeed = playbackController.getPlaybackRate().toString();\r\n        }\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        isFragmentProcessingInProgress = false;\r\n        timeToLoadDelay = 0;\r\n        seekTarget = NaN;\r\n        playListMetrics = null;\r\n        playListTraceMetrics = null;\r\n        playListTraceMetricsClosed = true;\r\n        initialRequest = true;\r\n        lastInitQuality = NaN;\r\n        lastFragmentRequest = {\r\n            mediaInfo: undefined,\r\n            quality: NaN,\r\n            adaptationIndex: NaN\r\n        };\r\n        topQualityIndex = {};\r\n        replaceRequestArray = [];\r\n        isStopped = true;\r\n        switchTrack = false;\r\n        bufferResetInProgress = false;\r\n        mediaRequest = null;\r\n        isReplacementRequest = false;\r\n    }\r\n\r\n    function reset() {\r\n        //eventBus.off(Events.LIVE_EDGE_SEARCH_COMPLETED, onLiveEdgeSearchCompleted, this);\r\n        eventBus.off(Events.DATA_UPDATE_STARTED, onDataUpdateStarted, this);\r\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\r\n        eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\r\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChanged, this);\r\n        eventBus.off(Events.FRAGMENT_LOADING_COMPLETED, onFragmentLoadingCompleted, this);\r\n        eventBus.off(Events.STREAM_COMPLETED, onStreamCompleted, this);\r\n        eventBus.off(Events.STREAM_INITIALIZED, onStreamInitialized, this);\r\n        eventBus.off(Events.QUOTA_EXCEEDED, onQuotaExceeded, this);\r\n        eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\r\n        eventBus.off(Events.BUFFER_CLEARED, onBufferCleared, this);\r\n        eventBus.off(Events.INIT_REQUESTED, onInitRequested, this);\r\n        eventBus.off(Events.PLAYBACK_RATE_CHANGED, onPlaybackRateChanged, this);\r\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, this);\r\n        eventBus.off(Events.PLAYBACK_STARTED, onPlaybackStarted, this);\r\n        eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackTimeUpdated, this);\r\n        eventBus.off(Events.URL_RESOLUTION_FAILED, onURLResolutionFailed, this);\r\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, this);\r\n        if (dashManifestModel.getIsTextTrack(type)) {\r\n            eventBus.off(Events.TIMED_TEXT_REQUESTED, onTimedTextRequested, this);\r\n        }\r\n\r\n        stop();\r\n        completeQualityChange(false);\r\n        resetInitialSettings();\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        getType: getType,\r\n        setSeekTarget: setSeekTarget,\r\n        setTimeToLoadDelay: setTimeToLoadDelay,\r\n        replaceRequest: replaceRequest,\r\n        switchTrackAsked: switchTrackAsked,\r\n        isStarted: isStarted,\r\n        start: start,\r\n        stop: stop,\r\n        reset: reset,\r\n        setPlayList: setPlayList,\r\n        getBufferTarget: getBufferTarget,\r\n        finalisePlayList: finalisePlayList\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nScheduleController.__dashjs_factory_name = 'ScheduleController';\r\nexport default FactoryMaker.getClassFactory(ScheduleController);\r\n"]}