{"version":3,"sources":["../../../../../src/streaming/controllers/PlaybackController.js"],"names":["Constants","BufferController","EventBus","Events","FactoryMaker","Debug","LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS","PlaybackController","context","eventBus","getInstance","instance","logger","streamController","metricsModel","dashMetrics","manifestModel","dashManifestModel","adapter","videoModel","timelineConverter","liveStartTime","wallclockTimeIntervalId","commonEarliestTime","liveDelay","bufferedRange","streamInfo","isDynamic","mediaPlayerModel","playOnceInitialized","lastLivePlaybackTime","availabilityStartTime","compatibleWithPreviousStream","isLowLatencySeekingInProgress","playbackStalled","minPlaybackRateChange","uriFragmentModel","setup","getLogger","reset","initialize","StreamInfo","compatible","addAllListeners","manifestInfo","start","ua","navigator","userAgent","toLowerCase","isSafari","test","on","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","BYTES_APPENDED_END_FRAGMENT","onBytesAppended","LOADING_PROGRESS","onFragmentLoadProgress","BUFFER_LEVEL_STATE_CHANGED","onBufferLevelStateChanged","PERIOD_SWITCH_STARTED","onPeriodSwitchStarted","PLAYBACK_PROGRESS","onPlaybackProgression","PLAYBACK_TIME_UPDATED","PLAYBACK_ENDED","onPlaybackEnded","play","e","fromStreamInfo","id","undefined","getTimeToStreamEnd","parseFloat","getStreamEndTime","getTime","toFixed","startTime","getStreamStartTime","offset","duration","getElement","isPaused","pause","isSeeking","seek","time","stickToBuffered","internalSeek","removeEventListener","onPlaybackSeeking","info","setCurrentTime","trigger","PLAYBACK_SEEK_ASKED","seekToLive","metrics","getReadOnlyMetricsFor","VIDEO","AUDIO","DVRMetrics","getCurrentDVRInfo","DVRWindow","range","end","getLiveDelay","getNormalizedTime","t","isNaN","timeOffset","getPlaybackRate","getPlayedRanges","getEnded","getIsDynamic","getStreamController","setLiveStartTime","value","getLiveStartTime","computeLiveDelay","fragmentDuration","dvrWindowSize","mpd","getMpd","getValue","delay","ret","END_OF_PLAYLIST_PADDING","getUseSuggestedPresentationDelay","hasOwnProperty","SUGGESTED_PRESENTATION_DELAY","suggestedPresentationDelay","getLowLatencyEnabled","getLiveDelayFragmentCount","minBufferTime","targetDelayCapping","Math","max","min","getCurrentLiveLatency","NaN","currentTime","now","Date","getClientTimeOffset","off","stopUpdatingWallclockTime","removeAllListeners","setConfig","config","getStartTimeFromUriParameters","fragData","getURIFragmentData","uriParameters","r","parseInt","DVRWindowSize","floor","availableFrom","fragS","s","fragT","ignoreStartOffset","liveEdge","presentationStartTime","startTimeOffset","earliestTime","audio","video","getActualPresentationTime","actualTime","startUpdatingWallclockTime","tick","onWallclockTime","setInterval","getWallclockTimeUpdateInterval","clearInterval","updateCurrentTime","getReadyState","timeChanged","error","representationInfo","convertDataToRepresentationInfo","currentRepresentation","mediaInfo","onCanPlay","CAN_PLAY","onPlaybackStart","PLAYBACK_STARTED","onPlaybackWaiting","PLAYBACK_WAITING","playingTime","onPlaybackPlaying","PLAYBACK_PLAYING","onPlaybackPaused","PLAYBACK_PAUSED","ended","seekTime","PLAYBACK_SEEKING","onPlaybackSeeked","PLAYBACK_SEEKED","addEventListener","onPlaybackTimeUpdated","timeToEnd","updateLivePlaybackTime","onPlaybackProgress","onPlaybackRateChanged","rate","PLAYBACK_RATE_CHANGED","playbackRate","onPlaybackMetaDataLoaded","PLAYBACK_METADATA_LOADED","onNativePlaybackEnded","getActiveStreamInfo","isLast","onPlaybackError","event","target","srcElement","PLAYBACK_ERROR","WALLCLOCK_TIME_UPDATED","checkTimeInRanges","ranges","length","i","len","getCatchUpPlaybackRate","needToCatchUp","startPlaybackCatchUp","stopPlaybackCatchUp","getBufferLevel","bufferLevel","getActiveStreamProcessors","forEach","p","bl","abs","getLowLatencyMinDrift","cpr","deltaLatency","d","pow","E","newRate","setPlaybackRate","getLowLatencyMaxDriftBeforeSeeking","initialStartTime","bufferedRanges","started","type","sender","getType","hasVideoTrack","isTrackTypePresent","hasAudioTrack","stream","request","minDelay","warn","setLiveDelay","state","BUFFER_EMPTY","setStallState","mediaType","onPlaybackStalled","PLAYBACK_STALLED","__dashjs_factory_name","getSingletonFactory"],"mappings":"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","file":"PlaybackController.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport Constants from '../constants/Constants';\r\nimport BufferController from './BufferController';\r\nimport EventBus from '../../core/EventBus';\r\nimport Events from '../../core/events/Events';\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport Debug from '../../core/Debug';\r\n\r\nconst LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS = 500;\r\n\r\nfunction PlaybackController() {\r\n\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n\r\n    let instance,\r\n        logger,\r\n        streamController,\r\n        metricsModel,\r\n        dashMetrics,\r\n        manifestModel,\r\n        dashManifestModel,\r\n        adapter,\r\n        videoModel,\r\n        timelineConverter,\r\n        liveStartTime,\r\n        wallclockTimeIntervalId,\r\n        commonEarliestTime,\r\n        liveDelay,\r\n        bufferedRange,\r\n        streamInfo,\r\n        isDynamic,\r\n        mediaPlayerModel,\r\n        playOnceInitialized,\r\n        lastLivePlaybackTime,\r\n        availabilityStartTime,\r\n        compatibleWithPreviousStream,\r\n        isLowLatencySeekingInProgress,\r\n        playbackStalled,\r\n        minPlaybackRateChange,\r\n        uriFragmentModel;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n\r\n        reset();\r\n    }\r\n\r\n    function initialize(StreamInfo, compatible) {\r\n        streamInfo = StreamInfo;\r\n        addAllListeners();\r\n        isDynamic = streamInfo.manifestInfo.isDynamic;\r\n        isLowLatencySeekingInProgress = false;\r\n        playbackStalled = false;\r\n        liveStartTime = streamInfo.start;\r\n        compatibleWithPreviousStream = compatible;\r\n\r\n        const ua = typeof navigator !== 'undefined' ? navigator.userAgent.toLowerCase() : '';\r\n\r\n        // Detect safari browser (special behavior for low latency streams)\r\n        const isSafari = /safari/.test(ua) && !/chrome/.test(ua);\r\n        minPlaybackRateChange = isSafari ? 0.25 : 0.02;\r\n\r\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\r\n        eventBus.on(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\r\n        eventBus.on(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\r\n        eventBus.on(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\r\n        eventBus.on(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, this);\r\n        eventBus.on(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\r\n        eventBus.on(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\r\n        eventBus.on(Events.PLAYBACK_ENDED, onPlaybackEnded, this);\r\n\r\n        if (playOnceInitialized) {\r\n            playOnceInitialized = false;\r\n            play();\r\n        }\r\n    }\r\n\r\n    function onPeriodSwitchStarted(e) {\r\n        if (!isDynamic && e.fromStreamInfo && commonEarliestTime[e.fromStreamInfo.id] !== undefined) {\r\n            delete bufferedRange[e.fromStreamInfo.id];\r\n            delete commonEarliestTime[e.fromStreamInfo.id];\r\n        }\r\n    }\r\n\r\n    function getTimeToStreamEnd() {\r\n        return parseFloat((getStreamEndTime() - getTime()).toFixed(5));\r\n    }\r\n\r\n    function getStreamEndTime() {\r\n        const startTime = getStreamStartTime(true);\r\n        const offset = isDynamic && streamInfo ? startTime - streamInfo.start : 0;\r\n        return startTime + (streamInfo ? streamInfo.duration - offset : offset);\r\n    }\r\n\r\n    function play() {\r\n        if (streamInfo && videoModel && videoModel.getElement()) {\r\n            videoModel.play();\r\n        } else {\r\n            playOnceInitialized = true;\r\n        }\r\n    }\r\n\r\n    function isPaused() {\r\n        return streamInfo && videoModel ? videoModel.isPaused() : null;\r\n    }\r\n\r\n    function pause() {\r\n        if (streamInfo && videoModel) {\r\n            videoModel.pause();\r\n        }\r\n    }\r\n\r\n    function isSeeking() {\r\n        return streamInfo && videoModel ? videoModel.isSeeking() : null;\r\n    }\r\n\r\n    function seek(time, stickToBuffered, internalSeek) {\r\n        if (streamInfo && videoModel) {\r\n            if (internalSeek === true) {\r\n                if (time !== videoModel.getTime()) {\r\n                    // Internal seek = seek video model only (disable 'seeking' listener),\r\n                    // buffer(s) are already appended at given time (see onBytesAppended())\r\n                    videoModel.removeEventListener('seeking', onPlaybackSeeking);\r\n                    logger.info('Requesting seek to time: ' + time);\r\n                    videoModel.setCurrentTime(time, stickToBuffered);\r\n                }\r\n            } else {\r\n                eventBus.trigger(Events.PLAYBACK_SEEK_ASKED);\r\n                logger.info('Requesting seek to time: ' + time);\r\n                videoModel.setCurrentTime(time, stickToBuffered);\r\n            }\r\n        }\r\n    }\r\n\r\n    function seekToLive() {\r\n        const metrics = metricsModel.getReadOnlyMetricsFor(Constants.VIDEO) || metricsModel.getReadOnlyMetricsFor(Constants.AUDIO);\r\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo(metrics);\r\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\r\n\r\n        seek(DVRWindow.end - mediaPlayerModel.getLiveDelay(), true, false);\r\n    }\r\n\r\n    function getTime() {\r\n        return streamInfo && videoModel ? videoModel.getTime() : null;\r\n    }\r\n\r\n    function getNormalizedTime() {\r\n        let t = getTime();\r\n\r\n        if (isDynamic && !isNaN(availabilityStartTime)) {\r\n            const timeOffset = availabilityStartTime / 1000;\r\n            // Fix current time for firefox and safari (returned as an absolute time)\r\n            if (t > timeOffset) {\r\n                t -= timeOffset;\r\n            }\r\n        }\r\n\r\n        return t;\r\n    }\r\n\r\n    function getPlaybackRate() {\r\n        return streamInfo && videoModel ? videoModel.getPlaybackRate() : null;\r\n    }\r\n\r\n    function getPlayedRanges() {\r\n        return streamInfo && videoModel ? videoModel.getPlayedRanges() : null;\r\n    }\r\n\r\n    function getEnded() {\r\n        return streamInfo && videoModel ? videoModel.getEnded() : null;\r\n    }\r\n\r\n    function getIsDynamic() {\r\n        return isDynamic;\r\n    }\r\n\r\n    function getStreamController() {\r\n        return streamController;\r\n    }\r\n\r\n    function setLiveStartTime(value) {\r\n        liveStartTime = value;\r\n    }\r\n\r\n    function getLiveStartTime() {\r\n        return liveStartTime;\r\n    }\r\n\r\n    /**\r\n     * Computes the desirable delay for the live edge to avoid a risk of getting 404 when playing at the bleeding edge\r\n     * @param {number} fragmentDuration - seconds?\r\n     * @param {number} dvrWindowSize - seconds?\r\n     * @returns {number} object\r\n     * @memberof PlaybackController#\r\n     */\r\n    function computeLiveDelay(fragmentDuration, dvrWindowSize) {\r\n        const mpd = dashManifestModel.getMpd(manifestModel.getValue());\r\n\r\n        let delay;\r\n        let ret;\r\n        const END_OF_PLAYLIST_PADDING = 10;\r\n\r\n        if (mediaPlayerModel.getUseSuggestedPresentationDelay() && mpd.hasOwnProperty(Constants.SUGGESTED_PRESENTATION_DELAY)) {\r\n            delay = mpd.suggestedPresentationDelay;\r\n        } else if (mediaPlayerModel.getLowLatencyEnabled()) {\r\n            delay = 0;\r\n        } else if (mediaPlayerModel.getLiveDelay()) {\r\n            delay = mediaPlayerModel.getLiveDelay(); // If set by user, this value takes precedence\r\n        } else if (!isNaN(fragmentDuration)) {\r\n            delay = fragmentDuration * mediaPlayerModel.getLiveDelayFragmentCount();\r\n        } else {\r\n            delay = streamInfo.manifestInfo.minBufferTime * 2;\r\n        }\r\n\r\n        if (mpd.availabilityStartTime) {\r\n            availabilityStartTime = mpd.availabilityStartTime.getTime();\r\n        }\r\n\r\n        if (dvrWindowSize > 0) {\r\n            // cap target latency to:\r\n            // - dvrWindowSize / 2 for short playlists\r\n            // - dvrWindowSize - END_OF_PLAYLIST_PADDING for longer playlists\r\n            const targetDelayCapping = Math.max(dvrWindowSize - END_OF_PLAYLIST_PADDING, dvrWindowSize / 2);\r\n            ret = Math.min(delay, targetDelayCapping);\r\n        } else {\r\n            ret = delay;\r\n        }\r\n        liveDelay = ret;\r\n        return ret;\r\n    }\r\n\r\n    function getLiveDelay() {\r\n        return liveDelay;\r\n    }\r\n\r\n    function getCurrentLiveLatency() {\r\n        if (!isDynamic || isNaN(availabilityStartTime)) {\r\n            return NaN;\r\n        }\r\n        let currentTime = getNormalizedTime();\r\n        if (isNaN(currentTime) || currentTime === 0) {\r\n            return 0;\r\n        }\r\n\r\n        const now = new Date().getTime() + timelineConverter.getClientTimeOffset() * 1000;\r\n        return Math.max(((now - availabilityStartTime - currentTime * 1000) / 1000).toFixed(3), 0);\r\n    }\r\n\r\n    function reset() {\r\n        liveStartTime = NaN;\r\n        playOnceInitialized = false;\r\n        commonEarliestTime = {};\r\n        liveDelay = 0;\r\n        availabilityStartTime = 0;\r\n        bufferedRange = {};\r\n        if (videoModel) {\r\n            eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\r\n            eventBus.off(Events.BUFFER_LEVEL_STATE_CHANGED, onBufferLevelStateChanged, this);\r\n            eventBus.off(Events.BYTES_APPENDED_END_FRAGMENT, onBytesAppended, this);\r\n            eventBus.off(Events.LOADING_PROGRESS, onFragmentLoadProgress, this);\r\n            eventBus.off(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, this);\r\n            eventBus.off(Events.PLAYBACK_PROGRESS, onPlaybackProgression, this);\r\n            eventBus.off(Events.PLAYBACK_TIME_UPDATED, onPlaybackProgression, this);\r\n            eventBus.off(Events.PLAYBACK_ENDED, onPlaybackEnded, this);\r\n            stopUpdatingWallclockTime();\r\n            removeAllListeners();\r\n        }\r\n        wallclockTimeIntervalId = null;\r\n        videoModel = null;\r\n        streamInfo = null;\r\n        isDynamic = null;\r\n    }\r\n\r\n    function setConfig(config) {\r\n        if (!config) return;\r\n\r\n        if (config.streamController) {\r\n            streamController = config.streamController;\r\n        }\r\n        if (config.metricsModel) {\r\n            metricsModel = config.metricsModel;\r\n        }\r\n        if (config.dashMetrics) {\r\n            dashMetrics = config.dashMetrics;\r\n        }\r\n        if (config.manifestModel) {\r\n            manifestModel = config.manifestModel;\r\n        }\r\n        if (config.dashManifestModel) {\r\n            dashManifestModel = config.dashManifestModel;\r\n        }\r\n        if (config.mediaPlayerModel) {\r\n            mediaPlayerModel = config.mediaPlayerModel;\r\n        }\r\n        if (config.adapter) {\r\n            adapter = config.adapter;\r\n        }\r\n        if (config.videoModel) {\r\n            videoModel = config.videoModel;\r\n        }\r\n        if (config.timelineConverter) {\r\n            timelineConverter = config.timelineConverter;\r\n        }\r\n        if (config.uriFragmentModel) {\r\n            uriFragmentModel = config.uriFragmentModel;\r\n        }\r\n    }\r\n\r\n    function getStartTimeFromUriParameters() {\r\n        const fragData = uriFragmentModel.getURIFragmentData();\r\n        let uriParameters;\r\n        if (fragData) {\r\n            uriParameters = {};\r\n            const r = parseInt(fragData.r, 10);\r\n            if (r >= 0 && streamInfo && r < streamInfo.manifestInfo.DVRWindowSize && fragData.t === null) {\r\n                fragData.t = Math.max(Math.floor(Date.now() / 1000) - streamInfo.manifestInfo.DVRWindowSize, (streamInfo.manifestInfo.availableFrom.getTime() / 1000) + streamInfo.start) + r;\r\n            }\r\n            uriParameters.fragS = parseFloat(fragData.s);\r\n            uriParameters.fragT = parseFloat(fragData.t);\r\n        }\r\n        return uriParameters;\r\n    }\r\n\r\n    /**\r\n     * @param {boolean} ignoreStartOffset - ignore URL fragment start offset if true\r\n     * @param {number} liveEdge - liveEdge value\r\n     * @returns {number} object\r\n     * @memberof PlaybackController#\r\n     */\r\n    function getStreamStartTime(ignoreStartOffset, liveEdge) {\r\n        let presentationStartTime;\r\n        let startTimeOffset = NaN;\r\n\r\n        if (!ignoreStartOffset) {\r\n            const uriParameters = getStartTimeFromUriParameters();\r\n            if (uriParameters) {\r\n                startTimeOffset = !isNaN(uriParameters.fragS) ? uriParameters.fragS : uriParameters.fragT;\r\n            } else {\r\n                startTimeOffset = 0;\r\n            }\r\n        } else {\r\n            startTimeOffset = streamInfo ? streamInfo.start : startTimeOffset;\r\n        }\r\n\r\n        if (isDynamic) {\r\n            if (!isNaN(startTimeOffset) && streamInfo) {\r\n                presentationStartTime = startTimeOffset - (streamInfo.manifestInfo.availableFrom.getTime() / 1000);\r\n\r\n                if (presentationStartTime > liveStartTime ||\r\n                    presentationStartTime < (!isNaN(liveEdge) ? (liveEdge - streamInfo.manifestInfo.DVRWindowSize) : NaN)) {\r\n                    presentationStartTime = null;\r\n                }\r\n            }\r\n            presentationStartTime = presentationStartTime || liveStartTime;\r\n\r\n        } else {\r\n            if (streamInfo) {\r\n                if (!isNaN(startTimeOffset) && startTimeOffset < Math.max(streamInfo.manifestInfo.duration, streamInfo.duration) && startTimeOffset >= 0) {\r\n                    presentationStartTime = startTimeOffset;\r\n                } else {\r\n                    let earliestTime = commonEarliestTime[streamInfo.id]; //set by ready bufferStart after first onBytesAppended\r\n                    presentationStartTime = earliestTime !== undefined ? Math.max(earliestTime.audio !== undefined ? earliestTime.audio : 0, earliestTime.video !== undefined ? earliestTime.video : 0, streamInfo.start) : streamInfo.start;\r\n                }\r\n            }\r\n        }\r\n\r\n        return presentationStartTime;\r\n    }\r\n\r\n    function getActualPresentationTime(currentTime) {\r\n        const metrics = metricsModel.getReadOnlyMetricsFor(Constants.VIDEO) || metricsModel.getReadOnlyMetricsFor(Constants.AUDIO);\r\n        const DVRMetrics = dashMetrics.getCurrentDVRInfo(metrics);\r\n        const DVRWindow = DVRMetrics ? DVRMetrics.range : null;\r\n        let actualTime;\r\n\r\n        if (!DVRWindow) return NaN;\r\n        if (currentTime > DVRWindow.end) {\r\n            actualTime = Math.max(DVRWindow.end - streamInfo.manifestInfo.minBufferTime * 2, DVRWindow.start);\r\n        } else if (currentTime + 0.250 < DVRWindow.start) {\r\n            // Checking currentTime plus 250ms as the 'timeupdate' is fired with a frequency between 4Hz and 66Hz\r\n            // https://developer.mozilla.org/en-US/docs/Web/Events/timeupdate\r\n            // http://w3c.github.io/html/single-page.html#offsets-into-the-media-resource\r\n            actualTime = DVRWindow.start;\r\n        } else {\r\n            return currentTime;\r\n        }\r\n\r\n        return actualTime;\r\n    }\r\n\r\n    function startUpdatingWallclockTime() {\r\n        if (wallclockTimeIntervalId !== null) return;\r\n\r\n        const tick = function () {\r\n            onWallclockTime();\r\n        };\r\n\r\n        wallclockTimeIntervalId = setInterval(tick, mediaPlayerModel.getWallclockTimeUpdateInterval());\r\n    }\r\n\r\n    function stopUpdatingWallclockTime() {\r\n        clearInterval(wallclockTimeIntervalId);\r\n        wallclockTimeIntervalId = null;\r\n    }\r\n\r\n    function updateCurrentTime() {\r\n        if (isPaused() || !isDynamic || videoModel.getReadyState() === 0) return;\r\n        const currentTime = getNormalizedTime();\r\n        const actualTime = getActualPresentationTime(currentTime);\r\n\r\n        const timeChanged = (!isNaN(actualTime) && actualTime !== currentTime);\r\n        if (timeChanged) {\r\n            seek(actualTime);\r\n        }\r\n    }\r\n\r\n    function onDataUpdateCompleted(e) {\r\n        if (e.error) return;\r\n\r\n        const representationInfo = adapter.convertDataToRepresentationInfo(e.currentRepresentation);\r\n        const info = representationInfo.mediaInfo.streamInfo;\r\n\r\n        if (streamInfo.id !== info.id) return;\r\n        streamInfo = info;\r\n\r\n        updateCurrentTime();\r\n    }\r\n\r\n    function onCanPlay() {\r\n        eventBus.trigger(Events.CAN_PLAY);\r\n    }\r\n\r\n    function onPlaybackStart() {\r\n        logger.info('Native video element event: play');\r\n        updateCurrentTime();\r\n        startUpdatingWallclockTime();\r\n        eventBus.trigger(Events.PLAYBACK_STARTED, {\r\n            startTime: getTime()\r\n        });\r\n    }\r\n\r\n    function onPlaybackWaiting() {\r\n        logger.info('Native video element event: waiting');\r\n        eventBus.trigger(Events.PLAYBACK_WAITING, {\r\n            playingTime: getTime()\r\n        });\r\n    }\r\n\r\n    function onPlaybackPlaying() {\r\n        logger.info('Native video element event: playing');\r\n        eventBus.trigger(Events.PLAYBACK_PLAYING, {\r\n            playingTime: getTime()\r\n        });\r\n    }\r\n\r\n    function onPlaybackPaused() {\r\n        logger.info('Native video element event: pause');\r\n        eventBus.trigger(Events.PLAYBACK_PAUSED, {\r\n            ended: getEnded()\r\n        });\r\n    }\r\n\r\n    function onPlaybackSeeking() {\r\n        const seekTime = getTime();\r\n        logger.info('Seeking to: ' + seekTime);\r\n        startUpdatingWallclockTime();\r\n        eventBus.trigger(Events.PLAYBACK_SEEKING, {\r\n            seekTime: seekTime\r\n        });\r\n    }\r\n\r\n    function onPlaybackSeeked() {\r\n        logger.info('Native video element event: seeked');\r\n        eventBus.trigger(Events.PLAYBACK_SEEKED);\r\n        // Reactivate 'seeking' event listener (see seek())\r\n        videoModel.addEventListener('seeking', onPlaybackSeeking);\r\n    }\r\n\r\n    function onPlaybackTimeUpdated() {\r\n        if (streamInfo) {\r\n            eventBus.trigger(Events.PLAYBACK_TIME_UPDATED, {\r\n                timeToEnd: getTimeToStreamEnd(),\r\n                time: getTime()\r\n            });\r\n        }\r\n    }\r\n\r\n    function updateLivePlaybackTime() {\r\n        const now = Date.now();\r\n        if (!lastLivePlaybackTime || now > lastLivePlaybackTime + LIVE_UPDATE_PLAYBACK_TIME_INTERVAL_MS) {\r\n            lastLivePlaybackTime = now;\r\n            onPlaybackTimeUpdated();\r\n        }\r\n    }\r\n\r\n    function onPlaybackProgress() {\r\n        eventBus.trigger(Events.PLAYBACK_PROGRESS);\r\n    }\r\n\r\n    function onPlaybackRateChanged() {\r\n        const rate = getPlaybackRate();\r\n        logger.info('Native video element event: ratechange: ', rate);\r\n        eventBus.trigger(Events.PLAYBACK_RATE_CHANGED, {\r\n            playbackRate: rate\r\n        });\r\n    }\r\n\r\n    function onPlaybackMetaDataLoaded() {\r\n        logger.info('Native video element event: loadedmetadata');\r\n        eventBus.trigger(Events.PLAYBACK_METADATA_LOADED);\r\n        startUpdatingWallclockTime();\r\n    }\r\n\r\n    // Event to handle the native video element ended event\r\n    function onNativePlaybackEnded() {\r\n        logger.info('Native video element event: ended');\r\n        pause();\r\n        stopUpdatingWallclockTime();\r\n        eventBus.trigger(Events.PLAYBACK_ENDED, {'isLast': streamController.getActiveStreamInfo().isLast});\r\n    }\r\n\r\n    // Handle DASH PLAYBACK_ENDED event\r\n    function onPlaybackEnded(e) {\r\n        if (wallclockTimeIntervalId && e.isLast) {\r\n            // PLAYBACK_ENDED was triggered elsewhere, react.\r\n            logger.info('onPlaybackEnded -- PLAYBACK_ENDED but native video element didn\\'t fire ended');\r\n            videoModel.setCurrentTime(getStreamEndTime());\r\n            pause();\r\n            stopUpdatingWallclockTime();\r\n        }\r\n    }\r\n\r\n    function onPlaybackError(event) {\r\n        const target = event.target || event.srcElement;\r\n        eventBus.trigger(Events.PLAYBACK_ERROR, {\r\n            error: target.error\r\n        });\r\n    }\r\n\r\n    function onWallclockTime() {\r\n        eventBus.trigger(Events.WALLCLOCK_TIME_UPDATED, {\r\n            isDynamic: isDynamic,\r\n            time: new Date()\r\n        });\r\n\r\n        // Updates playback time for paused dynamic streams\r\n        // (video element doesn't call timeupdate when the playback is paused)\r\n        if (getIsDynamic() && isPaused()) {\r\n            updateLivePlaybackTime();\r\n        }\r\n    }\r\n\r\n    function checkTimeInRanges(time, ranges) {\r\n        if (ranges && ranges.length > 0) {\r\n            for (let i = 0, len = ranges.length; i < len; i++) {\r\n                if (time >= ranges.start(i) && time < ranges.end(i)) {\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n\r\n    function onPlaybackProgression() {\r\n        if (\r\n            isDynamic &&\r\n            mediaPlayerModel.getLowLatencyEnabled() &&\r\n            mediaPlayerModel.getCatchUpPlaybackRate() > 0 &&\r\n            !isPaused() &&\r\n            !isSeeking()\r\n        ) {\r\n            if (needToCatchUp()) {\r\n                startPlaybackCatchUp();\r\n            } else {\r\n                stopPlaybackCatchUp();\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBufferLevel() {\r\n        let bufferLevel = null;\r\n        streamController.getActiveStreamProcessors().forEach(p => {\r\n            const bl = p.getBufferLevel();\r\n            if (bufferLevel === null) {\r\n                bufferLevel = bl;\r\n            } else {\r\n                bufferLevel = Math.min(bufferLevel, bl);\r\n            }\r\n        });\r\n\r\n        return bufferLevel;\r\n    }\r\n\r\n    function needToCatchUp() {\r\n        return mediaPlayerModel.getCatchUpPlaybackRate() > 0 && getTime() > 0 &&\r\n            Math.abs(getCurrentLiveLatency() - mediaPlayerModel.getLiveDelay()) > mediaPlayerModel.getLowLatencyMinDrift();\r\n    }\r\n\r\n    function startPlaybackCatchUp() {\r\n        if (videoModel) {\r\n            const cpr = mediaPlayerModel.getCatchUpPlaybackRate();\r\n            const liveDelay = mediaPlayerModel.getLiveDelay();\r\n            const deltaLatency = getCurrentLiveLatency() - liveDelay;\r\n            const d = deltaLatency * 5;\r\n            // Playback rate must be between (1 - cpr) - (1 + cpr)\r\n            // ex: if cpr is 0.5, it can have values between 0.5 - 1.5\r\n            const s = (cpr * 2) / (1 + Math.pow(Math.E, -d));\r\n            let newRate = (1 - cpr) + s;\r\n            // take into account situations in which there are buffer stalls,\r\n            // in which increasing playbackRate to reach target latency will\r\n            // just cause more and more stall situations\r\n            if (playbackStalled) {\r\n                const bufferLevel = getBufferLevel();\r\n                if (bufferLevel > liveDelay / 2) {\r\n                    playbackStalled = false;\r\n                } else if (deltaLatency > 0) {\r\n                    newRate = 1.0;\r\n                }\r\n            }\r\n\r\n            // don't change playbackrate for small variations (don't overload element with playbackrate changes)\r\n            if (Math.abs(videoModel.getPlaybackRate() - newRate) > minPlaybackRateChange) {\r\n                videoModel.setPlaybackRate(newRate);\r\n            }\r\n\r\n            if (mediaPlayerModel.getLowLatencyMaxDriftBeforeSeeking() > 0 && !isLowLatencySeekingInProgress &&\r\n                deltaLatency > mediaPlayerModel.getLowLatencyMaxDriftBeforeSeeking()) {\r\n                logger.info('Low Latency catchup mechanism. Latency too high, doing a seek to live point');\r\n                isLowLatencySeekingInProgress = true;\r\n                seekToLive();\r\n            } else {\r\n                isLowLatencySeekingInProgress = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function stopPlaybackCatchUp() {\r\n        if (videoModel) {\r\n            videoModel.setPlaybackRate(1.0);\r\n        }\r\n    }\r\n\r\n    function onBytesAppended(e) {\r\n        let earliestTime,\r\n            initialStartTime;\r\n        let ranges = e.bufferedRanges;\r\n        if (!ranges || !ranges.length) return;\r\n        if (commonEarliestTime[streamInfo.id] && commonEarliestTime[streamInfo.id].started === true) {\r\n            //stream has already been started.\r\n            return;\r\n        }\r\n\r\n        const type = e.sender.getType();\r\n\r\n        if (bufferedRange[streamInfo.id] === undefined) {\r\n            bufferedRange[streamInfo.id] = [];\r\n        }\r\n\r\n        bufferedRange[streamInfo.id][type] = ranges;\r\n\r\n        if (commonEarliestTime[streamInfo.id] === undefined) {\r\n            commonEarliestTime[streamInfo.id] = [];\r\n            commonEarliestTime[streamInfo.id].started = false;\r\n        }\r\n\r\n        if (commonEarliestTime[streamInfo.id][type] === undefined) {\r\n            commonEarliestTime[streamInfo.id][type] = Math.max(ranges.start(0), streamInfo.start);\r\n        }\r\n\r\n        const hasVideoTrack = streamController.isTrackTypePresent(Constants.VIDEO);\r\n        const hasAudioTrack = streamController.isTrackTypePresent(Constants.AUDIO);\r\n\r\n        initialStartTime = getStreamStartTime(false);\r\n        if (hasAudioTrack && hasVideoTrack) {\r\n            //current stream has audio and video contents\r\n            if (!isNaN(commonEarliestTime[streamInfo.id].audio) && !isNaN(commonEarliestTime[streamInfo.id].video)) {\r\n\r\n                if (commonEarliestTime[streamInfo.id].audio < commonEarliestTime[streamInfo.id].video) {\r\n                    // common earliest is video time\r\n                    // check buffered audio range has video time, if ok, we seek, otherwise, we wait some other data\r\n                    earliestTime = commonEarliestTime[streamInfo.id].video > initialStartTime ? commonEarliestTime[streamInfo.id].video : initialStartTime;\r\n                    ranges = bufferedRange[streamInfo.id].audio;\r\n                } else {\r\n                    // common earliest is audio time\r\n                    // check buffered video range has audio time, if ok, we seek, otherwise, we wait some other data\r\n                    earliestTime = commonEarliestTime[streamInfo.id].audio > initialStartTime ? commonEarliestTime[streamInfo.id].audio : initialStartTime;\r\n                    ranges = bufferedRange[streamInfo.id].video;\r\n                }\r\n                if (checkTimeInRanges(earliestTime, ranges)) {\r\n                    if (!isSeeking() && !compatibleWithPreviousStream && earliestTime !== 0) {\r\n                        seek(earliestTime, true, true);\r\n                    }\r\n                    commonEarliestTime[streamInfo.id].started = true;\r\n                }\r\n            }\r\n        } else {\r\n            //current stream has only audio or only video content\r\n            if (commonEarliestTime[streamInfo.id][type]) {\r\n                earliestTime = commonEarliestTime[streamInfo.id][type] > initialStartTime ? commonEarliestTime[streamInfo.id][type] : initialStartTime;\r\n                if (!isSeeking() && !compatibleWithPreviousStream) {\r\n                    seek(earliestTime, false, true);\r\n                }\r\n                commonEarliestTime[streamInfo.id].started = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    function onFragmentLoadProgress(e) {\r\n        // If using fetch and stream mode is not available, readjust live latency so it is 20% higher than segment duration\r\n        if (e.stream === false && mediaPlayerModel.getLowLatencyEnabled() && !isNaN(e.request.duration)) {\r\n            const minDelay = 1.2 * e.request.duration;\r\n            if (minDelay > mediaPlayerModel.getLiveDelay()) {\r\n                logger.warn('Browser does not support fetch API with StreamReader. Increasing live delay to be 20% higher than segment duration:', minDelay.toFixed(2));\r\n                mediaPlayerModel.setLiveDelay(minDelay);\r\n            }\r\n        }\r\n    }\r\n\r\n    function onBufferLevelStateChanged(e) {\r\n        // do not stall playback when get an event from Stream that is not active\r\n        if (e.streamInfo.id !== streamInfo.id) return;\r\n\r\n        if (mediaPlayerModel.getLowLatencyEnabled()) {\r\n            if (e.state === BufferController.BUFFER_EMPTY && !isSeeking()) {\r\n                if (!playbackStalled) {\r\n                    playbackStalled = true;\r\n                    stopPlaybackCatchUp();\r\n                }\r\n            }\r\n        } else {\r\n            videoModel.setStallState(e.mediaType, e.state === BufferController.BUFFER_EMPTY);\r\n        }\r\n    }\r\n\r\n\r\n    function onPlaybackStalled(e) {\r\n        eventBus.trigger(Events.PLAYBACK_STALLED, {\r\n            e: e\r\n        });\r\n    }\r\n\r\n    function addAllListeners() {\r\n        videoModel.addEventListener('canplay', onCanPlay);\r\n        videoModel.addEventListener('play', onPlaybackStart);\r\n        videoModel.addEventListener('waiting', onPlaybackWaiting);\r\n        videoModel.addEventListener('playing', onPlaybackPlaying);\r\n        videoModel.addEventListener('pause', onPlaybackPaused);\r\n        videoModel.addEventListener('error', onPlaybackError);\r\n        videoModel.addEventListener('seeking', onPlaybackSeeking);\r\n        videoModel.addEventListener('seeked', onPlaybackSeeked);\r\n        videoModel.addEventListener('timeupdate', onPlaybackTimeUpdated);\r\n        videoModel.addEventListener('progress', onPlaybackProgress);\r\n        videoModel.addEventListener('ratechange', onPlaybackRateChanged);\r\n        videoModel.addEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\r\n        videoModel.addEventListener('stalled', onPlaybackStalled);\r\n        videoModel.addEventListener('ended', onNativePlaybackEnded);\r\n    }\r\n\r\n    function removeAllListeners() {\r\n        videoModel.removeEventListener('canplay', onCanPlay);\r\n        videoModel.removeEventListener('play', onPlaybackStart);\r\n        videoModel.removeEventListener('waiting', onPlaybackWaiting);\r\n        videoModel.removeEventListener('playing', onPlaybackPlaying);\r\n        videoModel.removeEventListener('pause', onPlaybackPaused);\r\n        videoModel.removeEventListener('error', onPlaybackError);\r\n        videoModel.removeEventListener('seeking', onPlaybackSeeking);\r\n        videoModel.removeEventListener('seeked', onPlaybackSeeked);\r\n        videoModel.removeEventListener('timeupdate', onPlaybackTimeUpdated);\r\n        videoModel.removeEventListener('progress', onPlaybackProgress);\r\n        videoModel.removeEventListener('ratechange', onPlaybackRateChanged);\r\n        videoModel.removeEventListener('loadedmetadata', onPlaybackMetaDataLoaded);\r\n        videoModel.removeEventListener('stalled', onPlaybackStalled);\r\n        videoModel.removeEventListener('ended', onNativePlaybackEnded);\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        setConfig: setConfig,\r\n        getStartTimeFromUriParameters: getStartTimeFromUriParameters,\r\n        getStreamStartTime: getStreamStartTime,\r\n        getTimeToStreamEnd: getTimeToStreamEnd,\r\n        getTime: getTime,\r\n        getNormalizedTime: getNormalizedTime,\r\n        getPlaybackRate: getPlaybackRate,\r\n        getPlayedRanges: getPlayedRanges,\r\n        getEnded: getEnded,\r\n        getIsDynamic: getIsDynamic,\r\n        getStreamController: getStreamController,\r\n        setLiveStartTime: setLiveStartTime,\r\n        getLiveStartTime: getLiveStartTime,\r\n        computeLiveDelay: computeLiveDelay,\r\n        getLiveDelay: getLiveDelay,\r\n        getCurrentLiveLatency: getCurrentLiveLatency,\r\n        play: play,\r\n        isPaused: isPaused,\r\n        pause: pause,\r\n        isSeeking: isSeeking,\r\n        seek: seek,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nPlaybackController.__dashjs_factory_name = 'PlaybackController';\r\nexport default FactoryMaker.getSingletonFactory(PlaybackController);\r\n"]}