{"version":3,"sources":["../../../../../../src/streaming/rules/abr/InsufficientBufferRule.js"],"names":["BufferController","EventBus","Events","FactoryMaker","Debug","SwitchRequest","Constants","InsufficientBufferRule","config","INSUFFICIENT_BUFFER_SAFETY_FACTOR","context","eventBus","getInstance","metricsModel","dashMetrics","instance","logger","bufferStateDict","setup","getLogger","resetInitialSettings","on","PLAYBACK_SEEKING","onPlaybackSeeking","checkConfig","hasOwnProperty","Error","MISSING_CONFIG_ERROR","getMaxIndex","rulesContext","switchRequest","create","mediaType","getMediaType","metrics","getReadOnlyMetricsFor","lastBufferStateVO","BufferState","length","representationInfo","getRepresentationInfo","fragmentDuration","wasFirstBufferLoadedEventTriggered","state","BUFFER_EMPTY","debug","quality","reason","mediaInfo","getMediaInfo","abrController","getAbrController","throughputHistory","getThroughputHistory","bufferLevel","getCurrentBufferLevel","throughput","getAverageThroughput","latency","getAverageLatency","bitrate","getQualityForBitrate","currentBufferState","wasTriggered","firstBufferLoadedEvent","BUFFER_LOADED","reset","off","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"InsufficientBufferRule.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport BufferController from '../../controllers/BufferController';\r\nimport EventBus from '../../../core/EventBus';\r\nimport Events from '../../../core/events/Events';\r\nimport FactoryMaker from '../../../core/FactoryMaker';\r\nimport Debug from '../../../core/Debug';\r\nimport SwitchRequest from '../SwitchRequest';\r\nimport Constants from '../../constants/Constants';\r\n\r\nfunction InsufficientBufferRule(config) {\r\n\r\n    config = config || {};\r\n    const INSUFFICIENT_BUFFER_SAFETY_FACTOR = 0.5;\r\n\r\n    const context = this.context;\r\n\r\n    const eventBus = EventBus(context).getInstance();\r\n    const metricsModel = config.metricsModel;\r\n    const dashMetrics = config.dashMetrics;\r\n\r\n    let instance,\r\n        logger,\r\n        bufferStateDict;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        resetInitialSettings();\r\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\r\n    }\r\n\r\n    function checkConfig() {\r\n        if (!metricsModel || !metricsModel.hasOwnProperty('getReadOnlyMetricsFor') || !dashMetrics || !dashMetrics.hasOwnProperty('getCurrentBufferLevel')) {\r\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\r\n        }\r\n    }\r\n    /*\r\n     * InsufficientBufferRule does not kick in before the first BUFFER_LOADED event happens. This is reset at every seek.\r\n     *\r\n     * If a BUFFER_EMPTY event happens, then InsufficientBufferRule returns switchRequest.quality=0 until BUFFER_LOADED happens.\r\n     *\r\n     * Otherwise InsufficientBufferRule gives a maximum bitrate depending on throughput and bufferLevel such that\r\n     * a whole fragment can be downloaded before the buffer runs out, subject to a conservative safety factor of 0.5.\r\n     * If the bufferLevel is low, then InsufficientBufferRule avoids rebuffering risk.\r\n     * If the bufferLevel is high, then InsufficientBufferRule give a high MaxIndex allowing other rules to take over.\r\n     */\r\n    function getMaxIndex (rulesContext) {\r\n        const switchRequest = SwitchRequest(context).create();\r\n\r\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaType')) {\r\n            return switchRequest;\r\n        }\r\n\r\n        checkConfig();\r\n\r\n        const mediaType = rulesContext.getMediaType();\r\n        const metrics = metricsModel.getReadOnlyMetricsFor(mediaType);\r\n        const lastBufferStateVO = (metrics.BufferState.length > 0) ? metrics.BufferState[metrics.BufferState.length - 1] : null;\r\n        const representationInfo = rulesContext.getRepresentationInfo();\r\n        const fragmentDuration = representationInfo.fragmentDuration;\r\n\r\n        // Don't ask for a bitrate change if there is not info about buffer state or if fragmentDuration is not defined\r\n        if (!lastBufferStateVO || !wasFirstBufferLoadedEventTriggered(mediaType, lastBufferStateVO) || !fragmentDuration) {\r\n            return switchRequest;\r\n        }\r\n\r\n        if (lastBufferStateVO.state === BufferController.BUFFER_EMPTY) {\r\n            logger.debug('Switch to index 0; buffer is empty.');\r\n            switchRequest.quality = 0;\r\n            switchRequest.reason = 'InsufficientBufferRule: Buffer is empty';\r\n        } else {\r\n            const mediaInfo = rulesContext.getMediaInfo();\r\n            const abrController = rulesContext.getAbrController();\r\n            const throughputHistory = abrController.getThroughputHistory();\r\n\r\n            const bufferLevel = dashMetrics.getCurrentBufferLevel(metrics);\r\n            const throughput = throughputHistory.getAverageThroughput(mediaType);\r\n            const latency = throughputHistory.getAverageLatency(mediaType);\r\n            const bitrate = throughput * (bufferLevel / fragmentDuration) * INSUFFICIENT_BUFFER_SAFETY_FACTOR;\r\n\r\n            switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, bitrate, latency);\r\n            switchRequest.reason = 'InsufficientBufferRule: being conservative to avoid immediate rebuffering';\r\n        }\r\n\r\n        return switchRequest;\r\n    }\r\n\r\n    function wasFirstBufferLoadedEventTriggered(mediaType, currentBufferState) {\r\n        bufferStateDict[mediaType] = bufferStateDict[mediaType] || {};\r\n\r\n        let wasTriggered = false;\r\n        if (bufferStateDict[mediaType].firstBufferLoadedEvent) {\r\n            wasTriggered = true;\r\n        } else if (currentBufferState && currentBufferState.state === BufferController.BUFFER_LOADED) {\r\n            bufferStateDict[mediaType].firstBufferLoadedEvent = true;\r\n            wasTriggered = true;\r\n        }\r\n        return wasTriggered;\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        bufferStateDict = {};\r\n    }\r\n\r\n    function onPlaybackSeeking() {\r\n        resetInitialSettings();\r\n    }\r\n\r\n    function reset() {\r\n        resetInitialSettings();\r\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\r\n    }\r\n\r\n    instance = {\r\n        getMaxIndex: getMaxIndex,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nInsufficientBufferRule.__dashjs_factory_name = 'InsufficientBufferRule';\r\nexport default FactoryMaker.getClassFactory(InsufficientBufferRule);\r\n"]}