{"version":3,"sources":["../../../../../../src/streaming/rules/abr/AbandonRequestsRule.js"],"names":["AbandonRequestsRule","config","ABANDON_MULTIPLIER","GRACE_TIME_THRESHOLD","MIN_LENGTH_TO_AVERAGE","context","mediaPlayerModel","metricsModel","dashMetrics","instance","logger","fragmentDict","abandonDict","throughputArray","setup","getInstance","getLogger","reset","setFragmentRequestDict","type","id","storeLastRequestThroughputByType","throughput","push","shouldAbandon","rulesContext","switchRequest","create","SwitchRequest","NO_CHANGE","name","__dashjs_factory_name","hasOwnProperty","mediaInfo","getMediaInfo","mediaType","getMediaType","req","getCurrentRequest","isNaN","index","stableBufferTime","getStableBufferTime","bufferLevel","getCurrentBufferLevel","getReadOnlyMetricsFor","fragmentInfo","firstByteDate","firstByteTime","undefined","getTime","segmentDuration","duration","bytesTotal","bytesLoaded","elapsedTime","Date","Math","round","length","totalSampledValue","reduce","a","b","measuredBandwidthInKbps","estimatedTimeOfDownload","toFixed","getRepresentationInfo","quality","abrController","getAbrController","bytesRemaining","bitrateList","getBitrateList","newQuality","getQualityForBitrate","getBandwidthSafetyFactor","minQuality","getMinAllowedIndexFor","max","estimateOtherBytesTotal","bitrate","getQualityFor","streamInfo","reason","fragmentID","debug","FactoryMaker","getClassFactory"],"mappings":"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","file":"AbandonRequestsRule.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport SwitchRequest from '../SwitchRequest';\r\nimport FactoryMaker from '../../../core/FactoryMaker';\r\nimport Debug from '../../../core/Debug';\r\n\r\nfunction AbandonRequestsRule(config) {\r\n\r\n    config = config || {};\r\n    const ABANDON_MULTIPLIER = 1.8;\r\n    const GRACE_TIME_THRESHOLD = 500;\r\n    const MIN_LENGTH_TO_AVERAGE = 5;\r\n\r\n    const context = this.context;\r\n    const mediaPlayerModel = config.mediaPlayerModel;\r\n    const metricsModel = config.metricsModel;\r\n    const dashMetrics = config.dashMetrics;\r\n\r\n    let instance,\r\n        logger,\r\n        fragmentDict,\r\n        abandonDict,\r\n        throughputArray;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        reset();\r\n    }\r\n\r\n    function setFragmentRequestDict(type, id) {\r\n        fragmentDict[type] = fragmentDict[type] || {};\r\n        fragmentDict[type][id] = fragmentDict[type][id] || {};\r\n    }\r\n\r\n    function storeLastRequestThroughputByType(type, throughput) {\r\n        throughputArray[type] = throughputArray[type] || [];\r\n        throughputArray[type].push(throughput);\r\n    }\r\n\r\n    function shouldAbandon(rulesContext) {\r\n        const switchRequest = SwitchRequest(context).create(SwitchRequest.NO_CHANGE, {name: AbandonRequestsRule.__dashjs_factory_name});\r\n\r\n        if (!rulesContext || !rulesContext.hasOwnProperty('getMediaInfo') || !rulesContext.hasOwnProperty('getMediaType') || !rulesContext.hasOwnProperty('getCurrentRequest') ||\r\n            !rulesContext.hasOwnProperty('getRepresentationInfo') || !rulesContext.hasOwnProperty('getAbrController')) {\r\n            return switchRequest;\r\n        }\r\n\r\n        const mediaInfo = rulesContext.getMediaInfo();\r\n        const mediaType = rulesContext.getMediaType();\r\n        const req = rulesContext.getCurrentRequest();\r\n\r\n        if (!isNaN(req.index)) {\r\n            setFragmentRequestDict(mediaType, req.index);\r\n\r\n            const stableBufferTime = mediaPlayerModel.getStableBufferTime();\r\n            const bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(mediaType));\r\n            if ( bufferLevel > stableBufferTime ) {\r\n                return switchRequest;\r\n            }\r\n\r\n            const fragmentInfo = fragmentDict[mediaType][req.index];\r\n            if (fragmentInfo === null || req.firstByteDate === null || abandonDict.hasOwnProperty(fragmentInfo.id)) {\r\n                return switchRequest;\r\n            }\r\n\r\n            //setup some init info based on first progress event\r\n            if (fragmentInfo.firstByteTime === undefined) {\r\n                throughputArray[mediaType] = [];\r\n                fragmentInfo.firstByteTime = req.firstByteDate.getTime();\r\n                fragmentInfo.segmentDuration = req.duration;\r\n                fragmentInfo.bytesTotal = req.bytesTotal;\r\n                fragmentInfo.id = req.index;\r\n            }\r\n            fragmentInfo.bytesLoaded = req.bytesLoaded;\r\n            fragmentInfo.elapsedTime = new Date().getTime() - fragmentInfo.firstByteTime;\r\n\r\n            if (fragmentInfo.bytesLoaded > 0 && fragmentInfo.elapsedTime > 0) {\r\n                storeLastRequestThroughputByType(mediaType, Math.round(fragmentInfo.bytesLoaded * 8 / fragmentInfo.elapsedTime));\r\n            }\r\n\r\n            if (throughputArray[mediaType].length >= MIN_LENGTH_TO_AVERAGE &&\r\n                fragmentInfo.elapsedTime > GRACE_TIME_THRESHOLD &&\r\n                fragmentInfo.bytesLoaded < fragmentInfo.bytesTotal) {\r\n\r\n                const totalSampledValue = throughputArray[mediaType].reduce((a, b) => a + b, 0);\r\n                fragmentInfo.measuredBandwidthInKbps = Math.round(totalSampledValue / throughputArray[mediaType].length);\r\n                fragmentInfo.estimatedTimeOfDownload = +((fragmentInfo.bytesTotal * 8 / fragmentInfo.measuredBandwidthInKbps) / 1000).toFixed(2);\r\n\r\n                if (fragmentInfo.estimatedTimeOfDownload < fragmentInfo.segmentDuration * ABANDON_MULTIPLIER || rulesContext.getRepresentationInfo().quality === 0 ) {\r\n                    return switchRequest;\r\n                } else if (!abandonDict.hasOwnProperty(fragmentInfo.id)) {\r\n\r\n                    const abrController = rulesContext.getAbrController();\r\n                    const bytesRemaining = fragmentInfo.bytesTotal - fragmentInfo.bytesLoaded;\r\n                    const bitrateList = abrController.getBitrateList(mediaInfo);\r\n                    let newQuality = abrController.getQualityForBitrate(mediaInfo, fragmentInfo.measuredBandwidthInKbps * mediaPlayerModel.getBandwidthSafetyFactor());\r\n                    const minQuality = abrController.getMinAllowedIndexFor(mediaType);\r\n                    newQuality = (minQuality !== undefined) ? Math.max(minQuality, newQuality) : newQuality;\r\n                    const estimateOtherBytesTotal = fragmentInfo.bytesTotal * bitrateList[newQuality].bitrate / bitrateList[abrController.getQualityFor(mediaType, mediaInfo.streamInfo)].bitrate;\r\n\r\n                    if (bytesRemaining > estimateOtherBytesTotal) {\r\n                        switchRequest.quality = newQuality;\r\n                        switchRequest.reason.throughput = fragmentInfo.measuredBandwidthInKbps;\r\n                        switchRequest.reason.fragmentID = fragmentInfo.id;\r\n                        abandonDict[fragmentInfo.id] = fragmentInfo;\r\n                        logger.debug('( ', mediaType, 'frag id',fragmentInfo.id,') is asking to abandon and switch to quality to ', newQuality, ' measured bandwidth was', fragmentInfo.measuredBandwidthInKbps);\r\n                        delete fragmentDict[mediaType][fragmentInfo.id];\r\n                    }\r\n                }\r\n            } else if (fragmentInfo.bytesLoaded === fragmentInfo.bytesTotal) {\r\n                delete fragmentDict[mediaType][fragmentInfo.id];\r\n            }\r\n        }\r\n\r\n        return switchRequest;\r\n    }\r\n\r\n    function reset() {\r\n        fragmentDict = {};\r\n        abandonDict = {};\r\n        throughputArray = [];\r\n    }\r\n\r\n    instance = {\r\n        shouldAbandon: shouldAbandon,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nAbandonRequestsRule.__dashjs_factory_name = 'AbandonRequestsRule';\r\nexport default FactoryMaker.getClassFactory(AbandonRequestsRule);\r\n"]}