{"version":3,"sources":["../../../../../../src/streaming/rules/abr/BolaRule.js"],"names":["MetricsConstants","SwitchRequest","FactoryMaker","HTTPRequest","EventBus","Events","Debug","BOLA_STATE_ONE_BITRATE","BOLA_STATE_STARTUP","BOLA_STATE_STEADY","MINIMUM_BUFFER_S","MINIMUM_BUFFER_PER_BITRATE_LEVEL_S","PLACEHOLDER_BUFFER_DECAY","BolaRule","config","context","dashMetrics","metricsModel","mediaPlayerModel","eventBus","getInstance","instance","logger","bolaStateDict","setup","getLogger","resetInitialSettings","on","BUFFER_EMPTY","onBufferEmpty","PLAYBACK_SEEKING","onPlaybackSeeking","PERIOD_SWITCH_STARTED","onPeriodSwitchStarted","MEDIA_FRAGMENT_LOADED","onMediaFragmentLoaded","METRIC_ADDED","onMetricAdded","QUALITY_CHANGE_REQUESTED","onQualityChangeRequested","FRAGMENT_LOADING_ABANDONED","onFragmentLoadingAbandoned","utilitiesFromBitrates","bitrates","map","b","Math","log","calculateBolaParameters","stableBufferTime","utilities","highestUtilityIndex","reduce","highestIndex","u","uIndex","bufferTime","max","length","gp","Vp","getInitialBolaState","rulesContext","initialState","mediaInfo","getMediaInfo","bitrateList","bandwidth","getStableBufferTime","params","state","lastQuality","clearBolaStateOnSeek","bolaState","placeholderBuffer","mostAdvancedSegmentStart","NaN","lastSegmentWasReplacement","lastSegmentStart","lastSegmentDurationS","lastSegmentRequestTimeMs","lastSegmentFinishTimeMs","checkBolaStateStableBufferTime","mediaType","bufferLevel","getCurrentBufferLevel","getReadOnlyMetricsFor","effectiveBufferLevel","getBolaState","getMediaType","getQualityFromBufferLevel","bitrateCount","quality","score","i","s","isNaN","maxBufferLevelForQuality","minBufferLevelForQuality","qBitrate","qUtility","min","iBitrate","iUtility","level","updatePlaceholderBuffer","nowMs","Date","now","delay","lastCallTimeMs","hasOwnProperty","e","chunk","type","start","duration","checkNewSegment","metric","HTTP_REQUEST","value","MEDIA_SEGMENT_TYPE","trace","trequest","getTime","_tfinish","bufferAtLastSegmentRequest","maxEffectiveBufferForLastSegment","maxPlaceholderBuffer","abrQuality","newQuality","wantEffectiveBufferLevel","getMaxIndex","metrics","scheduleController","getScheduleController","streamInfo","getStreamInfo","abrController","getAbrController","throughputHistory","getThroughputHistory","streamId","id","isDynamic","manifestInfo","useBufferOccupancyABR","switchRequest","create","reason","setTimeToLoadDelay","throughput","getAverageThroughput","safeThroughput","getSafeAverageThroughput","latency","getAverageLatency","getQualityForBitrate","qualityForThroughput","delayS","getTopQualityIndexFor","debug","reset","off","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"BolaRule.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2016, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\n// For a description of the BOLA adaptive bitrate (ABR) algorithm, see http://arxiv.org/abs/1601.06748\r\n\r\nimport MetricsConstants from '../../constants/MetricsConstants';\r\nimport SwitchRequest from '../SwitchRequest';\r\nimport FactoryMaker from '../../../core/FactoryMaker';\r\nimport {HTTPRequest} from '../../vo/metrics/HTTPRequest';\r\nimport EventBus from '../../../core/EventBus';\r\nimport Events from '../../../core/events/Events';\r\nimport Debug from '../../../core/Debug';\r\n\r\n// BOLA_STATE_ONE_BITRATE   : If there is only one bitrate (or initialization failed), always return NO_CHANGE.\r\n// BOLA_STATE_STARTUP       : Set placeholder buffer such that we download fragments at most recently measured throughput.\r\n// BOLA_STATE_STEADY        : Buffer primed, we switch to steady operation.\r\n// TODO: add BOLA_STATE_SEEK and tune BOLA behavior on seeking\r\nconst BOLA_STATE_ONE_BITRATE    = 0;\r\nconst BOLA_STATE_STARTUP        = 1;\r\nconst BOLA_STATE_STEADY         = 2;\r\n\r\nconst MINIMUM_BUFFER_S = 10; // BOLA should never add artificial delays if buffer is less than MINIMUM_BUFFER_S.\r\nconst MINIMUM_BUFFER_PER_BITRATE_LEVEL_S = 2;\r\n// E.g. if there are 5 bitrates, BOLA switches to top bitrate at buffer = 10 + 5 * 2 = 20s.\r\n// If Schedule Controller does not allow buffer to reach that level, it can be achieved through the placeholder buffer level.\r\n\r\nconst PLACEHOLDER_BUFFER_DECAY = 0.99; // Make sure placeholder buffer does not stick around too long.\r\n\r\nfunction BolaRule(config) {\r\n\r\n    config = config || {};\r\n    const context = this.context;\r\n\r\n    const dashMetrics = config.dashMetrics;\r\n    const metricsModel = config.metricsModel;\r\n    const mediaPlayerModel = config.mediaPlayerModel;\r\n    const eventBus = EventBus(context).getInstance();\r\n\r\n    let instance,\r\n        logger,\r\n        bolaStateDict;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        resetInitialSettings();\r\n\r\n        eventBus.on(Events.BUFFER_EMPTY, onBufferEmpty, instance);\r\n        eventBus.on(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\r\n        eventBus.on(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\r\n        eventBus.on(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\r\n        eventBus.on(Events.METRIC_ADDED, onMetricAdded, instance);\r\n        eventBus.on(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\r\n        eventBus.on(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\r\n    }\r\n\r\n    function utilitiesFromBitrates(bitrates) {\r\n        return bitrates.map(b => Math.log(b));\r\n        // no need to worry about offset, utilities will be offset (uniformly) anyway later\r\n    }\r\n\r\n    // NOTE: in live streaming, the real buffer level can drop below minimumBufferS, but bola should not stick to lowest bitrate by using a placeholder buffer level\r\n    function calculateBolaParameters(stableBufferTime, bitrates, utilities) {\r\n        const highestUtilityIndex = utilities.reduce((highestIndex, u, uIndex) => (u > utilities[highestIndex] ? uIndex : highestIndex), 0);\r\n\r\n        if (highestUtilityIndex === 0) {\r\n            // if highestUtilityIndex === 0, then always use lowest bitrate\r\n            return null;\r\n        }\r\n\r\n        const bufferTime = Math.max(stableBufferTime, MINIMUM_BUFFER_S + MINIMUM_BUFFER_PER_BITRATE_LEVEL_S * bitrates.length);\r\n\r\n        // TODO: Investigate if following can be better if utilities are not the default Math.log utilities.\r\n        // If using Math.log utilities, we can choose Vp and gp to always prefer bitrates[0] at minimumBufferS and bitrates[max] at bufferTarget.\r\n        // (Vp * (utility + gp) - bufferLevel) / bitrate has the maxima described when:\r\n        // Vp * (utilities[0] + gp - 1) === minimumBufferS and Vp * (utilities[max] + gp - 1) === bufferTarget\r\n        // giving:\r\n        const gp = (utilities[highestUtilityIndex] - 1) / (bufferTime / MINIMUM_BUFFER_S - 1);\r\n        const Vp = MINIMUM_BUFFER_S / gp;\r\n        // note that expressions for gp and Vp assume utilities[0] === 1, which is true because of normalization\r\n\r\n        return {gp: gp, Vp: Vp};\r\n    }\r\n\r\n    function getInitialBolaState(rulesContext) {\r\n        const initialState = {};\r\n        const mediaInfo = rulesContext.getMediaInfo();\r\n        const bitrates = mediaInfo.bitrateList.map(b => b.bandwidth);\r\n        let utilities = utilitiesFromBitrates(bitrates);\r\n        utilities = utilities.map(u => u - utilities[0] + 1); // normalize\r\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\r\n        const params = calculateBolaParameters(stableBufferTime, bitrates, utilities);\r\n\r\n        if (!params) {\r\n            // only happens when there is only one bitrate level\r\n            initialState.state = BOLA_STATE_ONE_BITRATE;\r\n        } else {\r\n            initialState.state = BOLA_STATE_STARTUP;\r\n\r\n            initialState.bitrates = bitrates;\r\n            initialState.utilities = utilities;\r\n            initialState.stableBufferTime = stableBufferTime;\r\n            initialState.Vp = params.Vp;\r\n            initialState.gp = params.gp;\r\n\r\n            initialState.lastQuality = 0;\r\n            clearBolaStateOnSeek(initialState);\r\n        }\r\n\r\n        return initialState;\r\n    }\r\n\r\n    function clearBolaStateOnSeek(bolaState) {\r\n        bolaState.placeholderBuffer = 0;\r\n        bolaState.mostAdvancedSegmentStart = NaN;\r\n        bolaState.lastSegmentWasReplacement = false;\r\n        bolaState.lastSegmentStart = NaN;\r\n        bolaState.lastSegmentDurationS = NaN;\r\n        bolaState.lastSegmentRequestTimeMs = NaN;\r\n        bolaState.lastSegmentFinishTimeMs = NaN;\r\n    }\r\n\r\n    // If the buffer target is changed (can this happen mid-stream?), then adjust BOLA parameters accordingly.\r\n    function checkBolaStateStableBufferTime(bolaState, mediaType) {\r\n        const stableBufferTime = mediaPlayerModel.getStableBufferTime();\r\n        if (bolaState.stableBufferTime !== stableBufferTime) {\r\n            const params = calculateBolaParameters(stableBufferTime, bolaState.bitrates, bolaState.utilities);\r\n            if (params.Vp !== bolaState.Vp || params.gp !== bolaState.gp) {\r\n                // correct placeholder buffer using two criteria:\r\n                // 1. do not change effective buffer level at effectiveBufferLevel === MINIMUM_BUFFER_S ( === Vp * gp )\r\n                // 2. scale placeholder buffer by Vp subject to offset indicated in 1.\r\n\r\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(mediaType));\r\n                let effectiveBufferLevel = bufferLevel + bolaState.placeholderBuffer;\r\n\r\n                effectiveBufferLevel -= MINIMUM_BUFFER_S;\r\n                effectiveBufferLevel *= params.Vp / bolaState.Vp;\r\n                effectiveBufferLevel += MINIMUM_BUFFER_S;\r\n\r\n                bolaState.stableBufferTime = stableBufferTime;\r\n                bolaState.Vp = params.Vp;\r\n                bolaState.gp = params.gp;\r\n                bolaState.placeholderBuffer = Math.max(0, effectiveBufferLevel - bufferLevel);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getBolaState(rulesContext) {\r\n        const mediaType = rulesContext.getMediaType();\r\n        let bolaState = bolaStateDict[mediaType];\r\n        if (!bolaState) {\r\n            bolaState = getInitialBolaState(rulesContext);\r\n            bolaStateDict[mediaType] = bolaState;\r\n        } else if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\r\n            checkBolaStateStableBufferTime(bolaState, mediaType);\r\n        }\r\n        return bolaState;\r\n    }\r\n\r\n    // The core idea of BOLA.\r\n    function getQualityFromBufferLevel(bolaState, bufferLevel) {\r\n        const bitrateCount = bolaState.bitrates.length;\r\n        let quality = NaN;\r\n        let score = NaN;\r\n        for (let i = 0; i < bitrateCount; ++i) {\r\n            let s = (bolaState.Vp * (bolaState.utilities[i] + bolaState.gp) - bufferLevel) / bolaState.bitrates[i];\r\n            if (isNaN(score) || s >= score) {\r\n                score = s;\r\n                quality = i;\r\n            }\r\n        }\r\n        return quality;\r\n    }\r\n\r\n    // maximum buffer level which prefers to download at quality rather than wait\r\n    function maxBufferLevelForQuality(bolaState, quality) {\r\n        return bolaState.Vp * (bolaState.utilities[quality] + bolaState.gp);\r\n    }\r\n\r\n    // the minimum buffer level that would cause BOLA to choose quality rather than a lower bitrate\r\n    function minBufferLevelForQuality(bolaState, quality) {\r\n        const qBitrate = bolaState.bitrates[quality];\r\n        const qUtility = bolaState.utilities[quality];\r\n\r\n        let min = 0;\r\n        for (let i = quality - 1; i >= 0; --i) {\r\n            // for each bitrate less than bitrates[quality], BOLA should prefer quality (unless other bitrate has higher utility)\r\n            if (bolaState.utilities[i] < bolaState.utilities[quality]) {\r\n                const iBitrate = bolaState.bitrates[i];\r\n                const iUtility = bolaState.utilities[i];\r\n\r\n                const level = bolaState.Vp * (bolaState.gp + (qBitrate * iUtility - iBitrate * qUtility) / (qBitrate - iBitrate));\r\n                min = Math.max(min, level); // we want min to be small but at least level(i) for all i\r\n            }\r\n        }\r\n        return min;\r\n    }\r\n\r\n    /*\r\n     * The placeholder buffer increases the effective buffer that is used to calculate the bitrate.\r\n     * There are two main reasons we might want to increase the placeholder buffer:\r\n     *\r\n     * 1. When a segment finishes downloading, we would expect to get a call on getMaxIndex() regarding the quality for\r\n     *    the next segment. However, there might be a delay before the next call. E.g. when streaming live content, the\r\n     *    next segment might not be available yet. If the call to getMaxIndex() does happens after a delay, we don't\r\n     *    want the delay to change the BOLA decision - we only want to factor download time to decide on bitrate level.\r\n     *\r\n     * 2. It is possible to get a call to getMaxIndex() without having a segment download. The buffer target in dash.js\r\n     *    is different for top-quality segments and lower-quality segments. If getMaxIndex() returns a lower-than-top\r\n     *    quality, then the buffer controller might decide not to download a segment. When dash.js is ready for the next\r\n     *    segment, getMaxIndex() will be called again. We don't want this extra delay to factor in the bitrate decision.\r\n     */\r\n    function updatePlaceholderBuffer(bolaState, mediaType) {\r\n        const nowMs = Date.now();\r\n\r\n        if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\r\n            // compensate for non-bandwidth-derived delays, e.g., live streaming availability, buffer controller\r\n            const delay = 0.001 * (nowMs - bolaState.lastSegmentFinishTimeMs);\r\n            bolaState.placeholderBuffer += Math.max(0, delay);\r\n        } else if (!isNaN(bolaState.lastCallTimeMs)) {\r\n            // no download after last call, compensate for delay between calls\r\n            const delay = 0.001 * (nowMs - bolaState.lastCallTimeMs);\r\n            bolaState.placeholderBuffer += Math.max(0, delay);\r\n        }\r\n\r\n        bolaState.lastCallTimeMs = nowMs;\r\n        bolaState.lastSegmentStart = NaN;\r\n        bolaState.lastSegmentRequestTimeMs = NaN;\r\n        bolaState.lastSegmentFinishTimeMs = NaN;\r\n\r\n        checkBolaStateStableBufferTime(bolaState, mediaType);\r\n    }\r\n\r\n    function onBufferEmpty() {\r\n        // if we rebuffer, we don't want the placeholder buffer to artificially raise BOLA quality\r\n        for (const mediaType in bolaStateDict) {\r\n            if (bolaStateDict.hasOwnProperty(mediaType) && bolaStateDict[mediaType].state === BOLA_STATE_STEADY) {\r\n                bolaStateDict[mediaType].placeholderBuffer = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function onPlaybackSeeking() {\r\n        // TODO: 1. Verify what happens if we seek mid-fragment.\r\n        // TODO: 2. If e.g. we have 10s fragments and seek, we might want to download the first fragment at a lower quality to restart playback quickly.\r\n        for (const mediaType in bolaStateDict) {\r\n            if (bolaStateDict.hasOwnProperty(mediaType)) {\r\n                const bolaState = bolaStateDict[mediaType];\r\n                if (bolaState.state !== BOLA_STATE_ONE_BITRATE) {\r\n                    bolaState.state = BOLA_STATE_STARTUP; // TODO: BOLA_STATE_SEEK?\r\n                    clearBolaStateOnSeek(bolaState);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    function onPeriodSwitchStarted() {\r\n        // TODO: does this have to be handled here?\r\n    }\r\n\r\n    function onMediaFragmentLoaded(e) {\r\n        if (e && e.chunk && e.chunk.mediaInfo) {\r\n            const bolaState = bolaStateDict[e.chunk.mediaInfo.type];\r\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\r\n                const start = e.chunk.start;\r\n                if (isNaN(bolaState.mostAdvancedSegmentStart) || start > bolaState.mostAdvancedSegmentStart) {\r\n                    bolaState.mostAdvancedSegmentStart = start;\r\n                    bolaState.lastSegmentWasReplacement = false;\r\n                } else {\r\n                    bolaState.lastSegmentWasReplacement = true;\r\n                }\r\n\r\n                bolaState.lastSegmentStart = start;\r\n                bolaState.lastSegmentDurationS = e.chunk.duration;\r\n                bolaState.lastQuality = e.chunk.quality;\r\n\r\n                checkNewSegment(bolaState, e.chunk.mediaInfo.type);\r\n            }\r\n        }\r\n    }\r\n\r\n    function onMetricAdded(e) {\r\n        if (e && e.metric === MetricsConstants.HTTP_REQUEST && e.value && e.value.type === HTTPRequest.MEDIA_SEGMENT_TYPE && e.value.trace && e.value.trace.length) {\r\n            const bolaState = bolaStateDict[e.mediaType];\r\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\r\n                bolaState.lastSegmentRequestTimeMs = e.value.trequest.getTime();\r\n                bolaState.lastSegmentFinishTimeMs = e.value._tfinish.getTime();\r\n\r\n                checkNewSegment(bolaState, e.mediaType);\r\n            }\r\n        }\r\n    }\r\n\r\n    /*\r\n     * When a new segment is downloaded, we get two notifications: onMediaFragmentLoaded() and onMetricAdded(). It is\r\n     * possible that the quality for the downloaded segment was lower (not higher) than the quality indicated by BOLA.\r\n     * This might happen because of other rules such as the DroppedFramesRule. When this happens, we trim the\r\n     * placeholder buffer to make BOLA more stable. This mechanism also avoids inflating the buffer when BOLA itself\r\n     * decides not to increase the quality to avoid oscillations.\r\n     *\r\n     * We should also check for replacement segments (fast switching). In this case, a segment is downloaded but does\r\n     * not grow the actual buffer. Fast switching might cause the buffer to deplete, causing BOLA to drop the bitrate.\r\n     * We avoid this by growing the placeholder buffer.\r\n     */\r\n    function checkNewSegment(bolaState, mediaType) {\r\n        if (!isNaN(bolaState.lastSegmentStart) && !isNaN(bolaState.lastSegmentRequestTimeMs) && !isNaN(bolaState.placeholderBuffer)) {\r\n            bolaState.placeholderBuffer *= PLACEHOLDER_BUFFER_DECAY;\r\n\r\n            // Find what maximum buffer corresponding to last segment was, and ensure placeholder is not relatively larger.\r\n            if (!isNaN(bolaState.lastSegmentFinishTimeMs)) {\r\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(mediaType));\r\n                const bufferAtLastSegmentRequest = bufferLevel + 0.001 * (bolaState.lastSegmentFinishTimeMs - bolaState.lastSegmentRequestTimeMs); // estimate\r\n                const maxEffectiveBufferForLastSegment = maxBufferLevelForQuality(bolaState, bolaState.lastQuality);\r\n                const maxPlaceholderBuffer = Math.max(0, maxEffectiveBufferForLastSegment - bufferAtLastSegmentRequest);\r\n                bolaState.placeholderBuffer = Math.min(maxPlaceholderBuffer, bolaState.placeholderBuffer);\r\n            }\r\n\r\n            // then see if we should grow placeholder buffer\r\n\r\n            if (bolaState.lastSegmentWasReplacement && !isNaN(bolaState.lastSegmentDurationS)) {\r\n                // compensate for segments that were downloaded but did not grow the buffer\r\n                bolaState.placeholderBuffer += bolaState.lastSegmentDurationS;\r\n            }\r\n\r\n            bolaState.lastSegmentStart = NaN;\r\n            bolaState.lastSegmentRequestTimeMs = NaN;\r\n        }\r\n    }\r\n\r\n    function onQualityChangeRequested(e) {\r\n        // Useful to store change requests when abandoning a download.\r\n        if (e) {\r\n            const bolaState = bolaStateDict[e.mediaType];\r\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\r\n                bolaState.abrQuality = e.newQuality;\r\n            }\r\n        }\r\n    }\r\n\r\n    function onFragmentLoadingAbandoned(e) {\r\n        if (e) {\r\n            const bolaState = bolaStateDict[e.mediaType];\r\n            if (bolaState && bolaState.state !== BOLA_STATE_ONE_BITRATE) {\r\n                // deflate placeholderBuffer - note that we want to be conservative when abandoning\r\n                const bufferLevel = dashMetrics.getCurrentBufferLevel(metricsModel.getReadOnlyMetricsFor(e.mediaType));\r\n                let wantEffectiveBufferLevel;\r\n                if (bolaState.abrQuality > 0) {\r\n                    // deflate to point where BOLA just chooses newQuality over newQuality-1\r\n                    wantEffectiveBufferLevel = minBufferLevelForQuality(bolaState, bolaState.abrQuality);\r\n                } else {\r\n                    wantEffectiveBufferLevel = MINIMUM_BUFFER_S;\r\n                }\r\n                const maxPlaceholderBuffer = Math.max(0, wantEffectiveBufferLevel - bufferLevel);\r\n                bolaState.placeholderBuffer = Math.min(bolaState.placeholderBuffer, maxPlaceholderBuffer);\r\n            }\r\n        }\r\n    }\r\n\r\n    function getMaxIndex(rulesContext) {\r\n        const mediaInfo = rulesContext.getMediaInfo();\r\n        const mediaType = rulesContext.getMediaType();\r\n        const metrics = metricsModel.getReadOnlyMetricsFor(mediaType);\r\n        const scheduleController = rulesContext.getScheduleController();\r\n        const streamInfo = rulesContext.getStreamInfo();\r\n        const abrController = rulesContext.getAbrController();\r\n        const throughputHistory = abrController.getThroughputHistory();\r\n        const streamId = streamInfo ? streamInfo.id : null;\r\n        const isDynamic = streamInfo && streamInfo.manifestInfo && streamInfo.manifestInfo.isDynamic;\r\n        const useBufferOccupancyABR = rulesContext.useBufferOccupancyABR();\r\n        const switchRequest = SwitchRequest(context).create();\r\n        switchRequest.reason = switchRequest.reason || {};\r\n\r\n        if (!useBufferOccupancyABR) {\r\n            return switchRequest;\r\n        }\r\n\r\n        scheduleController.setTimeToLoadDelay(0);\r\n\r\n        const bolaState = getBolaState(rulesContext);\r\n\r\n        if (bolaState.state === BOLA_STATE_ONE_BITRATE) {\r\n            // shouldn't even have been called\r\n            return switchRequest;\r\n        }\r\n\r\n        const bufferLevel = dashMetrics.getCurrentBufferLevel(metrics);\r\n        const throughput = throughputHistory.getAverageThroughput(mediaType, isDynamic);\r\n        const safeThroughput = throughputHistory.getSafeAverageThroughput(mediaType, isDynamic);\r\n        const latency = throughputHistory.getAverageLatency(mediaType);\r\n        let quality;\r\n\r\n        switchRequest.reason.state = bolaState.state;\r\n        switchRequest.reason.throughput = throughput;\r\n        switchRequest.reason.latency = latency;\r\n\r\n        if (isNaN(throughput)) { // isNaN(throughput) === isNaN(safeThroughput) === isNaN(latency)\r\n            // still starting up - not enough information\r\n            return switchRequest;\r\n        }\r\n\r\n        switch (bolaState.state) {\r\n            case BOLA_STATE_STARTUP:\r\n                quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\r\n\r\n                switchRequest.quality = quality;\r\n                switchRequest.reason.throughput = safeThroughput;\r\n\r\n                bolaState.placeholderBuffer = Math.max(0, minBufferLevelForQuality(bolaState, quality) - bufferLevel);\r\n                bolaState.lastQuality = quality;\r\n\r\n                if (!isNaN(bolaState.lastSegmentDurationS) && bufferLevel >= bolaState.lastSegmentDurationS) {\r\n                    bolaState.state = BOLA_STATE_STEADY;\r\n                }\r\n\r\n                break; // BOLA_STATE_STARTUP\r\n\r\n            case BOLA_STATE_STEADY:\r\n\r\n                // NB: The placeholder buffer is added to bufferLevel to come up with a bitrate.\r\n                //     This might lead BOLA to be too optimistic and to choose a bitrate that would lead to rebuffering -\r\n                //     if the real buffer bufferLevel runs out, the placeholder buffer cannot prevent rebuffering.\r\n                //     However, the InsufficientBufferRule takes care of this scenario.\r\n\r\n                updatePlaceholderBuffer(bolaState, mediaType);\r\n\r\n                quality = getQualityFromBufferLevel(bolaState, bufferLevel + bolaState.placeholderBuffer);\r\n\r\n                // we want to avoid oscillations\r\n                // We implement the \"BOLA-O\" variant: when network bandwidth lies between two encoded bitrate levels, stick to the lowest level.\r\n                const qualityForThroughput = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\r\n                if (quality > bolaState.lastQuality && quality > qualityForThroughput) {\r\n                    // only intervene if we are trying to *increase* quality to an *unsustainable* level\r\n                    // we are only avoid oscillations - do not drop below last quality\r\n\r\n                    quality = Math.max(qualityForThroughput, bolaState.lastQuality);\r\n                }\r\n\r\n                // We do not want to overfill buffer with low quality chunks.\r\n                // Note that there will be no delay if buffer level is below MINIMUM_BUFFER_S, probably even with some margin higher than MINIMUM_BUFFER_S.\r\n                let delayS = Math.max(0, bufferLevel + bolaState.placeholderBuffer - maxBufferLevelForQuality(bolaState, quality));\r\n\r\n                // First reduce placeholder buffer, then tell schedule controller to pause.\r\n                if (delayS <= bolaState.placeholderBuffer) {\r\n                    bolaState.placeholderBuffer -= delayS;\r\n                    delayS = 0;\r\n                } else {\r\n                    delayS -= bolaState.placeholderBuffer;\r\n                    bolaState.placeholderBuffer = 0;\r\n\r\n                    if (quality < abrController.getTopQualityIndexFor(mediaType, streamId)) {\r\n                        // At top quality, allow schedule controller to decide how far to fill buffer.\r\n                        scheduleController.setTimeToLoadDelay(1000 * delayS);\r\n                    } else {\r\n                        delayS = 0;\r\n                    }\r\n                }\r\n\r\n                switchRequest.quality = quality;\r\n                switchRequest.reason.throughput = throughput;\r\n                switchRequest.reason.latency = latency;\r\n                switchRequest.reason.bufferLevel = bufferLevel;\r\n                switchRequest.reason.placeholderBuffer = bolaState.placeholderBuffer;\r\n                switchRequest.reason.delay = delayS;\r\n\r\n                bolaState.lastQuality = quality;\r\n                // keep bolaState.state === BOLA_STATE_STEADY\r\n\r\n                break; // BOLA_STATE_STEADY\r\n\r\n            default:\r\n                logger.debug('BOLA ABR rule invoked in bad state.');\r\n                // should not arrive here, try to recover\r\n                switchRequest.quality = abrController.getQualityForBitrate(mediaInfo, safeThroughput, latency);\r\n                switchRequest.reason.state = bolaState.state;\r\n                switchRequest.reason.throughput = safeThroughput;\r\n                switchRequest.reason.latency = latency;\r\n                bolaState.state = BOLA_STATE_STARTUP;\r\n                clearBolaStateOnSeek(bolaState);\r\n        }\r\n\r\n        return switchRequest;\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        bolaStateDict = {};\r\n    }\r\n\r\n    function reset() {\r\n        resetInitialSettings();\r\n\r\n        eventBus.off(Events.BUFFER_EMPTY, onBufferEmpty, instance);\r\n        eventBus.off(Events.PLAYBACK_SEEKING, onPlaybackSeeking, instance);\r\n        eventBus.off(Events.PERIOD_SWITCH_STARTED, onPeriodSwitchStarted, instance);\r\n        eventBus.off(Events.MEDIA_FRAGMENT_LOADED, onMediaFragmentLoaded, instance);\r\n        eventBus.off(Events.METRIC_ADDED, onMetricAdded, instance);\r\n        eventBus.off(Events.QUALITY_CHANGE_REQUESTED, onQualityChangeRequested, instance);\r\n        eventBus.off(Events.FRAGMENT_LOADING_ABANDONED, onFragmentLoadingAbandoned, instance);\r\n    }\r\n\r\n    instance = {\r\n        getMaxIndex: getMaxIndex,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n    return instance;\r\n}\r\n\r\nBolaRule.__dashjs_factory_name = 'BolaRule';\r\nexport default FactoryMaker.getClassFactory(BolaRule);\r\n"]}