{"version":3,"sources":["../../../../../src/streaming/rules/ThroughputHistory.js"],"names":["Constants","FactoryMaker","ThroughputHistory","config","MAX_MEASUREMENTS_TO_KEEP","AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE","AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD","AVERAGE_LATENCY_SAMPLE_AMOUNT","THROUGHPUT_DECREASE_SCALE","THROUGHPUT_INCREASE_SCALE","EWMA_THROUGHPUT_SLOW_HALF_LIFE_SECONDS","EWMA_THROUGHPUT_FAST_HALF_LIFE_SECONDS","EWMA_LATENCY_SLOW_HALF_LIFE_COUNT","EWMA_LATENCY_FAST_HALF_LIFE_COUNT","mediaPlayerModel","throughputDict","latencyDict","ewmaThroughputDict","ewmaLatencyDict","ewmaHalfLife","setup","throughputHalfLife","fast","slow","latencyHalfLife","reset","isCachedResponse","mediaType","latencyMs","downloadTimeMs","VIDEO","getCacheLoadThresholdForType","AUDIO","push","httpRequest","useDeadTimeLatency","trace","length","latencyTimeInMilliseconds","tresponse","getTime","trequest","downloadTimeInMilliseconds","_tfinish","downloadBytes","reduce","a","b","throughputMeasureTime","getLowLatencyEnabled","d","throughput","Math","round","checkSettingsForMediaType","hasCachedEntries","clearSettingsForMediaType","shift","updateEwmaEstimate","ewmaObj","value","weight","halfLife","fastAlpha","pow","fastEstimate","slowAlpha","slowEstimate","totalWeight","getSampleSize","isThroughput","isLive","arr","sampleSize","i","ratio","getAverage","isDynamic","getMovingAverageMethod","MOVING_AVERAGE_SLIDING_WINDOW","getAverageEwma","getAverageSlidingWindow","dict","NaN","slice","total","elem","min","max","getAverageThroughput","getSafeAverageThroughput","average","isNaN","getBandwidthSafetyFactor","getAverageLatency","instance","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"ThroughputHistory.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2017, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nimport Constants from '../constants/Constants';\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\n\r\n// throughput generally stored in kbit/s\r\n// latency generally stored in ms\r\n\r\nfunction ThroughputHistory(config) {\r\n\r\n    config = config || {};\r\n    // sliding window constants\r\n    const MAX_MEASUREMENTS_TO_KEEP = 20;\r\n    const AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE = 3;\r\n    const AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD = 4;\r\n    const AVERAGE_LATENCY_SAMPLE_AMOUNT = 4;\r\n    const THROUGHPUT_DECREASE_SCALE = 1.3;\r\n    const THROUGHPUT_INCREASE_SCALE = 1.3;\r\n\r\n    // EWMA constants\r\n    const EWMA_THROUGHPUT_SLOW_HALF_LIFE_SECONDS = 8;\r\n    const EWMA_THROUGHPUT_FAST_HALF_LIFE_SECONDS = 3;\r\n    const EWMA_LATENCY_SLOW_HALF_LIFE_COUNT = 2;\r\n    const EWMA_LATENCY_FAST_HALF_LIFE_COUNT = 1;\r\n\r\n    const mediaPlayerModel = config.mediaPlayerModel;\r\n\r\n    let throughputDict,\r\n        latencyDict,\r\n        ewmaThroughputDict,\r\n        ewmaLatencyDict,\r\n        ewmaHalfLife;\r\n\r\n    function setup() {\r\n        ewmaHalfLife = {\r\n            throughputHalfLife: { fast: EWMA_THROUGHPUT_FAST_HALF_LIFE_SECONDS, slow: EWMA_THROUGHPUT_SLOW_HALF_LIFE_SECONDS },\r\n            latencyHalfLife:    { fast: EWMA_LATENCY_FAST_HALF_LIFE_COUNT,      slow: EWMA_LATENCY_SLOW_HALF_LIFE_COUNT }\r\n        };\r\n\r\n        reset();\r\n    }\r\n\r\n    function isCachedResponse(mediaType, latencyMs, downloadTimeMs) {\r\n        if (mediaType === Constants.VIDEO) {\r\n            return downloadTimeMs < mediaPlayerModel.getCacheLoadThresholdForType(Constants.VIDEO);\r\n        } else if (mediaType === Constants.AUDIO) {\r\n            return downloadTimeMs < mediaPlayerModel.getCacheLoadThresholdForType(Constants.AUDIO);\r\n        }\r\n    }\r\n\r\n    function push(mediaType, httpRequest, useDeadTimeLatency) {\r\n        if (!httpRequest.trace || !httpRequest.trace.length) {\r\n            return;\r\n        }\r\n\r\n        const latencyTimeInMilliseconds = (httpRequest.tresponse.getTime() - httpRequest.trequest.getTime()) || 1;\r\n        const downloadTimeInMilliseconds = (httpRequest._tfinish.getTime() - httpRequest.tresponse.getTime()) || 1; //Make sure never 0 we divide by this value. Avoid infinity!\r\n        const downloadBytes = httpRequest.trace.reduce((a, b) => a + b.b[0], 0);\r\n\r\n        let throughputMeasureTime;\r\n        if (mediaPlayerModel.getLowLatencyEnabled()) {\r\n            throughputMeasureTime = httpRequest.trace.reduce((a, b) => a + b.d, 0);\r\n        } else {\r\n            throughputMeasureTime = useDeadTimeLatency ? downloadTimeInMilliseconds : latencyTimeInMilliseconds + downloadTimeInMilliseconds;\r\n        }\r\n\r\n        const throughput = Math.round((8 * downloadBytes) / throughputMeasureTime); // bits/ms = kbits/s\r\n\r\n        checkSettingsForMediaType(mediaType);\r\n\r\n        if (isCachedResponse(mediaType, latencyTimeInMilliseconds, downloadTimeInMilliseconds)) {\r\n            if (throughputDict[mediaType].length > 0 && !throughputDict[mediaType].hasCachedEntries) {\r\n                // already have some entries which are not cached entries\r\n                // prevent cached fragment loads from skewing the average values\r\n                return;\r\n            } else { // have no entries || have cached entries\r\n                // no uncached entries yet, rely on cached entries because ABR rules need something to go by\r\n                throughputDict[mediaType].hasCachedEntries = true;\r\n            }\r\n        } else if (throughputDict[mediaType] && throughputDict[mediaType].hasCachedEntries) {\r\n            // if we are here then we have some entries already, but they are cached, and now we have a new uncached entry\r\n            clearSettingsForMediaType(mediaType);\r\n        }\r\n\r\n        throughputDict[mediaType].push(throughput);\r\n        if (throughputDict[mediaType].length > MAX_MEASUREMENTS_TO_KEEP) {\r\n            throughputDict[mediaType].shift();\r\n        }\r\n\r\n        latencyDict[mediaType].push(latencyTimeInMilliseconds);\r\n        if (latencyDict[mediaType].length > MAX_MEASUREMENTS_TO_KEEP) {\r\n            latencyDict[mediaType].shift();\r\n        }\r\n\r\n        updateEwmaEstimate(ewmaThroughputDict[mediaType], throughput, 0.001 * downloadTimeInMilliseconds, ewmaHalfLife.throughputHalfLife);\r\n        updateEwmaEstimate(ewmaLatencyDict[mediaType], latencyTimeInMilliseconds, 1, ewmaHalfLife.latencyHalfLife);\r\n    }\r\n\r\n    function updateEwmaEstimate(ewmaObj, value, weight, halfLife) {\r\n        // Note about startup:\r\n        // Estimates start at 0, so early values are underestimated.\r\n        // This effect is countered in getAverageEwma() by dividing the estimates by:\r\n        //     1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife)\r\n\r\n        const fastAlpha = Math.pow(0.5, weight / halfLife.fast);\r\n        ewmaObj.fastEstimate = (1 - fastAlpha) * value + fastAlpha * ewmaObj.fastEstimate;\r\n\r\n        const slowAlpha = Math.pow(0.5, weight / halfLife.slow);\r\n        ewmaObj.slowEstimate = (1 - slowAlpha) * value + slowAlpha * ewmaObj.slowEstimate;\r\n\r\n        ewmaObj.totalWeight += weight;\r\n    }\r\n\r\n    function getSampleSize(isThroughput, mediaType, isLive) {\r\n        let arr,\r\n            sampleSize;\r\n\r\n        if (isThroughput) {\r\n            arr = throughputDict[mediaType];\r\n            sampleSize = isLive ? AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_LIVE : AVERAGE_THROUGHPUT_SAMPLE_AMOUNT_VOD;\r\n        } else {\r\n            arr = latencyDict[mediaType];\r\n            sampleSize = AVERAGE_LATENCY_SAMPLE_AMOUNT;\r\n        }\r\n\r\n        if (!arr) {\r\n            sampleSize = 0;\r\n        } else if (sampleSize >= arr.length) {\r\n            sampleSize = arr.length;\r\n        } else if (isThroughput) {\r\n            // if throughput samples vary a lot, average over a wider sample\r\n            for (let i = 1; i < sampleSize; ++i) {\r\n                const ratio = arr[i] / arr[i - 1];\r\n                if (ratio >= THROUGHPUT_INCREASE_SCALE || ratio <= 1 / THROUGHPUT_DECREASE_SCALE) {\r\n                    sampleSize += 1;\r\n                    if (sampleSize === arr.length) { // cannot increase sampleSize beyond arr.length\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        return sampleSize;\r\n    }\r\n\r\n    function getAverage(isThroughput, mediaType, isDynamic) {\r\n        // only two moving average methods defined at the moment\r\n        return mediaPlayerModel.getMovingAverageMethod() !== Constants.MOVING_AVERAGE_SLIDING_WINDOW ?\r\n            getAverageEwma(isThroughput, mediaType) : getAverageSlidingWindow(isThroughput, mediaType, isDynamic);\r\n    }\r\n\r\n    function getAverageSlidingWindow(isThroughput, mediaType, isDynamic) {\r\n        const sampleSize = getSampleSize(isThroughput, mediaType, isDynamic);\r\n        const dict = isThroughput ? throughputDict : latencyDict;\r\n        let arr = dict[mediaType];\r\n\r\n        if (sampleSize === 0 || !arr || arr.length === 0) {\r\n            return NaN;\r\n        }\r\n\r\n        arr = arr.slice(-sampleSize); // still works if sampleSize too large\r\n        // arr.length >= 1\r\n        return arr.reduce((total, elem) => total + elem) / arr.length;\r\n    }\r\n\r\n    function getAverageEwma(isThroughput, mediaType) {\r\n        const halfLife = isThroughput ? ewmaHalfLife.throughputHalfLife : ewmaHalfLife.latencyHalfLife;\r\n        const ewmaObj = isThroughput ? ewmaThroughputDict[mediaType] : ewmaLatencyDict[mediaType];\r\n\r\n        if (!ewmaObj || ewmaObj.totalWeight <= 0) {\r\n            return NaN;\r\n        }\r\n\r\n        // to correct for startup, divide by zero factor = 1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife)\r\n        const fastEstimate = ewmaObj.fastEstimate / (1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife.fast));\r\n        const slowEstimate = ewmaObj.slowEstimate / (1 - Math.pow(0.5, ewmaObj.totalWeight / halfLife.slow));\r\n        return isThroughput ? Math.min(fastEstimate, slowEstimate) : Math.max(fastEstimate, slowEstimate);\r\n    }\r\n\r\n    function getAverageThroughput(mediaType, isDynamic) {\r\n        return getAverage(true, mediaType, isDynamic);\r\n    }\r\n\r\n    function getSafeAverageThroughput(mediaType, isDynamic) {\r\n        let average = getAverageThroughput(mediaType, isDynamic);\r\n        if (!isNaN(average)) {\r\n            average *= mediaPlayerModel.getBandwidthSafetyFactor();\r\n        }\r\n        return average;\r\n    }\r\n\r\n    function getAverageLatency(mediaType) {\r\n        return getAverage(false, mediaType);\r\n    }\r\n\r\n    function checkSettingsForMediaType(mediaType) {\r\n        throughputDict[mediaType] = throughputDict[mediaType] || [];\r\n        latencyDict[mediaType] = latencyDict[mediaType] || [];\r\n        ewmaThroughputDict[mediaType] = ewmaThroughputDict[mediaType] || {fastEstimate: 0, slowEstimate: 0, totalWeight: 0};\r\n        ewmaLatencyDict[mediaType] = ewmaLatencyDict[mediaType] || {fastEstimate: 0, slowEstimate: 0, totalWeight: 0};\r\n    }\r\n\r\n    function clearSettingsForMediaType(mediaType) {\r\n        delete throughputDict[mediaType];\r\n        delete latencyDict[mediaType];\r\n        delete ewmaThroughputDict[mediaType];\r\n        delete ewmaLatencyDict[mediaType];\r\n        checkSettingsForMediaType(mediaType);\r\n    }\r\n\r\n    function reset() {\r\n        throughputDict = {};\r\n        latencyDict = {};\r\n        ewmaThroughputDict = {};\r\n        ewmaLatencyDict = {};\r\n    }\r\n\r\n    const instance = {\r\n        push: push,\r\n        getAverageThroughput: getAverageThroughput,\r\n        getSafeAverageThroughput: getSafeAverageThroughput,\r\n        getAverageLatency: getAverageLatency,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n    return instance;\r\n}\r\n\r\nThroughputHistory.__dashjs_factory_name = 'ThroughputHistory';\r\nexport default FactoryMaker.getClassFactory(ThroughputHistory);\r\n"]}