{"version":3,"sources":["../../../../src/streaming/Stream.js"],"names":["Stream","config","context","eventBus","getInstance","manifestModel","dashManifestModel","mediaPlayerModel","manifestUpdater","adapter","capabilities","errHandler","timelineConverter","metricsModel","abrController","playbackController","mediaController","textController","videoModel","instance","logger","streamProcessors","isStreamActivated","isMediaInitialized","streamInfo","updateError","isUpdating","protectionController","fragmentController","thumbnailController","eventController","preloaded","trackChangedEvent","codecCompatibilityTable","setup","getLogger","resetInitialSettings","create","registerEvents","on","Events","BUFFERING_COMPLETED","onBufferingCompleted","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","LIVE_STREAM_COMPLETED","onLiveStreamCompleted","unRegisterEvents","off","registerProtectionEvents","KEY_ERROR","onProtectionError","SERVER_CERTIFICATE_UPDATED","LICENSE_REQUEST_COMPLETE","KEY_SYSTEM_SELECTED","KEY_SESSION_CREATED","KEY_STATUSES_CHANGED","unRegisterProtectionEvents","initialize","StreamInfo","ProtectionController","activate","mediaSource","previousBuffers","result","CURRENT_TRACK_CHANGED","onCurrentTrackChanged","getPreloaded","initializeMedia","initializeAfterPreload","deactivate","keepBuffers","ln","length","errored","i","fragmentModel","getFragmentModel","removeExecutedRequestsBeforeTime","getStartTime","getDuration","reset","setPreloaded","isActive","setMediaSource","isMediaSupported","getMediaInfo","splice","dischargePreBuffer","msg","manifestError","getValue","error","DashJSError","Errors","MANIFEST_ERROR_ID_NOSTREAMS_CODE","fatal","stopEventController","pause","duration","NaN","start","getId","id","getStreamInfo","getFragmentController","getThumbnailController","checkConfig","hasOwnProperty","Error","Constants","MISSING_CONFIG_ERROR","getBitrateListFor","type","IMAGE","getBitrateList","mediaInfo","startEventController","stop","event","mediaKeySessionError","message","codec","MUXED","MANIFEST_ERROR_ID_MULTIPLEXED_CODE","TEXT","FRAGMENTED_TEXT","EMBEDDED_TEXT","debug","contentProtection","supportsEncryptedMedia","capabilityError","CAPABILITY_MEDIAKEYS_ERROR_CODE","CAPABILITY_MEDIAKEYS_ERROR_MESSAGE","supportsCodec","e","newMediaInfo","processor","getProcessorForMediaInfo","currentTime","getTime","info","manifest","setCurrentMediaInfo","refreshManifestOnSwitchTrack","refreshManifest","selectMediaInfo","updateTopQualityIndex","switchTrackAsked","abortRequests","getScheduleController","setSeekTarget","setIndexHandlerTime","resetIndexHandler","createStreamProcessor","allMediaForType","optionalSettings","streamProcessor","mimeType","dashMetrics","baseURLController","stream","domStorage","streamController","setBuffer","buffer","getIndexHandler","setCurrentTime","replaceIdx","push","ignoreMediaInfo","idx","index","addMediaInfo","initializeMediaForType","getAllMediaInfoForType","initialMediaInfo","addEmbeddedTrack","addTrack","getTracksFor","getTextDefaultEnabled","checkInitialMediaSettingsForType","getCurrentTrackFor","initializeEventController","setConfig","addInlineEvents","events","getEventsFor","addInbandEvents","element","getElement","filterCodecs","VIDEO","AUDIO","test","nodeName","buffers","createBuffers","checkIfInitializationCompleted","realAdaptation","getAdaptationForType","Array","isArray","Representation_asArray","filter","_","getCodec","hasError","audio","video","DATA_UPDATE_FAILED_ERROR_CODE","DATA_UPDATE_FAILED_ERROR_MESSAGE","getType","initializeForMedia","trigger","STREAM_INITIALIZED","createBuffer","getBuffer","processors","getProcessors","warn","isBufferingCompleted","STREAM_BUFFERING_COMPLETED","sp","sender","getStreamProcessor","liveStreamCompleted","arr","updateData","updatedStreamInfo","getMediaInfoForType","oldMediaInfo","undefined","isMediaCodecCompatible","compareCodecs","isProtectionCompatible","compareProtectionConfig","newStreamInfo","currentStreamInfo","newAdaptation","currentAdaptation","ContentProtection","sameMimeType","oldCodecs","map","representation","codecs","newCodecs","codecMatch","some","newCodec","indexOf","partialCodecMatch","oldCodec","codecRootCompatibleWithCodec","codec1","codec2","codecRoot","split","rootCompatible","compatTableCodec","compatibleCodecs","compatibleCodec","value","preload","__dashjs_factory_name","FactoryMaker","getClassFactory"],"mappings":"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","file":"Stream.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport Constants from './constants/Constants';\r\nimport StreamProcessor from './StreamProcessor';\r\nimport EventController from './controllers/EventController';\r\nimport FragmentController from './controllers/FragmentController';\r\nimport ThumbnailController from './thumbnail/ThumbnailController';\r\nimport EventBus from '../core/EventBus';\r\nimport Events from '../core/events/Events';\r\nimport Debug from '../core/Debug';\r\nimport Errors from '../core/errors/Errors';\r\nimport FactoryMaker from '../core/FactoryMaker';\r\nimport DashJSError from './vo/DashJSError';\r\n\r\nfunction Stream(config) {\r\n\r\n    config = config || {};\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n\r\n    const manifestModel = config.manifestModel;\r\n    const dashManifestModel = config.dashManifestModel;\r\n    const mediaPlayerModel = config.mediaPlayerModel;\r\n    const manifestUpdater = config.manifestUpdater;\r\n    const adapter = config.adapter;\r\n    const capabilities = config.capabilities;\r\n    const errHandler = config.errHandler;\r\n    const timelineConverter = config.timelineConverter;\r\n    const metricsModel = config.metricsModel;\r\n    const abrController = config.abrController;\r\n    const playbackController = config.playbackController;\r\n    const mediaController = config.mediaController;\r\n    const textController = config.textController;\r\n    const videoModel = config.videoModel;\r\n\r\n    let instance,\r\n        logger,\r\n        streamProcessors,\r\n        isStreamActivated,\r\n        isMediaInitialized,\r\n        streamInfo,\r\n        updateError,\r\n        isUpdating,\r\n        protectionController,\r\n        fragmentController,\r\n        thumbnailController,\r\n        eventController,\r\n        preloaded,\r\n        trackChangedEvent;\r\n\r\n    const codecCompatibilityTable = [\r\n        {\r\n            'codec': 'avc1',\r\n            'compatibleCodecs': ['avc3']\r\n        },\r\n        {\r\n            'codec': 'avc3',\r\n            'compatibleCodecs': ['avc1']\r\n        }\r\n    ];\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        resetInitialSettings();\r\n\r\n        fragmentController = FragmentController(context).create({\r\n            mediaPlayerModel: mediaPlayerModel,\r\n            metricsModel: metricsModel,\r\n            errHandler: errHandler\r\n        });\r\n\r\n        registerEvents();\r\n    }\r\n\r\n    function registerEvents() {\r\n        eventBus.on(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\r\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\r\n        eventBus.on(Events.LIVE_STREAM_COMPLETED, onLiveStreamCompleted, instance);\r\n    }\r\n\r\n    function unRegisterEvents() {\r\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, instance);\r\n        eventBus.off(Events.BUFFERING_COMPLETED, onBufferingCompleted, instance);\r\n        eventBus.off(Events.LIVE_STREAM_COMPLETED, onLiveStreamCompleted, instance);\r\n    }\r\n\r\n    function registerProtectionEvents() {\r\n        if (protectionController) {\r\n            eventBus.on(Events.KEY_ERROR, onProtectionError, instance);\r\n            eventBus.on(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\r\n            eventBus.on(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\r\n            eventBus.on(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\r\n            eventBus.on(Events.KEY_SESSION_CREATED, onProtectionError, instance);\r\n            eventBus.on(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\r\n        }\r\n    }\r\n\r\n    function unRegisterProtectionEvents() {\r\n        if (protectionController) {\r\n            eventBus.off(Events.KEY_ERROR, onProtectionError, instance);\r\n            eventBus.off(Events.SERVER_CERTIFICATE_UPDATED, onProtectionError, instance);\r\n            eventBus.off(Events.LICENSE_REQUEST_COMPLETE, onProtectionError, instance);\r\n            eventBus.off(Events.KEY_SYSTEM_SELECTED, onProtectionError, instance);\r\n            eventBus.off(Events.KEY_SESSION_CREATED, onProtectionError, instance);\r\n            eventBus.off(Events.KEY_STATUSES_CHANGED, onProtectionError, instance);\r\n        }\r\n    }\r\n\r\n    function initialize(StreamInfo, ProtectionController) {\r\n        streamInfo = StreamInfo;\r\n        protectionController = ProtectionController;\r\n        registerProtectionEvents();\r\n    }\r\n\r\n    /**\r\n     * Activates Stream by re-initializing some of its components\r\n     * @param {MediaSource} mediaSource\r\n     * @memberof Stream#\r\n     * @param {SourceBuffer} previousBuffers\r\n     */\r\n    function activate(mediaSource, previousBuffers) {\r\n        if (!isStreamActivated) {\r\n            let result;\r\n            eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\r\n            if (!getPreloaded()) {\r\n                result = initializeMedia(mediaSource, previousBuffers);\r\n            } else {\r\n                initializeAfterPreload();\r\n                result = previousBuffers;\r\n            }\r\n            isStreamActivated = true;\r\n            return result;\r\n        }\r\n        return previousBuffers;\r\n    }\r\n\r\n    /**\r\n     * Partially resets some of the Stream elements\r\n     * @memberof Stream#\r\n     * @param {boolean} keepBuffers\r\n     */\r\n    function deactivate(keepBuffers) {\r\n        let ln = streamProcessors ? streamProcessors.length : 0;\r\n        const errored = false;\r\n        for (let i = 0; i < ln; i++) {\r\n            let fragmentModel = streamProcessors[i].getFragmentModel();\r\n            fragmentModel.removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\r\n            streamProcessors[i].reset(errored, keepBuffers);\r\n        }\r\n        streamProcessors = [];\r\n        isStreamActivated = false;\r\n        isMediaInitialized = false;\r\n        setPreloaded(false);\r\n        eventBus.off(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\r\n    }\r\n\r\n    function isActive() {\r\n        return isStreamActivated;\r\n    }\r\n\r\n    function setMediaSource(mediaSource) {\r\n        for (let i = 0; i < streamProcessors.length;) {\r\n            if (isMediaSupported(streamProcessors[i].getMediaInfo())) {\r\n                streamProcessors[i].setMediaSource(mediaSource);\r\n                i++;\r\n            } else {\r\n                streamProcessors[i].reset();\r\n                streamProcessors.splice(i,1);\r\n            }\r\n        }\r\n\r\n        for (let i = 0; i < streamProcessors.length; i++) {\r\n            //Adding of new tracks to a stream processor isn't guaranteed by the spec after the METADATA_LOADED state\r\n            //so do this after the buffers are created above.\r\n            streamProcessors[i].dischargePreBuffer();\r\n        }\r\n\r\n        if (streamProcessors.length === 0) {\r\n            let msg = 'No streams to play.';\r\n            errHandler.manifestError(msg, 'nostreams', manifestModel.getValue());\r\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg +  'nostreams', manifestModel.getValue()));\r\n            logger.fatal(msg);\r\n        }\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        deactivate();\r\n        streamInfo = null;\r\n        updateError = {};\r\n        isUpdating = false;\r\n    }\r\n\r\n    function reset() {\r\n\r\n        stopEventController();\r\n\r\n        if (playbackController) {\r\n            playbackController.pause();\r\n        }\r\n\r\n        if (fragmentController) {\r\n            fragmentController.reset();\r\n            fragmentController = null;\r\n        }\r\n\r\n        resetInitialSettings();\r\n\r\n        unRegisterEvents();\r\n\r\n        unRegisterProtectionEvents();\r\n\r\n        setPreloaded(false);\r\n    }\r\n\r\n    function getDuration() {\r\n        return streamInfo ? streamInfo.duration : NaN;\r\n    }\r\n\r\n    function getStartTime() {\r\n        return streamInfo ? streamInfo.start : NaN;\r\n    }\r\n\r\n    function getId() {\r\n        return streamInfo ? streamInfo.id : null;\r\n    }\r\n\r\n    function getStreamInfo() {\r\n        return streamInfo;\r\n    }\r\n\r\n    function getFragmentController() {\r\n        return fragmentController;\r\n    }\r\n\r\n    function getThumbnailController() {\r\n        return thumbnailController;\r\n    }\r\n\r\n    function checkConfig() {\r\n        if (!abrController || !abrController.hasOwnProperty('getBitrateList') || !adapter || !adapter.hasOwnProperty('getAllMediaInfoForType') || !adapter.hasOwnProperty('getEventsFor')) {\r\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @param {string} type\r\n     * @returns {Array}\r\n     * @memberof Stream#\r\n     */\r\n    function getBitrateListFor(type) {\r\n        checkConfig();\r\n        if (type === Constants.IMAGE) {\r\n            if (!thumbnailController) {\r\n                return [];\r\n            }\r\n            return thumbnailController.getBitrateList();\r\n        }\r\n        const mediaInfo = getMediaInfo(type);\r\n        return abrController.getBitrateList(mediaInfo);\r\n    }\r\n\r\n    function startEventController() {\r\n        if (eventController) {\r\n            eventController.start();\r\n        }\r\n    }\r\n\r\n    function stopEventController() {\r\n        if (eventController) {\r\n            eventController.stop();\r\n        }\r\n    }\r\n\r\n    function onProtectionError(event) {\r\n        if (event.error) {\r\n            errHandler.mediaKeySessionError(event.error.message);\r\n            errHandler.error(event.error);\r\n            logger.fatal(event.error.message);\r\n            reset();\r\n        }\r\n    }\r\n\r\n    function isMediaSupported(mediaInfo) {\r\n        const type = mediaInfo.type;\r\n        let codec,\r\n            msg;\r\n\r\n        if (type === Constants.MUXED && mediaInfo) {\r\n            msg = 'Multiplexed representations are intentionally not supported, as they are not compliant with the DASH-AVC/264 guidelines';\r\n            logger.fatal(msg);\r\n            errHandler.manifestError(msg, 'multiplexedrep', manifestModel.getValue());\r\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_MULTIPLEXED_CODE, msg, manifestModel.getValue()));\r\n            return false;\r\n        }\r\n\r\n        if (type === Constants.TEXT || type === Constants.FRAGMENTED_TEXT || type === Constants.EMBEDDED_TEXT || type === Constants.IMAGE) {\r\n            return true;\r\n        }\r\n        codec = mediaInfo.codec;\r\n        logger.debug(type + ' codec: ' + codec);\r\n\r\n        if (!!mediaInfo.contentProtection && !capabilities.supportsEncryptedMedia()) {\r\n            errHandler.capabilityError('encryptedmedia');\r\n            errHandler.error(new DashJSError(Errors.CAPABILITY_MEDIAKEYS_ERROR_CODE, Errors.CAPABILITY_MEDIAKEYS_ERROR_MESSAGE));\r\n        } else if (!capabilities.supportsCodec(codec)) {\r\n            msg = type + 'Codec (' + codec + ') is not supported.';\r\n            logger.error(msg);\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function onCurrentTrackChanged(e) {\r\n        if (e.newMediaInfo.streamInfo.id !== streamInfo.id) return;\r\n\r\n        let processor = getProcessorForMediaInfo(e.newMediaInfo);\r\n        if (!processor) return;\r\n\r\n        let currentTime = playbackController.getTime();\r\n        logger.info('Stream -  Process track changed at current time ' + currentTime);\r\n        let mediaInfo = e.newMediaInfo;\r\n        let manifest = manifestModel.getValue();\r\n\r\n        adapter.setCurrentMediaInfo(streamInfo.id, mediaInfo.type, mediaInfo);\r\n\r\n        logger.debug('Stream -  Update stream controller');\r\n        if (manifest.refreshManifestOnSwitchTrack) {\r\n            logger.debug('Stream -  Refreshing manifest for switch track');\r\n            trackChangedEvent = e;\r\n            manifestUpdater.refreshManifest();\r\n        } else {\r\n            processor.selectMediaInfo(mediaInfo);\r\n            if (mediaInfo.type !== Constants.FRAGMENTED_TEXT) {\r\n                abrController.updateTopQualityIndex(mediaInfo);\r\n                processor.switchTrackAsked();\r\n                processor.getFragmentModel().abortRequests();\r\n            } else {\r\n                processor.getScheduleController().setSeekTarget(NaN);\r\n                adapter.setIndexHandlerTime(processor, currentTime);\r\n                adapter.resetIndexHandler(processor);\r\n            }\r\n        }\r\n    }\r\n\r\n    function createStreamProcessor(mediaInfo, allMediaForType, mediaSource, optionalSettings) {\r\n        let streamProcessor = StreamProcessor(context).create({\r\n            type: mediaInfo.type,\r\n            mimeType: mediaInfo.mimeType,\r\n            timelineConverter: timelineConverter,\r\n            adapter: adapter,\r\n            manifestModel: manifestModel,\r\n            dashManifestModel: dashManifestModel,\r\n            mediaPlayerModel: mediaPlayerModel,\r\n            metricsModel: metricsModel,\r\n            dashMetrics: config.dashMetrics,\r\n            baseURLController: config.baseURLController,\r\n            stream: instance,\r\n            abrController: abrController,\r\n            domStorage: config.domStorage,\r\n            playbackController: playbackController,\r\n            mediaController: mediaController,\r\n            streamController: config.streamController,\r\n            textController: textController,\r\n            errHandler: errHandler\r\n        });\r\n\r\n        streamProcessor.initialize(mediaSource);\r\n        abrController.updateTopQualityIndex(mediaInfo);\r\n\r\n        if (optionalSettings) {\r\n            streamProcessor.setBuffer(optionalSettings.buffer);\r\n            streamProcessor.getIndexHandler().setCurrentTime(optionalSettings.currentTime);\r\n            streamProcessors[optionalSettings.replaceIdx] = streamProcessor;\r\n        } else {\r\n            streamProcessors.push(streamProcessor);\r\n        }\r\n\r\n        if (optionalSettings && optionalSettings.ignoreMediaInfo) {\r\n            return;\r\n        }\r\n\r\n        if ((mediaInfo.type === Constants.TEXT || mediaInfo.type === Constants.FRAGMENTED_TEXT)) {\r\n            let idx;\r\n            for (let i = 0; i < allMediaForType.length; i++) {\r\n                if (allMediaForType[i].index === mediaInfo.index) {\r\n                    idx = i;\r\n                }\r\n                streamProcessor.addMediaInfo(allMediaForType[i]); //creates text tracks for all adaptations in one stream processor\r\n            }\r\n            streamProcessor.selectMediaInfo(allMediaForType[idx]); //sets the initial media info\r\n        } else {\r\n            streamProcessor.addMediaInfo(mediaInfo, true);\r\n        }\r\n    }\r\n\r\n    function initializeMediaForType(type, mediaSource) {\r\n        const allMediaForType = adapter.getAllMediaInfoForType(streamInfo, type);\r\n\r\n        let mediaInfo = null;\r\n        let initialMediaInfo;\r\n\r\n        if (!allMediaForType || allMediaForType.length === 0) {\r\n            logger.info('No ' + type + ' data.');\r\n            return;\r\n        }\r\n\r\n        for (let i = 0, ln = allMediaForType.length; i < ln; i++) {\r\n            mediaInfo = allMediaForType[i];\r\n\r\n            if (type === Constants.EMBEDDED_TEXT) {\r\n                textController.addEmbeddedTrack(mediaInfo);\r\n            } else {\r\n                if (!isMediaSupported(mediaInfo)) continue;\r\n                mediaController.addTrack(mediaInfo);\r\n            }\r\n        }\r\n\r\n        if (type === Constants.EMBEDDED_TEXT || mediaController.getTracksFor(type, streamInfo).length === 0) {\r\n            return;\r\n        }\r\n\r\n        if (type === Constants.IMAGE) {\r\n            thumbnailController = ThumbnailController(context).create({\r\n                dashManifestModel: dashManifestModel,\r\n                adapter: adapter,\r\n                baseURLController: config.baseURLController,\r\n                stream: instance,\r\n                timelineConverter: config.timelineConverter\r\n            });\r\n            return;\r\n        }\r\n\r\n        if (type !== Constants.FRAGMENTED_TEXT || (type === Constants.FRAGMENTED_TEXT && textController.getTextDefaultEnabled())) {\r\n            mediaController.checkInitialMediaSettingsForType(type, streamInfo);\r\n            initialMediaInfo = mediaController.getCurrentTrackFor(type, streamInfo);\r\n        }\r\n\r\n        if (type === Constants.FRAGMENTED_TEXT && !textController.getTextDefaultEnabled()) {\r\n            initialMediaInfo = mediaController.getTracksFor(type, streamInfo)[0];\r\n        }\r\n\r\n        // TODO : How to tell index handler live/duration?\r\n        // TODO : Pass to controller and then pass to each method on handler?\r\n\r\n        createStreamProcessor(initialMediaInfo, allMediaForType, mediaSource);\r\n    }\r\n\r\n    function initializeEventController () {\r\n        //if initializeMedia is called from a switch period, eventController could have been already created.\r\n        if (!eventController) {\r\n            eventController = EventController(context).create();\r\n\r\n            eventController.setConfig({\r\n                manifestUpdater: manifestUpdater,\r\n                playbackController: playbackController\r\n            });\r\n            addInlineEvents();\r\n        }\r\n    }\r\n\r\n    function addInlineEvents () {\r\n        const events = adapter.getEventsFor(streamInfo);\r\n        eventController.addInlineEvents(events);\r\n    }\r\n\r\n    function addInbandEvents (events) {\r\n        if (eventController) {\r\n            eventController.addInbandEvents(events);\r\n        }\r\n    }\r\n\r\n    function initializeMedia(mediaSource, previousBuffers) {\r\n        checkConfig();\r\n        let element = videoModel.getElement();\r\n\r\n        initializeEventController();\r\n\r\n        isUpdating = true;\r\n\r\n        filterCodecs(Constants.VIDEO);\r\n        filterCodecs(Constants.AUDIO);\r\n\r\n        if (element === null || (element && (/^VIDEO$/i).test(element.nodeName))) {\r\n            initializeMediaForType(Constants.VIDEO, mediaSource);\r\n        }\r\n        initializeMediaForType(Constants.AUDIO, mediaSource);\r\n        initializeMediaForType(Constants.TEXT, mediaSource);\r\n        initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\r\n        initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\r\n        initializeMediaForType(Constants.MUXED, mediaSource);\r\n        initializeMediaForType(Constants.IMAGE, mediaSource);\r\n\r\n        //TODO. Consider initialization of TextSourceBuffer here if embeddedText, but no sideloadedText.\r\n        const buffers = createBuffers(previousBuffers);\r\n\r\n        isMediaInitialized = true;\r\n        isUpdating = false;\r\n\r\n        if (streamProcessors.length === 0) {\r\n            const msg = 'No streams to play.';\r\n            errHandler.manifestError(msg, 'nostreams', manifestModel.getValue());\r\n            errHandler.error(new DashJSError(Errors.MANIFEST_ERROR_ID_NOSTREAMS_CODE, msg, manifestModel.getValue()));\r\n            logger.fatal(msg);\r\n        } else {\r\n            checkIfInitializationCompleted();\r\n        }\r\n\r\n        return buffers;\r\n    }\r\n\r\n    function initializeAfterPreload() {\r\n        isUpdating = true;\r\n        checkConfig();\r\n        filterCodecs(Constants.VIDEO);\r\n        filterCodecs(Constants.AUDIO);\r\n\r\n        isMediaInitialized = true;\r\n        isUpdating = false;\r\n        if (streamProcessors.length === 0) {\r\n            let msg = 'No streams to play.';\r\n            errHandler.manifestError(msg, 'nostreams', manifestModel.getValue());\r\n            logger.debug(msg);\r\n        } else {\r\n            checkIfInitializationCompleted();\r\n        }\r\n    }\r\n\r\n    function filterCodecs(type) {\r\n        const realAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), streamInfo.index, type, streamInfo);\r\n\r\n        if (!realAdaptation || !Array.isArray(realAdaptation.Representation_asArray)) return;\r\n\r\n        // Filter codecs that are not supported\r\n        realAdaptation.Representation_asArray = realAdaptation.Representation_asArray.filter((_, i) => {\r\n            // keep at least codec from lowest representation\r\n            if (i === 0) return true;\r\n\r\n            const codec = dashManifestModel.getCodec(realAdaptation, i, true);\r\n            if (!capabilities.supportsCodec(codec)) {\r\n                logger.error('[Stream] codec not supported: ' + codec);\r\n                return false;\r\n            }\r\n            return true;\r\n        });\r\n    }\r\n\r\n    function checkIfInitializationCompleted() {\r\n        const ln = streamProcessors.length;\r\n        const hasError = !!updateError.audio || !!updateError.video;\r\n        let error = hasError ? new DashJSError(Errors.DATA_UPDATE_FAILED_ERROR_CODE, Errors.DATA_UPDATE_FAILED_ERROR_MESSAGE) : null;\r\n\r\n        for (let i = 0; i < ln; i++) {\r\n            if (streamProcessors[i].isUpdating() || isUpdating) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        if (!isMediaInitialized) {\r\n            return;\r\n        }\r\n\r\n        if (protectionController) {\r\n            // Need to check if streamProcessors exists because streamProcessors\r\n            // could be cleared in case an error is detected while initializing DRM keysystem\r\n            for (let i = 0; i < ln && streamProcessors[i]; i++) {\r\n                if (streamProcessors[i].getType() === Constants.AUDIO ||\r\n                    streamProcessors[i].getType() === Constants.VIDEO ||\r\n                    streamProcessors[i].getType() === Constants.FRAGMENTED_TEXT) {\r\n                    protectionController.initializeForMedia(streamProcessors[i].getMediaInfo());\r\n                }\r\n            }\r\n        }\r\n\r\n        eventBus.trigger(Events.STREAM_INITIALIZED, {\r\n            streamInfo: streamInfo,\r\n            error: error\r\n        });\r\n    }\r\n\r\n    function getMediaInfo(type) {\r\n        const ln = streamProcessors.length;\r\n        let streamProcessor = null;\r\n\r\n        for (let i = 0; i < ln; i++) {\r\n            streamProcessor = streamProcessors[i];\r\n\r\n            if (streamProcessor.getType() === type) {\r\n                return streamProcessor.getMediaInfo();\r\n            }\r\n        }\r\n\r\n        return null;\r\n    }\r\n\r\n    function createBuffers(previousBuffers) {\r\n        const buffers = {};\r\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\r\n            buffers[streamProcessors[i].getType()] = streamProcessors[i].createBuffer(previousBuffers).getBuffer();\r\n        }\r\n        return buffers;\r\n    }\r\n\r\n    function onBufferingCompleted(e) {\r\n        if (e.streamInfo !== streamInfo) {\r\n            return;\r\n        }\r\n\r\n        let processors = getProcessors();\r\n        const ln = processors.length;\r\n\r\n        if (ln === 0) {\r\n            logger.warn('onBufferingCompleted - can\\'t trigger STREAM_BUFFERING_COMPLETED because no streamProcessor is defined');\r\n            return;\r\n        }\r\n\r\n        // if there is at least one buffer controller that has not completed buffering yet do nothing\r\n        for (let i = 0; i < ln; i++) {\r\n            //if audio or video buffer is not buffering completed state, do not send STREAM_BUFFERING_COMPLETED\r\n            if (!processors[i].isBufferingCompleted() && (processors[i].getType() === Constants.AUDIO || processors[i].getType() === Constants.VIDEO)) {\r\n                logger.warn('onBufferingCompleted - One streamProcessor has finished but', processors[i].getType(), 'one is not buffering completed');\r\n                return;\r\n            }\r\n        }\r\n\r\n        logger.debug('onBufferingCompleted - trigger STREAM_BUFFERING_COMPLETED');\r\n        eventBus.trigger(Events.STREAM_BUFFERING_COMPLETED, {\r\n            streamInfo: streamInfo\r\n        });\r\n    }\r\n\r\n    function onDataUpdateCompleted(e) {\r\n        let sp = e.sender.getStreamProcessor();\r\n\r\n        if (sp.getStreamInfo() !== streamInfo) {\r\n            return;\r\n        }\r\n\r\n        updateError[sp.getType()] = e.error;\r\n        checkIfInitializationCompleted();\r\n    }\r\n\r\n    function onLiveStreamCompleted(/*e*/) {\r\n        streamInfo.liveStreamCompleted = true;\r\n    }\r\n\r\n    function getProcessorForMediaInfo(mediaInfo) {\r\n        if (!mediaInfo) {\r\n            return null;\r\n        }\r\n\r\n        let processors = getProcessors();\r\n\r\n        return processors.filter(function (processor) {\r\n            return (processor.getType() === mediaInfo.type);\r\n        })[0];\r\n    }\r\n\r\n    function getProcessors() {\r\n        const ln = streamProcessors.length;\r\n        let arr = [];\r\n\r\n        let type,\r\n            streamProcessor;\r\n\r\n        for (let i = 0; i < ln; i++) {\r\n            streamProcessor = streamProcessors[i];\r\n            type = streamProcessor.getType();\r\n\r\n            if (type === Constants.AUDIO || type === Constants.VIDEO || type === Constants.FRAGMENTED_TEXT || type === Constants.TEXT) {\r\n                arr.push(streamProcessor);\r\n            }\r\n        }\r\n\r\n        return arr;\r\n    }\r\n\r\n    function updateData(updatedStreamInfo) {\r\n        logger.info('Manifest updated... updating data system wide.');\r\n\r\n        isStreamActivated = false;\r\n        isUpdating = true;\r\n        streamInfo = updatedStreamInfo;\r\n\r\n        if (eventController) {\r\n            addInlineEvents();\r\n        }\r\n\r\n        filterCodecs(Constants.VIDEO);\r\n        filterCodecs(Constants.AUDIO);\r\n\r\n        for (let i = 0, ln = streamProcessors.length; i < ln; i++) {\r\n            let streamProcessor = streamProcessors[i];\r\n            let mediaInfo = adapter.getMediaInfoForType(streamInfo, streamProcessor.getType());\r\n            abrController.updateTopQualityIndex(mediaInfo);\r\n            streamProcessor.addMediaInfo(mediaInfo, true);\r\n        }\r\n\r\n        if (trackChangedEvent) {\r\n            let mediaInfo = trackChangedEvent.newMediaInfo;\r\n            if (mediaInfo.type !== 'fragmentedText') {\r\n                let processor = getProcessorForMediaInfo(trackChangedEvent.oldMediaInfo);\r\n                if (!processor) return;\r\n                processor.switchTrackAsked();\r\n                trackChangedEvent = undefined;\r\n            }\r\n        }\r\n\r\n        isUpdating = false;\r\n        checkIfInitializationCompleted();\r\n    }\r\n\r\n    function isMediaCodecCompatible(stream) {\r\n        return compareCodecs(stream, Constants.VIDEO) && compareCodecs(stream, Constants.AUDIO);\r\n    }\r\n\r\n    function isProtectionCompatible(stream) {\r\n        return compareProtectionConfig(stream, Constants.VIDEO) && compareProtectionConfig(stream, Constants.AUDIO);\r\n    }\r\n\r\n    function compareProtectionConfig(stream, type) {\r\n        if (!stream) {\r\n            return false;\r\n        }\r\n        const newStreamInfo = stream.getStreamInfo();\r\n        const currentStreamInfo = getStreamInfo();\r\n\r\n        if (!newStreamInfo || !currentStreamInfo) {\r\n            return false;\r\n        }\r\n\r\n        const newAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), newStreamInfo.index, type, newStreamInfo);\r\n        const currentAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), currentStreamInfo.index, type, currentStreamInfo);\r\n\r\n        if (!newAdaptation || !currentAdaptation) {\r\n            // If there is no adaptation for neither the old or the new stream they're compatible\r\n            return !newAdaptation && !currentAdaptation;\r\n        }\r\n\r\n        // If any of the periods requires EME, we can't do smooth transition\r\n        if (newAdaptation.ContentProtection || currentAdaptation.ContentProtection) {\r\n            return false;\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    function compareCodecs(stream, type) {\r\n        if (!stream) {\r\n            return false;\r\n        }\r\n        const newStreamInfo = stream.getStreamInfo();\r\n        const currentStreamInfo = getStreamInfo();\r\n\r\n        if (!newStreamInfo || !currentStreamInfo) {\r\n            return false;\r\n        }\r\n\r\n        const newAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), newStreamInfo.index, type, newStreamInfo);\r\n        const currentAdaptation = adapter.getAdaptationForType(manifestModel.getValue(), currentStreamInfo.index, type, currentStreamInfo);\r\n\r\n        if (!newAdaptation || !currentAdaptation) {\r\n            // If there is no adaptation for neither the old or the new stream they're compatible\r\n            return !newAdaptation && !currentAdaptation;\r\n        }\r\n\r\n        const sameMimeType =  newAdaptation && currentAdaptation && newAdaptation.mimeType === currentAdaptation.mimeType;\r\n        const oldCodecs = currentAdaptation.Representation_asArray.map((representation) => {\r\n            return representation.codecs;\r\n        });\r\n\r\n        const newCodecs = newAdaptation.Representation_asArray.map((representation) => {\r\n            return representation.codecs;\r\n        });\r\n\r\n        const codecMatch = newCodecs.some((newCodec) => {\r\n            return oldCodecs.indexOf(newCodec) > -1;\r\n        });\r\n\r\n        const partialCodecMatch = newCodecs.some((newCodec) => oldCodecs.some((oldCodec) => codecRootCompatibleWithCodec(oldCodec, newCodec)));\r\n        return codecMatch || (partialCodecMatch && sameMimeType);\r\n    }\r\n\r\n    // Check if the root of the old codec is the same as the new one, or if it's declared as compatible in the compat table\r\n    function codecRootCompatibleWithCodec(codec1, codec2) {\r\n        const codecRoot = codec1.split('.')[0];\r\n        const rootCompatible = codec2.indexOf(codecRoot) === 0;\r\n        let compatTableCodec;\r\n        for (let i = 0; i < codecCompatibilityTable.length; i++) {\r\n            if (codecCompatibilityTable[i].codec === codecRoot) {\r\n                compatTableCodec = codecCompatibilityTable[i];\r\n                break;\r\n            }\r\n        }\r\n        if (compatTableCodec) {\r\n            return rootCompatible || compatTableCodec.compatibleCodecs.some((compatibleCodec) => codec2.indexOf(compatibleCodec) === 0);\r\n        }\r\n        return rootCompatible;\r\n    }\r\n\r\n    function setPreloaded(value) {\r\n        preloaded = value;\r\n    }\r\n\r\n    function getPreloaded() {\r\n        return preloaded;\r\n    }\r\n\r\n    function preload(mediaSource, previousBuffers) {\r\n        initializeEventController();\r\n\r\n        initializeMediaForType(Constants.VIDEO, mediaSource);\r\n        initializeMediaForType(Constants.AUDIO, mediaSource);\r\n        initializeMediaForType(Constants.TEXT, mediaSource);\r\n        initializeMediaForType(Constants.FRAGMENTED_TEXT, mediaSource);\r\n        initializeMediaForType(Constants.EMBEDDED_TEXT, mediaSource);\r\n        initializeMediaForType(Constants.MUXED, mediaSource);\r\n        initializeMediaForType(Constants.IMAGE, mediaSource);\r\n\r\n        createBuffers(previousBuffers);\r\n\r\n        eventBus.on(Events.CURRENT_TRACK_CHANGED, onCurrentTrackChanged, instance);\r\n        for (let i = 0; i < streamProcessors.length && streamProcessors[i]; i++) {\r\n            streamProcessors[i].getScheduleController().start();\r\n        }\r\n\r\n        setPreloaded(true);\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        activate: activate,\r\n        deactivate: deactivate,\r\n        isActive: isActive,\r\n        getDuration: getDuration,\r\n        getStartTime: getStartTime,\r\n        getId: getId,\r\n        getStreamInfo: getStreamInfo,\r\n        preload: preload,\r\n        getFragmentController: getFragmentController,\r\n        getThumbnailController: getThumbnailController,\r\n        getBitrateListFor: getBitrateListFor,\r\n        startEventController: startEventController,\r\n        stopEventController: stopEventController,\r\n        updateData: updateData,\r\n        reset: reset,\r\n        getProcessors: getProcessors,\r\n        setMediaSource: setMediaSource,\r\n        isMediaCodecCompatible: isMediaCodecCompatible,\r\n        isProtectionCompatible: isProtectionCompatible,\r\n        getPreloaded: getPreloaded,\r\n        addInbandEvents: addInbandEvents\r\n    };\r\n\r\n    setup();\r\n    return instance;\r\n}\r\n\r\nStream.__dashjs_factory_name = 'Stream';\r\nexport default FactoryMaker.getClassFactory(Stream);\r\n"]}