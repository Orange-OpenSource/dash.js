{"version":3,"sources":["../../../../../src/dash/utils/SegmentsUtils.js"],"names":["unescapeDollarsInTemplate","replaceIDForTemplate","replaceTokenForTemplate","getIndexBasedSegment","getTimeBasedSegment","getSegmentByIndex","decideSegmentListRangeForTemplate","zeroPadToLength","numStr","minStrLength","length","getNumberForSegment","segment","segmentIndex","representation","startNumber","url","split","join","value","indexOf","v","toString","token","formatTag","startPos","endPos","formatTagPos","specifier","width","paddedValue","tokenLen","formatTagLen","charAt","parseInt","substring","toUpperCase","timelineConverter","isDynamic","index","seg","duration","presentationStartTime","presentationEndTime","segmentDuration","isNaN","adaptation","period","parseFloat","start","toFixed","Segment","mediaStartTime","calcMediaTimeFromPresentationTime","availabilityStartTime","calcAvailabilityStartTimeFromPresentationTime","mpd","availabilityEndTime","calcAvailabilityEndTimeFromPresentationTime","wallStartTime","calcWallTimeForSegment","replacementNumber","availabilityIdx","time","fTimescale","range","tManifest","scaledTime","scaledDuration","Math","min","maxSegmentDuration","calcPresentationTimeFromMediaTime","manifest","loadedTime","replacementTime","media","mediaRange","segments","ln","i","requestedTime","givenAvailabilityUpperLimit","minBufferTime","availabilityWindow","segmentAvailabilityRange","periodRelativeRange","calcPeriodRelativeTimeFromMpdRelativeTime","NaN","end","currentSegmentList","availabilityLowerLimit","availabilityUpperLimit","max","originAvailabilityTime","originSegment","isTimeSyncCompleted","floor"],"mappings":"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","file":"SegmentsUtils.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nimport Segment from './../vo/Segment';\r\n\r\nfunction zeroPadToLength(numStr, minStrLength) {\r\n    while (numStr.length < minStrLength) {\r\n        numStr = '0' + numStr;\r\n    }\r\n    return numStr;\r\n}\r\n\r\nfunction getNumberForSegment(segment, segmentIndex) {\r\n    return segment.representation.startNumber + segmentIndex;\r\n}\r\n\r\nexport function unescapeDollarsInTemplate(url) {\r\n    return url ? url.split('$$').join('$') : url;\r\n}\r\n\r\nexport function replaceIDForTemplate(url, value) {\r\n    if (!value || !url || url.indexOf('$RepresentationID$') === -1) { return url; }\r\n    let v = value.toString();\r\n    return url.split('$RepresentationID$').join(v);\r\n}\r\n\r\nexport function replaceTokenForTemplate(url, token, value) {\r\n    const formatTag = '%0';\r\n\r\n    let startPos,\r\n        endPos,\r\n        formatTagPos,\r\n        specifier,\r\n        width,\r\n        paddedValue;\r\n\r\n    const tokenLen = token.length;\r\n    const formatTagLen = formatTag.length;\r\n\r\n    if (!url) {\r\n        return url;\r\n    }\r\n\r\n    // keep looping round until all instances of <token> have been\r\n    // replaced. once that has happened, startPos below will be -1\r\n    // and the completed url will be returned.\r\n    while (true) {\r\n\r\n        // check if there is a valid $<token>...$ identifier\r\n        // if not, return the url as is.\r\n        startPos = url.indexOf('$' + token);\r\n        if (startPos < 0) {\r\n            return url;\r\n        }\r\n\r\n        // the next '$' must be the end of the identifier\r\n        // if there isn't one, return the url as is.\r\n        endPos = url.indexOf('$', startPos + tokenLen);\r\n        if (endPos < 0) {\r\n            return url;\r\n        }\r\n\r\n        // now see if there is an additional format tag suffixed to\r\n        // the identifier within the enclosing '$' characters\r\n        formatTagPos = url.indexOf(formatTag, startPos + tokenLen);\r\n        if (formatTagPos > startPos && formatTagPos < endPos) {\r\n\r\n            specifier = url.charAt(endPos - 1);\r\n            width = parseInt(url.substring(formatTagPos + formatTagLen, endPos - 1), 10);\r\n\r\n            // support the minimum specifiers required by IEEE 1003.1\r\n            // (d, i , o, u, x, and X) for completeness\r\n            switch (specifier) {\r\n                // treat all int types as uint,\r\n                // hence deliberate fallthrough\r\n                case 'd':\r\n                case 'i':\r\n                case 'u':\r\n                    paddedValue = zeroPadToLength(value.toString(), width);\r\n                    break;\r\n                case 'x':\r\n                    paddedValue = zeroPadToLength(value.toString(16), width);\r\n                    break;\r\n                case 'X':\r\n                    paddedValue = zeroPadToLength(value.toString(16), width).toUpperCase();\r\n                    break;\r\n                case 'o':\r\n                    paddedValue = zeroPadToLength(value.toString(8), width);\r\n                    break;\r\n                default:\r\n                    return url;\r\n            }\r\n        } else {\r\n            paddedValue = value;\r\n        }\r\n\r\n        url = url.substring(0, startPos) + paddedValue + url.substring(endPos + 1);\r\n    }\r\n}\r\n\r\nexport function getIndexBasedSegment(timelineConverter, isDynamic, representation, index) {\r\n    let seg,\r\n        duration,\r\n        presentationStartTime,\r\n        presentationEndTime;\r\n\r\n    duration = representation.segmentDuration;\r\n\r\n    /*\r\n     * From spec - If neither @duration attribute nor SegmentTimeline element is present, then the Representation\r\n     * shall contain exactly one Media Segment. The MPD start time is 0 and the MPD duration is obtained\r\n     * in the same way as for the last Media Segment in the Representation.\r\n     */\r\n    if (isNaN(duration)) {\r\n        duration = representation.adaptation.period.duration;\r\n    }\r\n\r\n    presentationStartTime = parseFloat((representation.adaptation.period.start + (index * duration)).toFixed(5));\r\n    presentationEndTime = parseFloat((presentationStartTime + duration).toFixed(5));\r\n\r\n    seg = new Segment();\r\n\r\n    seg.representation = representation;\r\n    seg.duration = duration;\r\n    seg.presentationStartTime = presentationStartTime;\r\n\r\n    seg.mediaStartTime = timelineConverter.calcMediaTimeFromPresentationTime(seg.presentationStartTime, representation);\r\n\r\n    seg.availabilityStartTime = timelineConverter.calcAvailabilityStartTimeFromPresentationTime(seg.presentationStartTime, representation.adaptation.period.mpd, isDynamic);\r\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\r\n\r\n    // at this wall clock time, the video element currentTime should be seg.presentationStartTime\r\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\r\n\r\n    seg.replacementNumber = getNumberForSegment(seg, index);\r\n    seg.availabilityIdx = index;\r\n\r\n    return seg;\r\n}\r\n\r\nexport function getTimeBasedSegment(timelineConverter, isDynamic, representation, time, duration, fTimescale, url, range, index, tManifest) {\r\n    const scaledTime = time / fTimescale;\r\n    const scaledDuration = Math.min(duration / fTimescale, representation.adaptation.period.mpd.maxSegmentDuration);\r\n\r\n    let presentationStartTime,\r\n        presentationEndTime,\r\n        seg;\r\n\r\n    presentationStartTime = timelineConverter.calcPresentationTimeFromMediaTime(scaledTime, representation);\r\n    presentationEndTime = presentationStartTime + scaledDuration;\r\n\r\n    seg = new Segment();\r\n\r\n    seg.representation = representation;\r\n    seg.duration = scaledDuration;\r\n    seg.mediaStartTime = scaledTime;\r\n\r\n    seg.presentationStartTime = presentationStartTime;\r\n\r\n    // For SegmentTimeline every segment is available at loadedTime\r\n    seg.availabilityStartTime = representation.adaptation.period.mpd.manifest.loadedTime;\r\n    seg.availabilityEndTime = timelineConverter.calcAvailabilityEndTimeFromPresentationTime(presentationEndTime, representation.adaptation.period.mpd, isDynamic);\r\n\r\n    // at this wall clock time, the video element currentTime should be seg.presentationStartTime\r\n    seg.wallStartTime = timelineConverter.calcWallTimeForSegment(seg, isDynamic);\r\n\r\n    seg.replacementTime = tManifest ? tManifest : time;\r\n\r\n    seg.replacementNumber = getNumberForSegment(seg, index);\r\n\r\n    url = replaceTokenForTemplate(url, 'Number', seg.replacementNumber);\r\n    url = replaceTokenForTemplate(url, 'Time', seg.replacementTime);\r\n    seg.media = url;\r\n    seg.mediaRange = range;\r\n    seg.availabilityIdx = index;\r\n\r\n    return seg;\r\n}\r\n\r\nexport function getSegmentByIndex(index, representation) {\r\n    if (!representation || !representation.segments) return null;\r\n\r\n    const ln = representation.segments.length;\r\n    let seg,\r\n        i;\r\n\r\n    if (index < ln) {\r\n        seg = representation.segments[index];\r\n        if (seg && seg.availabilityIdx === index) {\r\n            return seg;\r\n        }\r\n    }\r\n\r\n    for (i = 0; i < ln; i++) {\r\n        seg = representation.segments[i];\r\n\r\n        if (seg && seg.availabilityIdx === index) {\r\n            return seg;\r\n        }\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\nexport function decideSegmentListRangeForTemplate(timelineConverter, isDynamic, representation, requestedTime, index, givenAvailabilityUpperLimit) {\r\n    const duration = representation.segmentDuration;\r\n    const minBufferTime = representation.adaptation.period.mpd.manifest.minBufferTime;\r\n    const availabilityWindow = representation.segmentAvailabilityRange;\r\n    let periodRelativeRange = {\r\n        start: timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, availabilityWindow ? availabilityWindow.start : NaN),\r\n        end: timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, availabilityWindow ? availabilityWindow.end : NaN)\r\n    };\r\n    const currentSegmentList = representation.segments;\r\n    const availabilityLowerLimit = 2 * duration;\r\n    const availabilityUpperLimit = givenAvailabilityUpperLimit || Math.max(2 * minBufferTime, 10 * duration);\r\n    let originAvailabilityTime = NaN;\r\n    let originSegment = null;\r\n\r\n    let start,\r\n        end,\r\n        range;\r\n\r\n    periodRelativeRange.start = Math.max(periodRelativeRange.start, 0);\r\n\r\n    if (isDynamic && !timelineConverter.isTimeSyncCompleted()) {\r\n        start = Math.floor(periodRelativeRange.start / duration);\r\n        end = Math.floor(periodRelativeRange.end / duration);\r\n        range = {start: start, end: end};\r\n        return range;\r\n    }\r\n\r\n    // if segments exist we should try to find the latest buffered time, which is the presentation time of the\r\n    // segment for the current index\r\n    if (currentSegmentList && currentSegmentList.length > 0) {\r\n        originSegment = getSegmentByIndex(index, representation);\r\n        if (originSegment) {\r\n            originAvailabilityTime = timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, originSegment.presentationStartTime);\r\n        } else {\r\n            originAvailabilityTime = index > 0 ? index * duration :\r\n                timelineConverter.calcPeriodRelativeTimeFromMpdRelativeTime(representation, requestedTime);\r\n        }\r\n\r\n    } else {\r\n        // If no segments exist, but index > 0, it means that we switch to the other representation, so\r\n        // we should proceed from this time.\r\n        // Otherwise we should start from the beginning for static mpds or from the end (live edge) for dynamic mpds\r\n        originAvailabilityTime = index > 0 ? index * duration : isDynamic ? periodRelativeRange.end : periodRelativeRange.start;\r\n    }\r\n\r\n    // segment list should not be out of the availability window range\r\n    start = Math.floor(Math.max(originAvailabilityTime - availabilityLowerLimit, periodRelativeRange.start) / duration);\r\n    end = Math.floor(Math.min(start + availabilityUpperLimit / duration, periodRelativeRange.end / duration));\r\n\r\n    range = {start: start, end: end};\r\n\r\n    return range;\r\n}\r\n"]}