{"version":3,"sources":["../../../../../src/dash/utils/TimelineSegmentsGetter.js"],"names":["FactoryMaker","Constants","getTimeBasedSegment","TimelineSegmentsGetter","config","isDynamic","timelineConverter","instance","checkConfig","hasOwnProperty","Error","MISSING_CONFIG_ERROR","getSegmentsFromTimeline","representation","requestedTime","index","availabilityUpperLimit","undefined","base","adaptation","period","mpd","manifest","Period_asArray","AdaptationSet_asArray","Representation_asArray","SegmentTemplate","SegmentList","timeline","SegmentTimeline","list","SegmentURL_asArray","isAvailableSegmentNumberCalculated","availableSegmentsNumber","maxSegmentsAhead","Infinity","time","scaledTime","availabilityIdx","segments","requiredMediaTime","fragments","frag","i","len","j","repeat","repeatEndTime","nextFrag","hasEnoughSegments","startIdx","fTimescale","createSegment","s","media","mediaRange","d","tManifest","timescale","S_asArray","calcMediaTimeFromPresentationTime","length","r","t","availabilityEnd","segmentAvailabilityRange","end","calcSegmentAvailabilityRange","segmentDuration","Math","ceil","push","getSegments","__dashjs_factory_name","factory","getClassFactory"],"mappings":"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","file":"TimelineSegmentsGetter.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\n\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\nimport Constants from '../../streaming/constants/Constants';\r\n\r\nimport {getTimeBasedSegment} from './SegmentsUtils';\r\n\r\nfunction TimelineSegmentsGetter(config, isDynamic) {\r\n\r\n    config = config || {};\r\n    const timelineConverter = config.timelineConverter;\r\n\r\n    let instance;\r\n\r\n    function checkConfig() {\r\n        if (!timelineConverter || !timelineConverter.hasOwnProperty('calcMediaTimeFromPresentationTime') ||\r\n            !timelineConverter.hasOwnProperty('calcSegmentAvailabilityRange')) {\r\n            throw new Error(Constants.MISSING_CONFIG_ERROR);\r\n        }\r\n    }\r\n\r\n    function getSegmentsFromTimeline(representation, requestedTime, index, availabilityUpperLimit) {\r\n        checkConfig();\r\n\r\n        if (!representation) {\r\n            throw new Error('no representation');\r\n        }\r\n\r\n        if (requestedTime === undefined) {\r\n            requestedTime = null;\r\n        }\r\n\r\n        const base = representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\r\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentTemplate ||\r\n            representation.adaptation.period.mpd.manifest.Period_asArray[representation.adaptation.period.index].\r\n            AdaptationSet_asArray[representation.adaptation.index].Representation_asArray[representation.index].SegmentList;\r\n        const timeline = base.SegmentTimeline;\r\n        const list = base.SegmentURL_asArray;\r\n        const isAvailableSegmentNumberCalculated = representation.availableSegmentsNumber > 0;\r\n\r\n        let maxSegmentsAhead;\r\n\r\n        if (availabilityUpperLimit) {\r\n            maxSegmentsAhead = availabilityUpperLimit;\r\n        } else {\r\n            maxSegmentsAhead = (index > -1 || requestedTime !== null) ? 10 : Infinity;\r\n        }\r\n\r\n        let time = 0;\r\n        let scaledTime = 0;\r\n        let availabilityIdx = -1;\r\n        const segments = [];\r\n        let requiredMediaTime = null;\r\n\r\n        let fragments,\r\n            frag,\r\n            i,\r\n            len,\r\n            j,\r\n            repeat,\r\n            repeatEndTime,\r\n            nextFrag,\r\n            hasEnoughSegments,\r\n            startIdx,\r\n            fTimescale;\r\n\r\n        let createSegment = function (s, i) {\r\n            let media = base.media;\r\n            let mediaRange = s.mediaRange;\r\n\r\n            if (list) {\r\n                media = list[i].media || '';\r\n                mediaRange = list[i].mediaRange;\r\n            }\r\n\r\n            return getTimeBasedSegment(\r\n                timelineConverter,\r\n                isDynamic,\r\n                representation,\r\n                time,\r\n                s.d,\r\n                fTimescale,\r\n                media,\r\n                mediaRange,\r\n                availabilityIdx,\r\n                s.tManifest);\r\n        };\r\n\r\n        fTimescale = representation.timescale;\r\n\r\n        fragments = timeline.S_asArray;\r\n\r\n        startIdx = index;\r\n\r\n        if (requestedTime !== null) {\r\n            requiredMediaTime = timelineConverter.calcMediaTimeFromPresentationTime(requestedTime, representation);\r\n        }\r\n\r\n        for (i = 0, len = fragments.length; i < len; i++) {\r\n            frag = fragments[i];\r\n            repeat = 0;\r\n            if (frag.hasOwnProperty('r')) {\r\n                repeat = frag.r;\r\n            }\r\n\r\n            // For a repeated S element, t belongs only to the first segment\r\n            if (frag.hasOwnProperty('t')) {\r\n                time = frag.t;\r\n                scaledTime = time / fTimescale;\r\n            }\r\n\r\n            // This is a special case: \"A negative value of the @r attribute of the S element indicates that the duration indicated in @d attribute repeats until the start of the next S element, the end of the Period or until the\r\n            // next MPD update.\"\r\n            if (repeat < 0) {\r\n                nextFrag = fragments[i + 1];\r\n\r\n                if (nextFrag && nextFrag.hasOwnProperty('t')) {\r\n                    repeatEndTime = nextFrag.t / fTimescale;\r\n                } else {\r\n                    const availabilityEnd = representation.segmentAvailabilityRange ? representation.segmentAvailabilityRange.end : (timelineConverter.calcSegmentAvailabilityRange(representation, isDynamic).end);\r\n                    repeatEndTime = timelineConverter.calcMediaTimeFromPresentationTime(availabilityEnd, representation);\r\n                    representation.segmentDuration = frag.d / fTimescale;\r\n                }\r\n\r\n                repeat = Math.ceil((repeatEndTime - scaledTime) / (frag.d / fTimescale)) - 1;\r\n            }\r\n\r\n            // if we have enough segments in the list, but we have not calculated the total number of the segments yet we\r\n            // should continue the loop and calc the number. Once it is calculated, we can break the loop.\r\n            if (hasEnoughSegments) {\r\n                if (isAvailableSegmentNumberCalculated) break;\r\n                availabilityIdx += repeat + 1;\r\n                continue;\r\n            }\r\n\r\n            for (j = 0; j <= repeat; j++) {\r\n                availabilityIdx++;\r\n\r\n                if (segments.length > maxSegmentsAhead) {\r\n                    hasEnoughSegments = true;\r\n                    if (isAvailableSegmentNumberCalculated) break;\r\n                    continue;\r\n                }\r\n\r\n                if (requiredMediaTime !== null) {\r\n                    // In some cases when requiredMediaTime = actual end time of the last segment\r\n                    // it is possible that this time a bit exceeds the declared end time of the last segment.\r\n                    // in this case we still need to include the last segment in the segment list. to do this we\r\n                    // use a correction factor = 1.5. This number is used because the largest possible deviation is\r\n                    // is 50% of segment duration.\r\n                    if (scaledTime >= (requiredMediaTime - (frag.d / fTimescale) * 1.5)) {\r\n                        segments.push(createSegment(frag, availabilityIdx));\r\n                    }\r\n                } else if (availabilityIdx >= startIdx) {\r\n                    segments.push(createSegment(frag, availabilityIdx));\r\n                }\r\n\r\n                time += frag.d;\r\n                scaledTime = time / fTimescale;\r\n            }\r\n        }\r\n\r\n        if (!isAvailableSegmentNumberCalculated) {\r\n            representation.availableSegmentsNumber = availabilityIdx + 1;\r\n        }\r\n\r\n        return segments;\r\n    }\r\n\r\n    instance = {\r\n        getSegments: getSegmentsFromTimeline\r\n    };\r\n\r\n    return instance;\r\n}\r\n\r\nTimelineSegmentsGetter.__dashjs_factory_name = 'TimelineSegmentsGetter';\r\nconst factory = FactoryMaker.getClassFactory(TimelineSegmentsGetter);\r\nexport default factory;\r\n"]}