{"version":3,"sources":["../../../../../src/dash/utils/TimelineConverter.js"],"names":["TimelineConverter","context","eventBus","getInstance","instance","dashManifestModel","clientServerTimeShift","isClientServerTimeSyncCompleted","expectedLiveEdge","initialize","resetInitialSettings","on","Events","TIME_SYNCHRONIZATION_COMPLETED","onTimeSyncComplete","setConfig","config","isTimeSyncCompleted","setTimeSyncCompleted","value","getClientTimeOffset","setClientTimeOffset","getExpectedLiveEdge","setExpectedLiveEdge","calcAvailabilityTimeFromPresentationTime","presentationTime","mpd","isDynamic","calculateEnd","availabilityTime","NaN","timeShiftBufferDepth","Number","POSITIVE_INFINITY","Date","availabilityStartTime","getTime","availabilityEndTime","calcAvailabilityStartTimeFromPresentationTime","call","calcAvailabilityEndTimeFromPresentationTime","calcPresentationTimeFromWallTime","wallTime","period","calcPresentationTimeFromMediaTime","mediaTime","representation","periodStart","adaptation","start","presentationOffset","presentationTimeOffset","calcMediaTimeFromPresentationTime","calcWallTimeForSegment","segment","suggestedPresentationDelay","displayStartTime","presentationStartTime","calcSegmentAvailabilityRange","voRepresentation","voPeriod","range","end","duration","segmentAvailabilityRange","d","segmentDuration","segments","length","segmentInfoType","DashConstants","SEGMENT_TIMELINE","calcSegmentAvailabilityRangeFromTimeline","now","periodEnd","Math","max","endOffset","availabilityTimeOffset","undefined","manifest","Period_asArray","index","AdaptationSet_asArray","getRepresentationFor","timeline","SegmentTemplate","SegmentTimeline","timescale","S_asArray","repeat","i","len","t","hasOwnProperty","r","calcPeriodRelativeTimeFromMpdRelativeTime","mpdRelativeTime","periodStartTime","e","offset","calcMSETimeOffset","reset","off","__dashjs_factory_name","FactoryMaker","getSingletonFactory"],"mappings":"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","file":"TimelineConverter.js","sourcesContent":["/**\n * The copyright in this software is being made available under the BSD License,\n * included below. This software may be subject to other third party and contributor\n * rights, including patent rights, and no such rights are granted under this license.\n *\n * Copyright (c) 2013, Dash Industry Forum.\n * All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification,\n * are permitted provided that the following conditions are met:\n *  * Redistributions of source code must retain the above copyright notice, this\n *  list of conditions and the following disclaimer.\n *  * Redistributions in binary form must reproduce the above copyright notice,\n *  this list of conditions and the following disclaimer in the documentation and/or\n *  other materials provided with the distribution.\n *  * Neither the name of Dash Industry Forum nor the names of its\n *  contributors may be used to endorse or promote products derived from this software\n *  without specific prior written permission.\n *\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n *  POSSIBILITY OF SUCH DAMAGE.\n */\nimport EventBus from '../../core/EventBus';\nimport Events from '../../core/events/Events';\nimport FactoryMaker from '../../core/FactoryMaker';\nimport DashConstants from '../constants/DashConstants';\n\nfunction TimelineConverter() {\n\n    let context = this.context;\n    let eventBus = EventBus(context).getInstance();\n\n    let instance,\n        dashManifestModel,\n        clientServerTimeShift,\n        isClientServerTimeSyncCompleted,\n        expectedLiveEdge;\n\n    function initialize() {\n        resetInitialSettings();\n        eventBus.on(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n    }\n\n    function setConfig(config) {\n        if (!config) return;\n\n        if (config.dashManifestModel) {\n            dashManifestModel = config.dashManifestModel;\n        }\n    }\n\n    function isTimeSyncCompleted() {\n        return isClientServerTimeSyncCompleted;\n    }\n\n    function setTimeSyncCompleted(value) {\n        isClientServerTimeSyncCompleted = value;\n    }\n\n    function getClientTimeOffset() {\n        return clientServerTimeShift;\n    }\n\n    function setClientTimeOffset(value) {\n        clientServerTimeShift = value;\n    }\n\n    function getExpectedLiveEdge() {\n        return expectedLiveEdge;\n    }\n\n    function setExpectedLiveEdge(value) {\n        expectedLiveEdge = value;\n    }\n\n    function calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {\n        let availabilityTime = NaN;\n\n        if (calculateEnd) {\n            //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\n            // to be available for a Media Presentation with type 'dynamic'.\n            // When not present, the value is infinite.\n            if (isDynamic && (mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY)) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + ((presentationTime + mpd.timeShiftBufferDepth) * 1000));\n            } else {\n                availabilityTime = mpd.availabilityEndTime;\n            }\n        } else {\n            if (isDynamic) {\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime - clientServerTimeShift) * 1000);\n            } else {\n                // in static mpd, all segments are available at the same time\n                availabilityTime = mpd.availabilityStartTime;\n            }\n        }\n\n        return availabilityTime;\n    }\n\n    function calcAvailabilityStartTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\n    }\n\n    function calcAvailabilityEndTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\n    }\n\n    function calcPresentationTimeFromWallTime(wallTime, period) {\n        return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime() + clientServerTimeShift * 1000) / 1000);\n    }\n\n    function calcPresentationTimeFromMediaTime(mediaTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return mediaTime + (periodStart - presentationOffset);\n    }\n\n    function calcMediaTimeFromPresentationTime(presentationTime, representation) {\n        const periodStart = representation.adaptation.period.start;\n        const presentationOffset = representation.presentationTimeOffset;\n\n        return presentationTime - periodStart + presentationOffset;\n    }\n\n    function calcWallTimeForSegment(segment, isDynamic) {\n        let suggestedPresentationDelay,\n            displayStartTime,\n            wallTime;\n\n        if (isDynamic) {\n            suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\n            displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\n            wallTime = new Date(segment.availabilityStartTime.getTime() + (displayStartTime * 1000));\n        }\n\n        return wallTime;\n    }\n\n    function calcSegmentAvailabilityRange(voRepresentation, isDynamic) {\n        // Static Range Finder\n        const voPeriod = voRepresentation.adaptation.period;\n        const range = { start: voPeriod.start, end: voPeriod.start + voPeriod.duration };\n        if (!isDynamic) return range;\n\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\n            return voRepresentation.segmentAvailabilityRange;\n        }\n\n        // Dynamic Range Finder\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\n\n        // Specific use case of SegmentTimeline without timeShiftBufferDepth\n        if (voRepresentation.segmentInfoType === DashConstants.SEGMENT_TIMELINE && voPeriod.mpd.timeShiftBufferDepth === Number.POSITIVE_INFINITY) {\n            return calcSegmentAvailabilityRangeFromTimeline(voRepresentation);\n        } else {\n            const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\n            const periodEnd = voPeriod.start + voPeriod.duration;\n            range.start = Math.max((now - voPeriod.mpd.timeShiftBufferDepth), voPeriod.start);\n\n            const endOffset = voRepresentation.availabilityTimeOffset !== undefined &&\n                voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\n            range.end = now >= periodEnd && now - endOffset < periodEnd ? periodEnd : now - endOffset;\n        }\n\n        return range;\n    }\n\n    function calcSegmentAvailabilityRangeFromTimeline(voRepresentation) {\n        const adaptation = voRepresentation.adaptation.period.mpd.manifest.Period_asArray[voRepresentation.adaptation.period.index].AdaptationSet_asArray[voRepresentation.adaptation.index];\n        const representation = dashManifestModel.getRepresentationFor(voRepresentation.index, adaptation);\n\n        const timeline = representation.SegmentTemplate.SegmentTimeline;\n        const timescale = representation.SegmentTemplate.timescale;\n        const segments = timeline.S_asArray;\n        const range = { start: 0, end: 0 };\n        let d = 0;\n        let segment,\n            repeat,\n            i,\n            len;\n\n        range.start = segments[0].t / timescale;\n\n        for (i = 0, len = segments.length; i < len; i++) {\n            segment = segments[i];\n            repeat = 0;\n            if (segment.hasOwnProperty('r')) {\n                repeat = segment.r;\n            }\n            d += (segment.d / timescale)  * (1 + repeat);\n        }\n\n        range.end = range.start + d;\n\n        return range;\n    }\n\n    function calcPeriodRelativeTimeFromMpdRelativeTime(representation, mpdRelativeTime) {\n        const periodStartTime = representation.adaptation.period.start;\n        return mpdRelativeTime - periodStartTime;\n    }\n\n    /*\n    * We need to figure out if we want to timesync for segmentTimeine where useCalculatedLiveEdge = true\n    * seems we figure out client offset based on logic in liveEdgeFinder getLiveEdge timelineConverter.setClientTimeOffset(liveEdge - representationInfo.DVRWindow.end);\n    * FYI StreamController's onManifestUpdated entry point to timeSync\n    * */\n    function onTimeSyncComplete(e) {\n\n        if (isClientServerTimeSyncCompleted) return;\n\n        if (e.offset !== undefined) {\n            setClientTimeOffset(e.offset / 1000);\n            isClientServerTimeSyncCompleted = true;\n\n        }\n    }\n\n    function calcMSETimeOffset(representation) {\n        // The MSEOffset is offset from AST for media. It is Period@start - presentationTimeOffset\n        const presentationOffset = representation.presentationTimeOffset;\n        const periodStart = representation.adaptation.period.start;\n        return (periodStart - presentationOffset);\n    }\n\n    function resetInitialSettings() {\n        clientServerTimeShift = 0;\n        isClientServerTimeSyncCompleted = false;\n        expectedLiveEdge = NaN;\n    }\n\n    function reset() {\n        eventBus.off(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\n        resetInitialSettings();\n    }\n\n    instance = {\n        initialize: initialize,\n        setConfig: setConfig,\n        isTimeSyncCompleted: isTimeSyncCompleted,\n        setTimeSyncCompleted: setTimeSyncCompleted,\n        getClientTimeOffset: getClientTimeOffset,\n        setClientTimeOffset: setClientTimeOffset,\n        getExpectedLiveEdge: getExpectedLiveEdge,\n        setExpectedLiveEdge: setExpectedLiveEdge,\n        calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\n        calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\n        calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\n        calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\n        calcPeriodRelativeTimeFromMpdRelativeTime: calcPeriodRelativeTimeFromMpdRelativeTime,\n        calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\n        calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\n        calcWallTimeForSegment: calcWallTimeForSegment,\n        calcMSETimeOffset: calcMSETimeOffset,\n        reset: reset\n    };\n\n    return instance;\n}\n\nTimelineConverter.__dashjs_factory_name = 'TimelineConverter';\nexport default FactoryMaker.getSingletonFactory(TimelineConverter);"]}