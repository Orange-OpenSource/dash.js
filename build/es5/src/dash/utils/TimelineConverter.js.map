{"version":3,"sources":["../../../../../src/dash/utils/TimelineConverter.js"],"names":["EventBus","Events","FactoryMaker","TimelineConverter","context","eventBus","getInstance","instance","clientServerTimeShift","isClientServerTimeSyncCompleted","expectedLiveEdge","initialize","resetInitialSettings","on","TIME_SYNCHRONIZATION_COMPLETED","onTimeSyncComplete","isTimeSyncCompleted","setTimeSyncCompleted","value","getClientTimeOffset","setClientTimeOffset","getExpectedLiveEdge","setExpectedLiveEdge","calcAvailabilityTimeFromPresentationTime","presentationTime","mpd","isDynamic","calculateEnd","availabilityTime","NaN","timeShiftBufferDepth","Number","POSITIVE_INFINITY","Date","availabilityStartTime","getTime","availabilityEndTime","calcAvailabilityStartTimeFromPresentationTime","call","calcAvailabilityEndTimeFromPresentationTime","calcPresentationTimeFromWallTime","wallTime","period","calcPresentationTimeFromMediaTime","mediaTime","representation","periodStart","adaptation","start","presentationOffset","presentationTimeOffset","calcMediaTimeFromPresentationTime","calcWallTimeForSegment","segment","suggestedPresentationDelay","displayStartTime","presentationStartTime","calcSegmentAvailabilityRange","voRepresentation","voPeriod","range","end","duration","segmentAvailabilityRange","d","segmentDuration","segments","length","now","periodEnd","Math","max","endOffset","availabilityTimeOffset","undefined","calcPeriodRelativeTimeFromMpdRelativeTime","mpdRelativeTime","periodStartTime","e","offset","calcMSETimeOffset","reset","off","__dashjs_factory_name","getSingletonFactory"],"mappings":"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","file":"TimelineConverter.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport EventBus from '../../core/EventBus';\r\nimport Events from '../../core/events/Events';\r\nimport FactoryMaker from '../../core/FactoryMaker';\r\n\r\nfunction TimelineConverter() {\r\n\r\n    let context = this.context;\r\n    let eventBus = EventBus(context).getInstance();\r\n\r\n    let instance,\r\n        clientServerTimeShift,\r\n        isClientServerTimeSyncCompleted,\r\n        expectedLiveEdge;\r\n\r\n    function initialize() {\r\n        resetInitialSettings();\r\n        eventBus.on(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\r\n    }\r\n\r\n    function isTimeSyncCompleted() {\r\n        return isClientServerTimeSyncCompleted;\r\n    }\r\n\r\n    function setTimeSyncCompleted(value) {\r\n        isClientServerTimeSyncCompleted = value;\r\n    }\r\n\r\n    function getClientTimeOffset() {\r\n        return clientServerTimeShift;\r\n    }\r\n\r\n    function setClientTimeOffset(value) {\r\n        clientServerTimeShift = value;\r\n    }\r\n\r\n    function getExpectedLiveEdge() {\r\n        return expectedLiveEdge;\r\n    }\r\n\r\n    function setExpectedLiveEdge(value) {\r\n        expectedLiveEdge = value;\r\n    }\r\n\r\n    function calcAvailabilityTimeFromPresentationTime(presentationTime, mpd, isDynamic, calculateEnd) {\r\n        let availabilityTime = NaN;\r\n\r\n        if (calculateEnd) {\r\n            //@timeShiftBufferDepth specifies the duration of the time shifting buffer that is guaranteed\r\n            // to be available for a Media Presentation with type 'dynamic'.\r\n            // When not present, the value is infinite.\r\n            if (isDynamic && (mpd.timeShiftBufferDepth != Number.POSITIVE_INFINITY)) {\r\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + ((presentationTime + mpd.timeShiftBufferDepth) * 1000));\r\n            } else {\r\n                availabilityTime = mpd.availabilityEndTime;\r\n            }\r\n        } else {\r\n            if (isDynamic) {\r\n                availabilityTime = new Date(mpd.availabilityStartTime.getTime() + (presentationTime - clientServerTimeShift) * 1000);\r\n            } else {\r\n                // in static mpd, all segments are available at the same time\r\n                availabilityTime = mpd.availabilityStartTime;\r\n            }\r\n        }\r\n\r\n        return availabilityTime;\r\n    }\r\n\r\n    function calcAvailabilityStartTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\r\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic);\r\n    }\r\n\r\n    function calcAvailabilityEndTimeFromPresentationTime(presentationTime, mpd, isDynamic) {\r\n        return calcAvailabilityTimeFromPresentationTime.call(this, presentationTime, mpd, isDynamic, true);\r\n    }\r\n\r\n    function calcPresentationTimeFromWallTime(wallTime, period) {\r\n        return ((wallTime.getTime() - period.mpd.availabilityStartTime.getTime() + clientServerTimeShift * 1000) / 1000);\r\n    }\r\n\r\n    function calcPresentationTimeFromMediaTime(mediaTime, representation) {\r\n        const periodStart = representation.adaptation.period.start;\r\n        const presentationOffset = representation.presentationTimeOffset;\r\n\r\n        return mediaTime + (periodStart - presentationOffset);\r\n    }\r\n\r\n    function calcMediaTimeFromPresentationTime(presentationTime, representation) {\r\n        const periodStart = representation.adaptation.period.start;\r\n        const presentationOffset = representation.presentationTimeOffset;\r\n\r\n        return presentationTime - periodStart + presentationOffset;\r\n    }\r\n\r\n    function calcWallTimeForSegment(segment, isDynamic) {\r\n        let suggestedPresentationDelay,\r\n            displayStartTime,\r\n            wallTime;\r\n\r\n        if (isDynamic) {\r\n            suggestedPresentationDelay = segment.representation.adaptation.period.mpd.suggestedPresentationDelay;\r\n            displayStartTime = segment.presentationStartTime + suggestedPresentationDelay;\r\n            wallTime = new Date(segment.availabilityStartTime.getTime() + (displayStartTime * 1000));\r\n        }\r\n\r\n        return wallTime;\r\n    }\r\n\r\n    function calcSegmentAvailabilityRange(voRepresentation, isDynamic) {\r\n        // Static Range Finder\r\n        const voPeriod = voRepresentation.adaptation.period;\r\n        const range = { start: voPeriod.start, end: voPeriod.start + voPeriod.duration };\r\n        if (!isDynamic) return range;\r\n\r\n        if (!isClientServerTimeSyncCompleted && voRepresentation.segmentAvailabilityRange) {\r\n            return voRepresentation.segmentAvailabilityRange;\r\n        }\r\n\r\n        // Dynamic Range Finder\r\n        const d = voRepresentation.segmentDuration || (voRepresentation.segments && voRepresentation.segments.length ? voRepresentation.segments[voRepresentation.segments.length - 1].duration : 0);\r\n        const now = calcPresentationTimeFromWallTime(new Date(), voPeriod);\r\n        const periodEnd = voPeriod.start + voPeriod.duration;\r\n        range.start = Math.max((now - voPeriod.mpd.timeShiftBufferDepth), voPeriod.start);\r\n\r\n        const endOffset = voRepresentation.availabilityTimeOffset !== undefined &&\r\n            voRepresentation.availabilityTimeOffset < d ? d - voRepresentation.availabilityTimeOffset : d;\r\n        range.end = now >= periodEnd && now - endOffset < periodEnd ? periodEnd : now - endOffset;\r\n\r\n        return range;\r\n    }\r\n\r\n    function calcPeriodRelativeTimeFromMpdRelativeTime(representation, mpdRelativeTime) {\r\n        const periodStartTime = representation.adaptation.period.start;\r\n        return mpdRelativeTime - periodStartTime;\r\n    }\r\n\r\n    /*\r\n    * We need to figure out if we want to timesync for segmentTimeine where useCalculatedLiveEdge = true\r\n    * seems we figure out client offset based on logic in liveEdgeFinder getLiveEdge timelineConverter.setClientTimeOffset(liveEdge - representationInfo.DVRWindow.end);\r\n    * FYI StreamController's onManifestUpdated entry point to timeSync\r\n    * */\r\n    function onTimeSyncComplete(e) {\r\n\r\n        if (isClientServerTimeSyncCompleted) return;\r\n\r\n        if (e.offset !== undefined) {\r\n            setClientTimeOffset(e.offset / 1000);\r\n            isClientServerTimeSyncCompleted = true;\r\n\r\n        }\r\n    }\r\n\r\n    function calcMSETimeOffset(representation) {\r\n        // The MSEOffset is offset from AST for media. It is Period@start - presentationTimeOffset\r\n        const presentationOffset = representation.presentationTimeOffset;\r\n        const periodStart = representation.adaptation.period.start;\r\n        return (periodStart - presentationOffset);\r\n    }\r\n\r\n    function resetInitialSettings() {\r\n        clientServerTimeShift = 0;\r\n        isClientServerTimeSyncCompleted = false;\r\n        expectedLiveEdge = NaN;\r\n    }\r\n\r\n    function reset() {\r\n        eventBus.off(Events.TIME_SYNCHRONIZATION_COMPLETED, onTimeSyncComplete, this);\r\n        resetInitialSettings();\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        isTimeSyncCompleted: isTimeSyncCompleted,\r\n        setTimeSyncCompleted: setTimeSyncCompleted,\r\n        getClientTimeOffset: getClientTimeOffset,\r\n        setClientTimeOffset: setClientTimeOffset,\r\n        getExpectedLiveEdge: getExpectedLiveEdge,\r\n        setExpectedLiveEdge: setExpectedLiveEdge,\r\n        calcAvailabilityStartTimeFromPresentationTime: calcAvailabilityStartTimeFromPresentationTime,\r\n        calcAvailabilityEndTimeFromPresentationTime: calcAvailabilityEndTimeFromPresentationTime,\r\n        calcPresentationTimeFromWallTime: calcPresentationTimeFromWallTime,\r\n        calcPresentationTimeFromMediaTime: calcPresentationTimeFromMediaTime,\r\n        calcPeriodRelativeTimeFromMpdRelativeTime: calcPeriodRelativeTimeFromMpdRelativeTime,\r\n        calcMediaTimeFromPresentationTime: calcMediaTimeFromPresentationTime,\r\n        calcSegmentAvailabilityRange: calcSegmentAvailabilityRange,\r\n        calcWallTimeForSegment: calcWallTimeForSegment,\r\n        calcMSETimeOffset: calcMSETimeOffset,\r\n        reset: reset\r\n    };\r\n\r\n    return instance;\r\n}\r\n\r\nTimelineConverter.__dashjs_factory_name = 'TimelineConverter';\r\nexport default FactoryMaker.getSingletonFactory(TimelineConverter);"]}