{"version":3,"sources":["../../../../src/offline/OfflineDownload.js"],"names":["EventBus","Events","FactoryMaker","Debug","OfflineConstants","ManifestUpdater","BaseURLController","OfflineStream","OfflineIndexDBManifestParser","OfflineDownload","params","context","instance","adapter","schemeLoaderFactory","baseURLController","manifestId","manifestLoader","manifestModel","manifestUpdater","dashManifestModel","mediaPlayerModel","offlineStoreController","XMLManifest","errHandler","streams","manifest","isDownloadingStatus","isComposed","logger","eventBus","getInstance","setup","id","create","getLogger","setConfig","config","initialize","getId","downloadFromUrl","url","setupOfflineEvents","load","offlineManifest","OFFLINE_STATUS_CREATED","OFFLINE_SCHEME","createOfflineManifest","on","MANIFEST_UPDATED","onManifestUpdated","ORIGINAL_MANIFEST_LOADED","onOriginalManifestLoaded","setupIndexedDBEvents","INDEXEDDB_QUOTA_EXCEED_ERROR","stopDownload","INDEXEDDB_INVALID_STATE_ERROR","isDownloading","e","error","composeStreams","getDownloadableRepresentations","trigger","STREAMS_COMPOSED","err","Error","onDownloadingStarted","setDownloadingStatus","OFFLINE_STATUS_STARTED","DOWNLOADING_STARTED","message","onDownloadingFinished","OFFLINE_STATUS_FINISHED","DOWNLOADING_FINISHED","resetDownload","updatePeriods","streamsInfo","getStreamsInfo","length","i","ln","streamInfo","stream","started","finished","push","info","forEach","createFragmentStore","updateOfflineManifest","originalManifest","initializeAllMediasInfoList","selectedRepresentations","startDownload","generateOfflineManifest","then","parser","allMediaInfos","parse","parsedManifest","Promise","reject","catch","stopOfflineStreamProcessors","OFFLINE_STATUS_STOPPED","DOWNLOADING_STOPPED","sender","status","deleteDownload","resumeDownload","resumeOfflineStreamProcessors","getDownloadProgression","globalProgression","Math","round","reset","off","resetOfflineEvents","resetIndexedDBEvents","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"OfflineDownload.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport EventBus from '../core/EventBus';\r\nimport Events from '../core/events/Events';\r\nimport FactoryMaker from '../core/FactoryMaker';\r\nimport Debug from '../core/Debug';\r\nimport OfflineConstants from './constants/OfflineConstants';\r\nimport ManifestUpdater from '../streaming/ManifestUpdater';\r\nimport BaseURLController from '../streaming/controllers/BaseURLController';\r\nimport OfflineStream from './OfflineStream';\r\nimport OfflineIndexDBManifestParser from './utils/OfflineIndexDBManifestParser';\r\n\r\n/**\r\n * @class OfflineDownload\r\n */\r\nfunction OfflineDownload(params) {\r\n\r\n    const context = this.context;\r\n\r\n    let instance,\r\n        adapter,\r\n        schemeLoaderFactory,\r\n        baseURLController,\r\n        manifestId,\r\n        manifestLoader,\r\n        manifestModel,\r\n        manifestUpdater,\r\n        dashManifestModel,\r\n        mediaPlayerModel,\r\n        offlineStoreController,\r\n        XMLManifest,\r\n        errHandler,\r\n        streams,\r\n        manifest,\r\n        isDownloadingStatus,\r\n        isComposed,\r\n        logger;\r\n\r\n    const eventBus = EventBus(context).getInstance();\r\n\r\n    function setup() {\r\n        manifestId = params.id;\r\n\r\n        manifestUpdater = ManifestUpdater(context).create();\r\n        baseURLController = BaseURLController(context).create();\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n\r\n        streams = [];\r\n        isDownloadingStatus = false;\r\n        isComposed = false;\r\n    }\r\n\r\n    function setConfig(config) {\r\n        if (!config) return;\r\n\r\n        if (config.manifestLoader) {\r\n            manifestLoader = config.manifestLoader;\r\n        }\r\n\r\n        if (config.manifestModel) {\r\n            manifestModel = config.manifestModel;\r\n        }\r\n\r\n        if (config.dashManifestModel) {\r\n            dashManifestModel = config.dashManifestModel;\r\n        }\r\n\r\n        if (config.mediaPlayerModel) {\r\n            mediaPlayerModel = config.mediaPlayerModel;\r\n        }\r\n\r\n        if (config.adapter) {\r\n            adapter = config.adapter;\r\n        }\r\n\r\n        if (config.errHandler) {\r\n            errHandler = config.errHandler;\r\n        }\r\n\r\n        if (config.schemeLoaderFactory) {\r\n            schemeLoaderFactory = config.schemeLoaderFactory;\r\n        }\r\n\r\n        if (config.offlineStoreController) {\r\n            offlineStoreController = config.offlineStoreController;\r\n        }\r\n\r\n        baseURLController.setConfig({\r\n            dashManifestModel: dashManifestModel\r\n        });\r\n\r\n        manifestUpdater.setConfig({\r\n            manifestModel: manifestModel,\r\n            dashManifestModel: dashManifestModel,\r\n            manifestLoader: manifestLoader,\r\n            errHandler: errHandler\r\n        });\r\n\r\n        manifestUpdater.initialize();\r\n    }\r\n\r\n    function getId() {\r\n        return manifestId;\r\n    }\r\n\r\n    /**\r\n     * Download a stream, from url of manifest\r\n     * @param {string} url\r\n     * @instance\r\n     */\r\n    function downloadFromUrl(url) {\r\n        setupOfflineEvents();\r\n        manifestLoader.load(url);\r\n        isDownloadingStatus = true;\r\n\r\n        let offlineManifest = {\r\n            'fragmentStore': manifestId,\r\n            'status': OfflineConstants.OFFLINE_STATUS_CREATED,\r\n            'manifestId': manifestId,\r\n            'url': OfflineConstants.OFFLINE_SCHEME + '://' + manifestId,\r\n            'originalURL': url\r\n        };\r\n        return createOfflineManifest(offlineManifest);\r\n    }\r\n\r\n    function setupOfflineEvents() {\r\n        eventBus.on(Events.MANIFEST_UPDATED, onManifestUpdated, instance);\r\n        eventBus.on(Events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance);\r\n        setupIndexedDBEvents();\r\n    }\r\n\r\n    function setupIndexedDBEvents() {\r\n        eventBus.on(Events.INDEXEDDB_QUOTA_EXCEED_ERROR, stopDownload, instance);\r\n        eventBus.on(Events.INDEXEDDB_INVALID_STATE_ERROR, stopDownload, instance);\r\n    }\r\n\r\n    function isDownloading() {\r\n        return isDownloadingStatus;\r\n    }\r\n\r\n    function onManifestUpdated(e) {\r\n        if (isComposed) {\r\n            return;\r\n        }\r\n        if (!e.error) {\r\n            try {\r\n                manifest = e.manifest;\r\n\r\n                // initialise offline streams\r\n                composeStreams(manifest);\r\n\r\n                // get downloadable representations\r\n                getDownloadableRepresentations();\r\n\r\n                eventBus.trigger(Events.STREAMS_COMPOSED);\r\n            } catch (err) {\r\n                throw new Error(err);\r\n            }\r\n        }\r\n    }\r\n\r\n    function onDownloadingStarted(e) {\r\n        if (e.id !== manifestId) {\r\n            return;\r\n        }\r\n        if (!e.error && manifestId !== null) {\r\n            offlineStoreController.setDownloadingStatus(manifestId, OfflineConstants.OFFLINE_STATUS_STARTED);\r\n            eventBus.trigger(Events.DOWNLOADING_STARTED, {id: manifestId, message: 'Downloading started for this stream !'});\r\n        } else {\r\n            throw e.error;\r\n        }\r\n    }\r\n\r\n    function onDownloadingFinished(e) {\r\n        if (e.id !== manifestId) {\r\n            return;\r\n        }\r\n        if (!e.error && manifestId !== null) {\r\n            offlineStoreController.setDownloadingStatus(manifestId, OfflineConstants.OFFLINE_STATUS_FINISHED);\r\n            eventBus.trigger(Events.DOWNLOADING_FINISHED, {id: manifestId, message: 'Downloading has been successfully completed for this stream !'});\r\n        } else {\r\n            throw e.error;\r\n        }\r\n        resetDownload();\r\n    }\r\n\r\n    function composeStreams() {\r\n        try {\r\n            adapter.updatePeriods(manifest);\r\n            baseURLController.initialize(manifest);\r\n            const streamsInfo = adapter.getStreamsInfo();\r\n            if (streamsInfo.length === 0) {\r\n                throw new Error('There are no streams');\r\n            }\r\n            for (let i = 0, ln = streamsInfo.length; i < ln; i++) {\r\n                const streamInfo = streamsInfo[i];\r\n                let stream = OfflineStream(context).create({\r\n                    id: manifestId,\r\n                    started: onDownloadingStarted,\r\n                    finished: onDownloadingFinished\r\n                });\r\n                stream.setConfig({\r\n                    dashManifestModel: dashManifestModel,\r\n                    adapter: adapter,\r\n                    errHandler: errHandler,\r\n                    baseURLController: baseURLController,\r\n                    mediaPlayerModel: mediaPlayerModel,\r\n                    offlineStoreController: offlineStoreController\r\n                });\r\n                streams.push(stream);\r\n\r\n                // initialise stream and get downloadable representations\r\n                stream.initialize(streamInfo);\r\n            }\r\n            isComposed = true;\r\n        } catch (e) {\r\n            logger.info(e);\r\n            throw e.error;\r\n        }\r\n    }\r\n\r\n    function getDownloadableRepresentations() {\r\n        streams.forEach(stream => {\r\n            stream.getDownloadableRepresentations();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Init databsse to store fragments\r\n     * @param {number} manifestId\r\n     * @instance\r\n     */\r\n    function createFragmentStore(manifestId) {\r\n        return offlineStoreController.createFragmentStore(manifestId);\r\n    }\r\n\r\n    /**\r\n     * Store in database the string representation of offline manifest (with only downloaded representations)\r\n     * @param {object} offlineManifest\r\n     * @instance\r\n     */\r\n    function createOfflineManifest(offlineManifest) {\r\n        return offlineStoreController.createOfflineManifest(offlineManifest);\r\n    }\r\n\r\n    /**\r\n     * Store in database the string representation of offline manifest (with only downloaded representations)\r\n     * @param {object} offlineManifest\r\n     * @instance\r\n     */\r\n    function updateOfflineManifest(offlineManifest) {\r\n        return offlineStoreController.updateOfflineManifest(offlineManifest);\r\n    }\r\n\r\n    /**\r\n     * Triggered when manifest is loaded from internet.\r\n     * @param {Object[]} e\r\n     */\r\n    function onOriginalManifestLoaded(e) {\r\n        XMLManifest = e.originalManifest;\r\n    }\r\n\r\n    function initializeAllMediasInfoList(selectedRepresentations) {\r\n        for (let i = 0; i < streams.length; i++) {\r\n            streams[i].initializeAllMediasInfoList(selectedRepresentations);\r\n        }\r\n    }\r\n\r\n    function startDownload(selectedRepresentations) {\r\n        try {\r\n            createFragmentStore(manifestId);\r\n            generateOfflineManifest(XMLManifest, selectedRepresentations, manifestId).then(function () {\r\n                initializeAllMediasInfoList(selectedRepresentations);\r\n            });\r\n        } catch (err) {\r\n            throw new Error(err);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Create the parser used to convert original manifest in offline manifest\r\n     * Creates a JSON object that will be stored in database\r\n     * @param {string} XMLManifest\r\n     * @param {Object[]} selectedRepresentations\r\n     * @param {number} manifestId\r\n     * @instance\r\n     */\r\n    function generateOfflineManifest(XMLManifest, selectedRepresentations, manifestId) {\r\n        let parser = OfflineIndexDBManifestParser(context).create({\r\n            manifestId: manifestId,\r\n            allMediaInfos: selectedRepresentations\r\n        });\r\n\r\n        return parser.parse(XMLManifest).then(function (parsedManifest) {\r\n            if (parsedManifest !== null && manifestId !== null) {\r\n                let offlineManifest = {\r\n                    'fragmentStore': manifestId,\r\n                    'status': OfflineConstants.OFFLINE_STATUS_CREATED,\r\n                    'manifestId': manifestId,\r\n                    'url': OfflineConstants.OFFLINE_SCHEME + '://' + manifestId,\r\n                    'originalURL': manifest.url,\r\n                    'manifest': parsedManifest\r\n                };\r\n                return updateOfflineManifest(offlineManifest);\r\n            } else {\r\n                return Promise.reject('falling parsing offline manifest');\r\n            }\r\n        }).catch(function (err) {\r\n            return Promise.reject(err);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Stops downloading of fragments\r\n     * @instance\r\n     */\r\n    function stopDownload() {\r\n        if (manifestId !== null && isDownloading) {\r\n            for (let i = 0, ln = streams.length; i < ln; i++) {\r\n                streams[i].stopOfflineStreamProcessors();\r\n            }\r\n            offlineStoreController.setDownloadingStatus(manifestId, OfflineConstants.OFFLINE_STATUS_STOPPED);\r\n            eventBus.trigger(Events.DOWNLOADING_STOPPED, {\r\n                sender: this,\r\n                id: manifestId,\r\n                status: OfflineConstants.OFFLINE_STATUS_STOPPED,\r\n                message: 'Downloading has been stopped for this stream !'\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Delete an offline manifest (and all of its data)\r\n     * @instance\r\n     */\r\n    function deleteDownload() {\r\n        if (streams.length >= 1) {\r\n            stopDownload();\r\n            isDownloadingStatus = false;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resume download of a stream\r\n     * @instance\r\n     */\r\n    function resumeDownload() {\r\n        if (isDownloading()) {\r\n            for (let i = 0, ln = streams.length; i < ln; i++) {\r\n                streams[i].resumeOfflineStreamProcessors();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Compute the progression of download\r\n     * @instance\r\n     */\r\n    function getDownloadProgression() {\r\n        let globalProgression = 0;\r\n        for (let i = 0, ln = streams.length; i < ln; i++) {\r\n            globalProgression = +streams[i].getDownloadProgression();\r\n        }\r\n        return Math.round(globalProgression * 100);\r\n    }\r\n\r\n    /**\r\n     * Reset events listeners\r\n     * @instance\r\n     */\r\n    function resetDownload() {\r\n        for (let i = 0, ln = streams.length; i < ln; i++) {\r\n            streams[i].reset();\r\n        }\r\n        isDownloadingStatus = false;\r\n        streams = [];\r\n        manifestId = null;\r\n        eventBus.off(Events.MANIFEST_UPDATED, onManifestUpdated, instance);\r\n        eventBus.off(Events.ORIGINAL_MANIFEST_LOADED, onOriginalManifestLoaded, instance);\r\n        resetOfflineEvents();\r\n    }\r\n\r\n    function resetOfflineEvents() {\r\n        resetIndexedDBEvents();\r\n    }\r\n\r\n    function resetIndexedDBEvents() {\r\n        eventBus.off(Events.INDEXEDDB_QUOTA_EXCEED_ERROR, stopDownload, instance);\r\n        eventBus.off(Events.INDEXEDDB_INVALID_STATE_ERROR, stopDownload, instance);\r\n    }\r\n\r\n    /**\r\n     * Reset\r\n     * @instance\r\n     */\r\n    function reset() {\r\n        if (isDownloading()) {\r\n            resetDownload();\r\n        }\r\n        baseURLController.reset();\r\n        manifestUpdater.reset();\r\n        offlineStoreController = null;\r\n    }\r\n\r\n    instance = {\r\n        reset: reset,\r\n        getId: getId,\r\n        setConfig: setConfig,\r\n        downloadFromUrl: downloadFromUrl,\r\n        startDownload: startDownload,\r\n        stopDownload: stopDownload,\r\n        resumeDownload: resumeDownload,\r\n        deleteDownload: deleteDownload,\r\n        getDownloadProgression: getDownloadProgression,\r\n        isDownloading: isDownloading,\r\n        resetDownload: resetDownload\r\n    };\r\n\r\n    setup();\r\n\r\n    return instance;\r\n}\r\n\r\nOfflineDownload.__dashjs_factory_name = 'OfflineDownload';\r\nexport default FactoryMaker.getClassFactory(OfflineDownload);\r\n"]}