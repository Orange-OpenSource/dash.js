{"version":3,"sources":["../../../../src/offline/OfflineStream.js"],"names":["EventBus","Events","OfflineEvents","FactoryMaker","Debug","OfflineStreamProcessor","Constants","OfflineStream","config","context","eventBus","getInstance","instance","manifestId","startedCb","finishedCb","adapter","baseURLController","dashManifestModel","mediaPlayerModel","offlineStreamProcessor","offlineStreamProcessors","offlineStoreController","startedOfflineStreamProcessors","finishedOfflineStreamProcessors","errHandler","streamInfo","availableSegments","allMediasInfosList","logger","setup","getLogger","resetInitialSettings","extend","id","started","finished","setConfig","initialize","initStreamInfo","on","DATA_UPDATE_COMPLETED","onDataUpdateCompleted","getDownloadableRepresentations","downloadableRepresentations","video","audio","mediaInfo","getAllMediaInfoForType","VIDEO","length","forEach","item","bitrateList","bitrate","push","bandwidth","width","height","AUDIO","lang","trigger","DOWNLOADABLE_REPRESENTATIONS_LOADED","data","sender","initializeAllMediasInfoList","mediasInfoList","initializeMedia","setAvailableSegments","createOfflineStreamProcessorFor","type","allMediaInfoForType","media","filter","indexOf","createStreamProcessor","streamProcessor","create","completed","onStreamCompleted","mimeType","stream","message","e","sp","getStreamProcessor","getStreamInfo","start","checkIfAllOfflineStreamProcessorsStarted","getStartTime","NaN","getDuration","duration","stopOfflineStreamProcessors","i","stop","resumeOfflineStreamProcessors","resume","DOWNLOADING_STARTED","getDownloadProgression","getDownloadedSegments","getAvailableSegmentsNumber","deactivate","ln","fragmentModel","getFragmentModel","removeExecutedRequestsBeforeTime","reset","off","__dashjs_factory_name","getClassFactory"],"mappings":"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","file":"OfflineStream.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport EventBus from './../core/EventBus';\r\nimport Events from './../core/events/Events';\r\nimport OfflineEvents from './events/OfflineEvents';\r\nimport FactoryMaker from './../core/FactoryMaker';\r\nimport Debug from './../core/Debug';\r\nimport OfflineStreamProcessor from './OfflineStreamProcessor';\r\nimport Constants from './../streaming/constants/Constants';\r\n\r\n/**\r\n * @module  OfflineStream\r\n * @description Initialize and Manage Offline Stream for each type\r\n * @param {Object} config - dependences\r\n */\r\nfunction OfflineStream(config) {\r\n\r\n    config = config || {};\r\n    const context = this.context;\r\n    const eventBus = EventBus(context).getInstance();\r\n\r\n    let instance,\r\n        manifestId,\r\n        startedCb,\r\n        finishedCb,\r\n        adapter,\r\n        baseURLController,\r\n        dashManifestModel,\r\n        mediaPlayerModel,\r\n        offlineStreamProcessor,\r\n        offlineStreamProcessors,\r\n        offlineStoreController,\r\n        startedOfflineStreamProcessors,\r\n        finishedOfflineStreamProcessors,\r\n        errHandler,\r\n        streamInfo,\r\n        availableSegments,\r\n        allMediasInfosList,\r\n        logger;\r\n\r\n    function setup() {\r\n        logger = Debug(context).getInstance().getLogger(instance);\r\n        resetInitialSettings();\r\n        Events.extend(OfflineEvents);\r\n\r\n        manifestId = config.id;\r\n        startedCb = config.started;\r\n        finishedCb = config.finished;\r\n    }\r\n\r\n    /**\r\n     * Reset\r\n     */\r\n    function resetInitialSettings() {\r\n        offlineStreamProcessors = [];\r\n        availableSegments = 0;\r\n        streamInfo = null;\r\n        offlineStreamProcessors = [];\r\n        startedOfflineStreamProcessors = 0;\r\n        finishedOfflineStreamProcessors = 0;\r\n        allMediasInfosList = [];\r\n    }\r\n\r\n    function setConfig(config) {\r\n        if (!config) return;\r\n\r\n        if (config.dashManifestModel) {\r\n            dashManifestModel = config.dashManifestModel;\r\n        }\r\n\r\n        if (config.adapter) {\r\n            adapter = config.adapter;\r\n        }\r\n\r\n        if (config.errHandler) {\r\n            errHandler = config.errHandler;\r\n        }\r\n\r\n        if (config.baseURLController) {\r\n            baseURLController = config.baseURLController;\r\n        }\r\n\r\n        if (config.mediaPlayerModel) {\r\n            mediaPlayerModel = config.mediaPlayerModel;\r\n        }\r\n\r\n        if (config.offlineStoreController) {\r\n            offlineStoreController = config.offlineStoreController;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Initialize offlinestream\r\n     * @param {Object} initStreamInfo\r\n     */\r\n    function initialize(initStreamInfo) {\r\n        streamInfo = initStreamInfo;\r\n        eventBus.on(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\r\n    }\r\n\r\n    /**\r\n     * Creates media bitrate list, so that user will be able to choose the representation he wants to download\r\n     */\r\n    function getDownloadableRepresentations() {\r\n        let downloadableRepresentations = {\r\n            video: [],\r\n            audio: []\r\n        };\r\n        let mediaInfo = adapter.getAllMediaInfoForType(streamInfo, Constants.VIDEO);\r\n        if (mediaInfo.length > 0) {\r\n            mediaInfo.forEach((item) => {\r\n                item.bitrateList.forEach((bitrate) => {\r\n                    downloadableRepresentations.video.push({\r\n                        id: bitrate.id,\r\n                        bandwidth: bitrate.bandwidth,\r\n                        width: bitrate.width,\r\n                        height: bitrate.height\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        mediaInfo = adapter.getAllMediaInfoForType(streamInfo, Constants.AUDIO);\r\n        if (mediaInfo.length > 0) {\r\n            mediaInfo.forEach((item) => {\r\n                item.bitrateList.forEach((bitrate) => {\r\n                    downloadableRepresentations.audio.push({\r\n                        id: bitrate.id,\r\n                        bandwidth: bitrate.bandwidth,\r\n                        lang: item.lang\r\n                    });\r\n                });\r\n            });\r\n        }\r\n        /** 1st, we download audio and video.\r\n        mediaInfo = adapter.getAllMediaInfoForType(streamInfo, Constants.TEXT);\r\n        if (mediaInfo.length > 0) {\r\n            downloadableRepresentations.push(mediaInfo);\r\n        }\r\n        mediaInfo = adapter.getAllMediaInfoForType(streamInfo, Constants.FRAGMENTED_TEXT);\r\n        if (mediaInfo.length > 0) {\r\n            downloadableRepresentations.push(mediaInfo);\r\n        }\r\n        mediaInfo = adapter.getAllMediaInfoForType(streamInfo, Constants.EMBEDDED_TEXT);\r\n        if (mediaInfo.length > 0) {\r\n            downloadableRepresentations.push(mediaInfo);\r\n        }\r\n        mediaInfo = adapter.getAllMediaInfoForType(streamInfo, Constants.MUXED);\r\n        if (mediaInfo.length > 0) {\r\n            downloadableRepresentations.push(mediaInfo);\r\n        }\r\n        mediaInfo = adapter.getAllMediaInfoForType(streamInfo, Constants.IMAGE);\r\n        if (mediaInfo.length > 0) {\r\n            downloadableRepresentations.push(mediaInfo);\r\n        }\r\n        */\r\n\r\n        eventBus.trigger(Events.DOWNLOADABLE_REPRESENTATIONS_LOADED, {\r\n            data: {\r\n                id: manifestId,\r\n                downloadableRepresentations: downloadableRepresentations\r\n            },\r\n            sender: this\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * Initialize with choosen representations by user\r\n     * @param {Object} mediasInfoList\r\n     */\r\n    function initializeAllMediasInfoList(mediasInfoList) {\r\n        allMediasInfosList = mediasInfoList;\r\n        initializeMedia(streamInfo);\r\n        setAvailableSegments();\r\n    }\r\n\r\n    /**\r\n     * Initialize media for each type\r\n     * @param {Object} streamInfo\r\n     */\r\n    function initializeMedia(streamInfo) {\r\n        createOfflineStreamProcessorFor(Constants.VIDEO,streamInfo);\r\n        createOfflineStreamProcessorFor(Constants.AUDIO,streamInfo);\r\n        /* 1st, we download audio and video.\r\n        createOfflineStreamProcessorFor(Constants.TEXT,streamInfo);\r\n        createOfflineStreamProcessorFor(Constants.FRAGMENTED_TEXT,streamInfo);\r\n        createOfflineStreamProcessorFor(Constants.EMBEDDED_TEXT,streamInfo);\r\n        createOfflineStreamProcessorFor(Constants.MUXED,streamInfo);\r\n        createOfflineStreamProcessorFor(Constants.IMAGE,streamInfo);\r\n        */\r\n    }\r\n\r\n    function createOfflineStreamProcessorFor(type, streamInfo) {\r\n        // filter mediaInfo according to choosen representation id\r\n        let allMediaInfoForType = adapter.getAllMediaInfoForType(streamInfo, type);\r\n        allMediaInfoForType.forEach((media) => {\r\n            media.bitrateList = media.bitrateList.filter((bitrate) => {\r\n                if (allMediasInfosList[type] && allMediasInfosList[type].indexOf(bitrate.id) !== -1) {\r\n                    return true;\r\n                }\r\n                return false;\r\n            });\r\n        });\r\n\r\n        allMediaInfoForType = allMediaInfoForType.filter((media) => {\r\n            return (media.bitrateList && media.bitrateList.length > 0);\r\n        });\r\n\r\n        // cration of an offline stream processor for each choosen representation\r\n        allMediaInfoForType.forEach((mediaInfo) => {\r\n            if (mediaInfo.bitrateList) {\r\n                mediaInfo.bitrateList.forEach((bitrate) => {\r\n                    createStreamProcessor(mediaInfo, bitrate);\r\n                });\r\n            }\r\n        });\r\n        return allMediaInfoForType;\r\n    }\r\n\r\n    function createStreamProcessor (mediaInfo, bitrate) {\r\n\r\n        let streamProcessor = OfflineStreamProcessor(context).create({\r\n            id: manifestId,\r\n            completed: onStreamCompleted\r\n        });\r\n        streamProcessor.setConfig({\r\n            type: mediaInfo.type,\r\n            mimeType: mediaInfo.mimeType,\r\n            mediaInfo: mediaInfo,\r\n            bitrate: bitrate,\r\n            adapter: adapter,\r\n            dashManifestModel: dashManifestModel,\r\n            baseURLController: baseURLController,\r\n            errHandler: errHandler,\r\n            stream: instance,\r\n            mediaPlayerModel: mediaPlayerModel,\r\n            offlineStoreController: offlineStoreController\r\n        });\r\n        offlineStreamProcessors.push(streamProcessor);\r\n        streamProcessor.initialize();\r\n    }\r\n\r\n    function onStreamCompleted() {\r\n        finishedOfflineStreamProcessors++;\r\n        if (finishedOfflineStreamProcessors === offlineStreamProcessors.length) {\r\n            finishedCb({sender: this, id: manifestId, message: 'Downloading has been successfully completed for this stream !'});\r\n        }\r\n    }\r\n\r\n    function onDataUpdateCompleted(e) {\r\n        let sp = e.sender.getStreamProcessor();\r\n        if (sp.getStreamInfo() !== streamInfo) {\r\n            return;\r\n        }\r\n\r\n        sp.start();\r\n        checkIfAllOfflineStreamProcessorsStarted();\r\n    }\r\n\r\n    function checkIfAllOfflineStreamProcessorsStarted() {\r\n        startedOfflineStreamProcessors++;\r\n        if (startedOfflineStreamProcessors === offlineStreamProcessors.length) {\r\n            startedCb({sender: this, id: manifestId, message: 'Downloading started for this stream !'});\r\n        }\r\n    }\r\n\r\n    function getStreamInfo() {\r\n        return streamInfo;\r\n    }\r\n\r\n    function getStartTime() {\r\n        return streamInfo ? streamInfo.start : NaN;\r\n    }\r\n\r\n    function getDuration() {\r\n        return streamInfo ? streamInfo.duration : NaN;\r\n    }\r\n\r\n    /**\r\n     * Stop offline stream processors\r\n     */\r\n    function stopOfflineStreamProcessors() {\r\n        for (let i = 0; i < offlineStreamProcessors.length; i++) {\r\n            offlineStreamProcessors[i].stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Resume offline stream processors\r\n     */\r\n    function resumeOfflineStreamProcessors() {\r\n        for (let i = 0; i < offlineStreamProcessors.length; i++) {\r\n            offlineStreamProcessors[i].resume();\r\n        }\r\n        eventBus.trigger(Events.DOWNLOADING_STARTED, {sender: this, id: manifestId, message: 'Downloading started for this stream !'});\r\n    }\r\n\r\n    /**\r\n     * Returns the progression (nbDownloaded/availableSegments)\r\n     * @returns {number} Download progression\r\n     */\r\n    function getDownloadProgression() {\r\n        let getDownloadedSegments = 0;\r\n\r\n        for (let i = 0; i < offlineStreamProcessors.length; i++) {\r\n            getDownloadedSegments = getDownloadedSegments + offlineStreamProcessors[i].getDownloadedSegments();\r\n        }\r\n        return getDownloadedSegments / availableSegments;\r\n    }\r\n\r\n    /**\r\n     * Initialize total numbers of segments\r\n     */\r\n    function setAvailableSegments() {\r\n        //TODO compter par taille de segments et non par le nombre\r\n        for (let i = 0; i < offlineStreamProcessors.length; i++) {\r\n            if (offlineStreamProcessors[i].getAvailableSegmentsNumber()) {\r\n                availableSegments = availableSegments +  offlineStreamProcessors[i].getAvailableSegmentsNumber();\r\n            } else {    //format différent\r\n                availableSegments = 0;\r\n            }\r\n        }\r\n    }\r\n\r\n    function deactivate() {\r\n        let ln = offlineStreamProcessors ? offlineStreamProcessors.length : 0;\r\n        for (let i = 0; i < ln; i++) {\r\n            let fragmentModel = offlineStreamProcessors[i].getFragmentModel();\r\n            fragmentModel.removeExecutedRequestsBeforeTime(getStartTime() + getDuration());\r\n            offlineStreamProcessors[i].reset();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Reset\r\n     */\r\n    function reset() {\r\n        stopOfflineStreamProcessors();\r\n        deactivate();\r\n        resetInitialSettings();\r\n\r\n        eventBus.off(Events.DATA_UPDATE_COMPLETED, onDataUpdateCompleted, this);\r\n    }\r\n\r\n    instance = {\r\n        initialize: initialize,\r\n        setConfig: setConfig,\r\n        getDownloadableRepresentations: getDownloadableRepresentations,\r\n        initializeAllMediasInfoList: initializeAllMediasInfoList,\r\n        offlineStreamProcessor: offlineStreamProcessor,\r\n        getStreamInfo: getStreamInfo,\r\n        stopOfflineStreamProcessors: stopOfflineStreamProcessors,\r\n        resumeOfflineStreamProcessors: resumeOfflineStreamProcessors,\r\n        getDownloadProgression: getDownloadProgression,\r\n        setAvailableSegments: setAvailableSegments,\r\n        reset: reset\r\n    };\r\n\r\n    setup();\r\n    return instance;\r\n}\r\n\r\nOfflineStream.__dashjs_factory_name = 'OfflineStream';\r\nexport default FactoryMaker.getClassFactory(OfflineStream);\r\n"]}