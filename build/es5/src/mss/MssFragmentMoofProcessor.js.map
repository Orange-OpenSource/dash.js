{"version":3,"sources":["../../../../src/mss/MssFragmentMoofProcessor.js"],"names":["DashJSError","MssErrors","Events","MssFragmentMoofProcessor","config","instance","type","logger","metricsModel","playbackController","errorHandler","errHandler","eventBus","ISOBoxer","debug","setup","getLogger","processTfrf","request","tfrf","tfdt","streamProcessor","representationController","getRepresentationController","representation","getCurrentRepresentation","indexHandler","getIndexHandler","manifest","adaptation","period","mpd","Period_asArray","index","AdaptationSet_asArray","timescale","SegmentTemplate","getType","timeShiftBufferDepth","error","MSS_NO_TFRF_CODE","MSS_NO_TFRF_MESSAGE","segments","SegmentTimeline","S","entries","entry","segmentTime","range","segment","t","availabilityStartTime","length","tManifest","parseFloat","fragment_absolute_time","start","end","baseMediaDecodeTime","duration","updateDVR","mediaType","getStreamInfo","manifestInfo","d","fragment_duration","push","trigger","MANIFEST_VALIDITY_CHANGED","sender","newDuration","Math","round","splice","updateSegmentList","dvrInfos","getMetricsFor","DVRInfo","addDVRInfo","getTime","getBoxOffset","parent","offset","i","boxes","size","convertFragment","e","sp","isoFile","parseBuffer","response","tfhd","fetch","track_ID","mediaInfo","traf","createFullBox","version","flags","floor","startTime","trun","tfxd","_parent","indexOf","sepiff","usertype","undefined","saio","entry_count","saiz","sample_count","default_sample_info_size","sample_info_size","NumberOfEntries","moof","getLength","data_offset","trafPosInMoof","sencPosInTraf","write","Error","__dashjs_factory_name","dashjs","FactoryMaker","getClassFactory"],"mappings":"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","file":"MssFragmentMoofProcessor.js","sourcesContent":["/**\r\n * The copyright in this software is being made available under the BSD License,\r\n * included below. This software may be subject to other third party and contributor\r\n * rights, including patent rights, and no such rights are granted under this license.\r\n *\r\n * Copyright (c) 2013, Dash Industry Forum.\r\n * All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *  list of conditions and the following disclaimer.\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *  this list of conditions and the following disclaimer in the documentation and/or\r\n *  other materials provided with the distribution.\r\n *  * Neither the name of Dash Industry Forum nor the names of its\r\n *  contributors may be used to endorse or promote products derived from this software\r\n *  without specific prior written permission.\r\n *\r\n *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY\r\n *  EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n *  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.\r\n *  IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT,\r\n *  INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT\r\n *  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR\r\n *  PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY,\r\n *  WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n *  ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n *  POSSIBILITY OF SUCH DAMAGE.\r\n */\r\nimport DashJSError from '../streaming/vo/DashJSError';\r\nimport MssErrors from './errors/MssErrors';\r\n\r\nimport Events from '../streaming/MediaPlayerEvents';\r\n\r\n/**\r\n * @module MssFragmentMoovProcessor\r\n * @param {Object} config object\r\n */\r\nfunction MssFragmentMoofProcessor(config) {\r\n\r\n    config = config || {};\r\n    let instance,\r\n        type,\r\n        logger;\r\n    const metricsModel = config.metricsModel;\r\n    const playbackController = config.playbackController;\r\n    const errorHandler = config.errHandler;\r\n    const eventBus = config.eventBus;\r\n    const ISOBoxer = config.ISOBoxer;\r\n    const debug = config.debug;\r\n\r\n    function setup() {\r\n        logger = debug.getLogger(instance);\r\n        type = '';\r\n    }\r\n\r\n    function processTfrf(request, tfrf, tfdt, streamProcessor) {\r\n        const representationController = streamProcessor.getRepresentationController();\r\n        const representation = representationController.getCurrentRepresentation();\r\n        const indexHandler = streamProcessor.getIndexHandler();\r\n\r\n        const manifest = representation.adaptation.period.mpd.manifest;\r\n        const adaptation = manifest.Period_asArray[representation.adaptation.period.index].AdaptationSet_asArray[representation.adaptation.index];\r\n        const timescale = adaptation.SegmentTemplate.timescale;\r\n\r\n        type = streamProcessor.getType();\r\n\r\n        if (manifest.type !== 'dynamic' && !manifest.timeShiftBufferDepth) {\r\n            return;\r\n        }\r\n\r\n        if (!tfrf) {\r\n            errorHandler.error(new DashJSError(MssErrors.MSS_NO_TFRF_CODE, MssErrors.MSS_NO_TFRF_MESSAGE));\r\n            return;\r\n        }\r\n\r\n        // Get adaptation's segment timeline (always a SegmentTimeline in Smooth Streaming use case)\r\n        const segments = adaptation.SegmentTemplate.SegmentTimeline.S;\r\n        const entries = tfrf.entry;\r\n        let entry,\r\n            segmentTime,\r\n            range;\r\n        let segment = null;\r\n        let t = 0;\r\n        let availabilityStartTime = null;\r\n\r\n        if (entries.length === 0) {\r\n            return;\r\n        }\r\n\r\n        // Consider only first tfrf entry (to avoid pre-condition failure on fragment info requests)\r\n        entry = entries[0];\r\n\r\n        // In case of start-over streams, check if we have reached end of original manifest duration (set in timeShiftBufferDepth)\r\n        // => then do not update anymore timeline\r\n        if (manifest.type === 'static') {\r\n            // Get first segment time\r\n            segmentTime = segments[0].tManifest ? parseFloat(segments[0].tManifest) : segments[0].t;\r\n            if (entry.fragment_absolute_time > (segmentTime + (manifest.timeShiftBufferDepth * timescale))) {\r\n                return;\r\n            }\r\n        }\r\n\r\n        logger.debug('entry - t = ', (entry.fragment_absolute_time / timescale));\r\n\r\n        // Get last segment time\r\n        segmentTime = segments[segments.length - 1].tManifest ? parseFloat(segments[segments.length - 1].tManifest) : segments[segments.length - 1].t;\r\n        logger.debug('Last segment - t = ', (segmentTime / timescale));\r\n\r\n        // Check if we have to append new segment to timeline\r\n        if (entry.fragment_absolute_time <= segmentTime) {\r\n            // Update DVR window range\r\n            // => set range end to end time of current segment\r\n            range = {\r\n                start: segments[0].t / timescale,\r\n                end: (tfdt.baseMediaDecodeTime / timescale) + request.duration\r\n            };\r\n\r\n            updateDVR(request.mediaType, range, streamProcessor.getStreamInfo().manifestInfo);\r\n            return;\r\n        }\r\n\r\n        logger.debug('Add new segment - t = ', (entry.fragment_absolute_time / timescale));\r\n        segment = {};\r\n        segment.t = entry.fragment_absolute_time;\r\n        segment.d = entry.fragment_duration;\r\n        // If timestamps starts at 0 relative to 1st segment (dynamic to static) then update segment time\r\n        if (segments[0].tManifest) {\r\n            segment.t -= parseFloat(segments[0].tManifest) - segments[0].t;\r\n            segment.tManifest = entry.fragment_absolute_time;\r\n        }\r\n        segments.push(segment);\r\n\r\n        // In case of static start-over streams, update content duration\r\n        if (manifest.type === 'static') {\r\n            if (type === 'video') {\r\n                segment = segments[segments.length - 1];\r\n                var end = (segment.t + segment.d) / timescale;\r\n                if (end > representation.adaptation.period.duration) {\r\n                    eventBus.trigger(Events.MANIFEST_VALIDITY_CHANGED, { sender: this, newDuration: end });\r\n                }\r\n            }\r\n            return;\r\n        }\r\n        // In case of live streams, update segment timeline according to DVR window\r\n        else if (manifest.timeShiftBufferDepth && manifest.timeShiftBufferDepth > 0) {\r\n            // Get timestamp of the last segment\r\n            segment = segments[segments.length - 1];\r\n            t = segment.t;\r\n\r\n            // Determine the segments' availability start time\r\n            availabilityStartTime = Math.round((t - (manifest.timeShiftBufferDepth * timescale)) / timescale);\r\n\r\n            // Remove segments prior to availability start time\r\n            segment = segments[0];\r\n            while (Math.round(segment.t / timescale) < availabilityStartTime) {\r\n                logger.debug('Remove segment  - t = ' + (segment.t / timescale));\r\n                segments.splice(0, 1);\r\n                segment = segments[0];\r\n            }\r\n\r\n            // Update DVR window range => set range end to end time of current segment\r\n            range = {\r\n                start: segments[0].t / timescale,\r\n                end: (tfdt.baseMediaDecodeTime / timescale) + request.duration\r\n            };\r\n\r\n            updateDVR(type, range, streamProcessor.getStreamInfo().manifestInfo);\r\n        }\r\n\r\n        indexHandler.updateSegmentList(representation);\r\n    }\r\n\r\n    function updateDVR(type, range, manifestInfo) {\r\n        const dvrInfos = metricsModel.getMetricsFor(type).DVRInfo;\r\n        if (dvrInfos) {\r\n            if (dvrInfos.length === 0 || (dvrInfos.length > 0 && range.end > dvrInfos[dvrInfos.length - 1].range.end)) {\r\n                logger.debug('Update DVR Infos [' + range.start + ' - ' + range.end + ']');\r\n                metricsModel.addDVRInfo(type, playbackController.getTime(), manifestInfo, range);\r\n            }\r\n        }\r\n    }\r\n\r\n    // This function returns the offset of the 1st byte of a child box within a container box\r\n    function getBoxOffset(parent, type) {\r\n        let offset = 8;\r\n        let i = 0;\r\n\r\n        for (i = 0; i < parent.boxes.length; i++) {\r\n            if (parent.boxes[i].type === type) {\r\n                return offset;\r\n            }\r\n            offset += parent.boxes[i].size;\r\n        }\r\n        return offset;\r\n    }\r\n\r\n    function convertFragment(e, sp) {\r\n        let i;\r\n\r\n        // e.request contains request description object\r\n        // e.response contains fragment bytes\r\n        const isoFile = ISOBoxer.parseBuffer(e.response);\r\n        // Update track_Id in tfhd box\r\n        const tfhd = isoFile.fetch('tfhd');\r\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\r\n\r\n        // Add tfdt box\r\n        let tfdt = isoFile.fetch('tfdt');\r\n        const traf = isoFile.fetch('traf');\r\n        if (tfdt === null) {\r\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\r\n            tfdt.version = 1;\r\n            tfdt.flags = 0;\r\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\r\n        }\r\n\r\n        const trun = isoFile.fetch('trun');\r\n\r\n        // Process tfxd boxes\r\n        // This box provide absolute timestamp but we take the segment start time for tfdt\r\n        let tfxd = isoFile.fetch('tfxd');\r\n        if (tfxd) {\r\n            tfxd._parent.boxes.splice(tfxd._parent.boxes.indexOf(tfxd), 1);\r\n            tfxd = null;\r\n        }\r\n        let tfrf = isoFile.fetch('tfrf');\r\n        processTfrf(e.request, tfrf, tfdt, sp);\r\n        if (tfrf) {\r\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\r\n            tfrf = null;\r\n        }\r\n\r\n        // If protected content in PIFF1.1 format (sepiff box = Sample Encryption PIFF)\r\n        // => convert sepiff box it into a senc box\r\n        // => create saio and saiz boxes (if not already present)\r\n        const sepiff = isoFile.fetch('sepiff');\r\n        if (sepiff !== null) {\r\n            sepiff.type = 'senc';\r\n            sepiff.usertype = undefined;\r\n\r\n            let saio = isoFile.fetch('saio');\r\n            if (saio === null) {\r\n                // Create Sample Auxiliary Information Offsets Box box (saio)\r\n                saio = ISOBoxer.createFullBox('saio', traf);\r\n                saio.version = 0;\r\n                saio.flags = 0;\r\n                saio.entry_count = 1;\r\n                saio.offset = [0];\r\n\r\n                const saiz = ISOBoxer.createFullBox('saiz', traf);\r\n                saiz.version = 0;\r\n                saiz.flags = 0;\r\n                saiz.sample_count = sepiff.sample_count;\r\n                saiz.default_sample_info_size = 0;\r\n                saiz.sample_info_size = [];\r\n\r\n                if (sepiff.flags & 0x02) {\r\n                    // Sub-sample encryption => set sample_info_size for each sample\r\n                    for (i = 0; i < sepiff.sample_count; i += 1) {\r\n                        // 10 = 8 (InitializationVector field size) + 2 (subsample_count field size)\r\n                        // 6 = 2 (BytesOfClearData field size) + 4 (BytesOfEncryptedData field size)\r\n                        saiz.sample_info_size[i] = 10 + (6 * sepiff.entry[i].NumberOfEntries);\r\n                    }\r\n                } else {\r\n                    // No sub-sample encryption => set default sample_info_size = InitializationVector field size (8)\r\n                    saiz.default_sample_info_size = 8;\r\n                }\r\n            }\r\n        }\r\n\r\n        tfhd.flags &= 0xFFFFFE; // set tfhd.base-data-offset-present to false\r\n        tfhd.flags |= 0x020000; // set tfhd.default-base-is-moof to true\r\n        trun.flags |= 0x000001; // set trun.data-offset-present to true\r\n\r\n        // Update trun.data_offset field that corresponds to first data byte (inside mdat box)\r\n        const moof = isoFile.fetch('moof');\r\n        let length = moof.getLength();\r\n        trun.data_offset = length + 8;\r\n\r\n        // Update saio box offset field according to new senc box offset\r\n        let saio = isoFile.fetch('saio');\r\n        if (saio !== null) {\r\n            let trafPosInMoof = getBoxOffset(moof, 'traf');\r\n            let sencPosInTraf = getBoxOffset(traf, 'senc');\r\n            // Set offset from begin fragment to the first IV field in senc box\r\n            saio.offset[0] = trafPosInMoof + sencPosInTraf + 16; // 16 = box header (12) + sample_count field size (4)\r\n        }\r\n\r\n        // Write transformed/processed fragment into request reponse data\r\n        e.response = isoFile.write();\r\n    }\r\n\r\n    function updateSegmentList(e, sp) {\r\n        // e.request contains request description object\r\n        // e.response contains fragment bytes\r\n        if (!e.response) {\r\n            throw new Error('e.response parameter is missing');\r\n        }\r\n\r\n        const isoFile = ISOBoxer.parseBuffer(e.response);\r\n        // Update track_Id in tfhd box\r\n        const tfhd = isoFile.fetch('tfhd');\r\n        tfhd.track_ID = e.request.mediaInfo.index + 1;\r\n\r\n        // Add tfdt box\r\n        let tfdt = isoFile.fetch('tfdt');\r\n        let traf = isoFile.fetch('traf');\r\n        if (tfdt === null) {\r\n            tfdt = ISOBoxer.createFullBox('tfdt', traf, tfhd);\r\n            tfdt.version = 1;\r\n            tfdt.flags = 0;\r\n            tfdt.baseMediaDecodeTime = Math.floor(e.request.startTime * e.request.timescale);\r\n        }\r\n\r\n        let tfrf = isoFile.fetch('tfrf');\r\n        processTfrf(e.request, tfrf, tfdt, sp);\r\n        if (tfrf) {\r\n            tfrf._parent.boxes.splice(tfrf._parent.boxes.indexOf(tfrf), 1);\r\n            tfrf = null;\r\n        }\r\n    }\r\n\r\n    function getType() {\r\n        return type;\r\n    }\r\n\r\n    instance = {\r\n        convertFragment: convertFragment,\r\n        updateSegmentList: updateSegmentList,\r\n        getType: getType\r\n    };\r\n\r\n    setup();\r\n    return instance;\r\n}\r\n\r\nMssFragmentMoofProcessor.__dashjs_factory_name = 'MssFragmentMoofProcessor';\r\nexport default dashjs.FactoryMaker.getClassFactory(MssFragmentMoofProcessor); /* jshint ignore:line */\r\n"]}